VERS 00000001 4
HEAD 00001205 <?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="/resources/transform.xslt"?><header><componentName>correlator</componentName><version>9.10.0.0.275046</version><build>rel/9.10.0.x@275046</build><buildPlatform>amd64-win</buildPlatform><platform>Windows 7 (Service Pack 1)</platform><cputype>GenuineIntel family 6 model 12 stepping 3 Intel(R) Core(TM) i7-4790S CPU @ 3.20GHz</cputype><cpus>8</cpus><javaEnabled>true</javaEnabled><replayLogMode>inputLog</replayLogMode><args><arg>C:\SoftwareAG\Apama\bin\correlator.exe</arg><arg>--port</arg><arg>15903</arg><arg>--loglevel</arg><arg>INFO</arg><arg>--name</arg><arg>Apama Designer Correlator for task1(task1:defaultCorrelator)</arg><arg>-j</arg><arg>--inputLog</arg><arg>logs/defaultCorrelator_${START_TIME}_${ID}.input.log</arg></args><environment><variable>ALLUSERSPROFILE=C:\ProgramData</variable><variable>APAMA_HOME=C:\SoftwareAG\Apama</variable><variable>APAMA_WORK=C:\Users\Public\SoftwareAG\ApamaWork_9.10</variable><variable>APPDATA=C:\Users\istmapara\AppData\Roaming</variable><variable>COMMONPROGRAMFILES=C:\Program Files\Common Files</variable><variable>COMMONPROGRAMFILES(X86)=C:\Program Files (x86)\Common Files</variable><variable>COMMONPROGRAMW6432=C:\Program Files\Common Files</variable><variable>COMPUTERNAME=WIDB-2014-6</variable><variable>COMSPEC=C:\Windows\system32\cmd.exe</variable><variable>FP_NO_HOST_CHECK=NO</variable><variable>HDGUARD=C:\Program Files (x86)\RDT Global\HDGUARD\</variable><variable>HOMEDRIVE=Z:</variable><variable>HOMEPATH=\</variable><variable>HOMESHARE=\\userv-fs\istmapara</variable><variable>LOCALAPPDATA=C:\Users\istmapara\AppData\Local</variable><variable>LOGONSERVER=\\SAMBABDC</variable><variable>NUMBER_OF_PROCESSORS=8</variable><variable>OS=Windows_NT</variable><variable>PATH=C:\SoftwareAG\Apama\..\jvm\jvm\jre\bin\server;C:\SoftwareAG\Apama\..\jvm\jvm\jre\bin;C:\SoftwareAG\Apama\..\jvm\jvm\jre\bin\server;C:\SoftwareAG\Apama\..\jvm\jvm\jre\bin;C:\Users\Public\SoftwareAG\ApamaWork_9.10\lib;C:\SoftwareAG\Apama\bin;C:\oraclexe\app\oracle\product\11.2.0\server\bin;C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\Windows Kits\8.1\Windows Performance Toolkit\;C:\Program Files\Microsoft SQL Server\110\Tools\Binn\;C:\Program Files (x86)\Microsoft SQL Server\100\Tools\Binn\;C:\Program Files\Microsoft SQL Server\100\Tools\Binn\;C:\Program Files\Microsoft SQL Server\100\DTS\Binn\;C:\Program Files (x86)\Microsoft SQL Server\100\Tools\Binn\VSShell\Common7\IDE\;C:\Program Files (x86)\Microsoft SQL Server\100\DTS\Binn\;C:\Program Files\Java\jdk1.6.0_21\bin;C:\Program Files\Git\cmd;C:\Program Files\TortoiseGit\bin</variable><variable>PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC</variable><variable>PENTAHO_JAVA_HOME=C:\PENTAHO\jdk1.6.0_21</variable><variable>PROCESSOR_ARCHITECTURE=AMD64</variable><variable>PROCESSOR_IDENTIFIER=Intel64 Family 6 Model 60 Stepping 3, GenuineIntel</variable><variable>PROCESSOR_LEVEL=6</variable><variable>PROCESSOR_REVISION=3c03</variable><variable>PROGRAMDATA=C:\ProgramData</variable><variable>PROGRAMFILES=C:\Program Files</variable><variable>PROGRAMFILES(X86)=C:\Program Files (x86)</variable><variable>PROGRAMW6432=C:\Program Files</variable><variable>PROMPT=$P$G</variable><variable>PSMODULEPATH=C:\Windows\system32\WindowsPowerShell\v1.0\Modules\</variable><variable>PUBLIC=C:\Users\Public</variable><variable>SESSIONNAME=Console</variable><variable>SYSTEMDRIVE=C:</variable><variable>SYSTEMROOT=C:\Windows</variable><variable>TEMP=C:\Users\ISTMAP~2\AppData\Local\Temp</variable><variable>TMP=C:\Users\ISTMAP~2\AppData\Local\Temp</variable><variable>USERDOMAIN=FBI-USERV</variable><variable>USERNAME=istmapara</variable><variable>USERPROFILE=C:\Users\istmapara</variable><variable>VBOX_MSI_INSTALL_PATH=C:\Program Files\Oracle\VirtualBox\</variable><variable>VS120COMNTOOLS=C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\Tools\</variable><variable>WINDIR=C:\Windows</variable><variable>WINDOWS_TRACING_FLAGS=3</variable><variable>WINDOWS_TRACING_LOGFILE=C:\BVTBin\Tests\installpackage\csilogfile.log</variable></environment><version>9.10.0.0.275046</version></header>
RAND 0000000a 2471252013
TIME 00000010 1484234969.278,1
CONN 0000003e 10612171611911497990:10613948555848853766 from 127.0.0.1:63395
TIME 0000000e 1484234969.6,1
MONF 0000022b /*
	$Copyright(c) 2011 Progress Software Corporation (PSC). All rights reserved.$ 
	$Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$ 
	Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
*/

package com.apama.correlator;

/** For internal use only. 

@private*/
event ManagementAck {
	string response;
	integer uid;
}
 0000002f C:\SoftwareAG\Apama\monitors\ManagementImpl.mon
MONF 0000456e /*
	$Copyright(c) 2011-2013 Progress Software Corporation (PSC). All rights reserved.$ 
	$Copyright (c) 2013-2016 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$ 
	Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
	
	Requires ManagementImpl.mon
*/

package com.apama.correlator;

/**
 * EPL representation of the correlator status.
 */
event EngineStatus {
	/** 
	* @private
	*
	* Identifer prepended to user status keys to differentiate from standard keys.
	*/
	constant string userPrefix := "user-";

	/** @private*/
	dictionary<string,string> values;

	/**
	 * Get the time in ms that the Engine has been running for.
	 *
	 * @return The uptime of the Engine.
	 */
	action getUptime() returns integer {
		return values["uptime"].toInteger();
	}

	/**
	 * Get the number of contexts active in the Engine.
	 *
	 * @return The number of contexts active.
	 */
	action getNumContexts() returns integer {
		return values["numContexts"].toInteger();
	}

	/**
	 * Get the number of monitors defined in the Engine.
	 *
	 * @return The number of monitors defined.
	 */
	action getNumMonitors() returns integer {
		return values["numMonitors"].toInteger();
	}
	
	/**
	 * Get the number of monitor processes or active
	 * sub-monitors. If a monitor spawns it creates a new
	 * process.
	 *
	 * @return The number of monitor processes.
	 */
	action getNumProcesses() returns integer {
		return values["numProcesses"].toInteger();
	}
	
	/**
	 * Get the number of Java (JMon) Applications defined in the Engine.
	 *
	 * @return The number of Java Applications.
	 */
	action getNumJavaApplications() returns integer {
		return values["numJavaApplications"].toInteger();
	}
	
	/**
	 * Get the number of active listeners.
	 *
	 * @return The number of active listeners.
	 */
	action getNumListeners() returns integer {
		return values["numListeners"].toInteger();
	}
	
	/**
	 * Get the number of event types defined.
	 *
	 * @return The number of event types.
	 */
	action getNumEventTypes() returns integer {
		return values["numEventTypes"].toInteger();
	}
	
	/**
	 * Get the total number of events waiting on the route queues (value of
	 * 'rq' in the correlator status line).
	 *
	 * @return The number of waiting events.
	 */
	action getNumQueuedFastTrack() returns integer {
		return values["numQueuedFastTrack"].toInteger();
	}
	
	/**
	 * Get the total number of events waiting on the input queues (value of
	 * 'iq' in the correlator status line).
	 *
	 * @return The number of waiting events.
	 */
	action getNumQueuedInput() returns integer {
		return values["numQueuedInput"].toInteger();
	}
	
	/**
	 * Get the number of events received since the Engine started.
	 *
	 * @return The number of events received.
	 */
	action getNumReceived() returns integer {
		return values["numReceived"].toInteger();
	}
	
	/**
	 * Get the number of events received on the internal input
	 * queue since the Engine started.
	 *
	 * @return The number of events received.
	 */
	action getNumFastTracked() returns integer {
		return values["numFastTracked"].toInteger();
	}
	
	/**
	 * Get the number of event consumers connected to the
	 * engine.
	 *
	 * @return The number of event consumers.
	 */
	action getNumConsumers() returns integer {
		return values["numConsumers"].toInteger();
	}
	
	/**
	 * Get the number of events waiting on the output queue.
	 *
	 * @return The number of events waiting.
	 */
	action getNumOutEventsQueued() returns integer {
		return values["numOutEventsQueued"].toInteger();
	}

	/**
	 * Gets the number of output events which have been
	 * put onto the output queue. This corresponds to the
	 * number of MonitorScript emit commands executed.
	 *
	 * @return The number of events emitted.
	 */
	action getNumOutEventsCreated() returns integer {
		return values["numEmits"].toInteger();
	}
	
	/**
	 * This is the number of output events sent out by the
	 * correlator process. This differs from getNumOutEventsCreated
	 * since events can be of interest to a varying number of
	 * consumers, and can be dropped by the output queue.
	 *
	 * @return The number of events sent.
	 */
	action getNumOutEventsSent() returns integer {
		return values["numOutEventsSent"].toInteger();
	}
	
	/**
	 * Get the queue size of the most backed up context.
	 *
	 * @return The number of events queued.
	 */
	action getMostBackedUpQueueSize() returns integer {
		return values["mostBackedUpICQueueSize"].toInteger();
	}
	
	/**
	 * Get the number of active sub-listeners.
	 *
	 * @return The number of sub-listeners.
	 */
	action getNumSubListeners() returns integer {
		return values["numSubListeners"].toInteger();
	}
	
	/**
	 * Get the number of events taken off the input queue and processed 
	 * since the Engine started.
	 *
	 * @return The number of events processed.
	 */
	action getNumProcessed() returns integer {
		return values["numProcessed"].toInteger();
	}

	/**
	 * Get the name of the most backed up context.
	 *
	 * @return Name of the slowest context.
	 */
	action getMostBackedUpInput() returns string {
		return values["mostBackedUpInputContext"];
	}

	/**
	 * Get the name of the slowest receiver.
	 *
	 * @return The slowest receiver.
	 */
	action getSlowestReceiver() returns string {
		return values["slowestReceiver"];
	}

	/**
	 * Get the queue size of the slowest receiver.
	 *
	 * @return The queue size of the slowest receiver.
	 */
	action getSlowestReceiverQueueSize() returns integer {
		return values["slowestReceiverQueueSize"].toInteger();
	}

	/** @private */
	action prep(string input) returns string {
		return userPrefix + input;
	}

	/**
	 * Get a user-set status value of type float OR the alternative value specified if the key does not exist.
	 *
	 * @param key The name of the value to get.
	 * @param alt The alternative value to return if the key does not exist.
	 * @return The user status of type float or the alternate value if the key does not exist.
	 */
	action getUserFloatOr(string key, float alt) returns float {
		key := prep(key);
		if(values.hasKey(key)) then {
			return float.parse(values[key]);
		} else {
			return alt;
		}
	}

	/**
	 * Get a user-set status value of type integer OR the alternative value specified if the key does not exist.
	 *
	 * @param key The name of the value to get.
	 * @param alt The alternative value to return if the key does not exist.
	 * @return The user status of type integer or the alternate value if the key does not exist.
	 */
	action getUserIntegerOr(string key, integer alt) returns integer {
		key := prep(key);
		if(values.hasKey(key)) then {
			return integer.parse(values[key]);
		} else {
			return alt;
		}
	}

	/**
	 * Get a user-set status value of type boolean OR the alternative value specified if the key does not exist.
	 *
	 * @param key The name of the value to get.
	 * @param alt The alternative value to return if the key does not exist.
	 * @return The user status of type boolean or the alternate value if the key does not exist.
	 */
	action getUserBooleanOr(string key, boolean alt) returns boolean {
		key := prep(key);
		if(values.hasKey(key)) then {
			return boolean.parse(values[key]);
		} else {
			return alt;
		}
	}

	/**
	 * Get a user-set status value of type string OR the alternative value specified if the key does not exist.
	 *
	 * @param key The name of the value to get.
	 * @param alt The alternative value to return if the key does not exist.
	 * @return The user status of type string or the alternate value if the key does not exist.
	 */
	action getUserStringOr(string key, string alt) returns string {
		key := prep(key);
		if(values.hasKey(key)) then {
			return values[key];
		} else {
			return alt;
		}
	}

	/**
	 * Get a user-set status value of type float.
	 *
	 * @param key The name of the value to get.
	 * @return The user status of type float.
	 */
	action getUserFloat(string key) returns float {
		return float.parse(values[prep(key)]);
	}

	/**
	 * Get a user-set status value of type integer.
	 *
	 * @param key The name of the value to get.
	 * @return The user status of type integer.
	 */
	action getUserInteger(string key) returns integer {
		return integer.parse(values[prep(key)]);
	}

	/**
	 * Get a user-set status value of type boolean.
	 *
	 * @param key The name of the value to get.
	 * @return The user status of type boolean.
	 */
	action getUserBoolean(string key) returns boolean {
		return boolean.parse(values[prep(key)]);
	}

	/**
	 * Get a user-set status value of type string.
	 *
	 * @param key The name of the value to get.
	 * @return The user status of type string.
	 */
	action getUserString(string key) returns string {
		return values[prep(key)];
	}

	/** Get the full correlator status value dictionary .
	 *
	 * @return The full correlator status value dictionary.
	 */
	action getValues() returns dictionary<string,string> {
		return values;
	}
}


/**
 * EPL interface to the persistence functionality of the correlator.
 */
event Persistence {
	/**
	 * Asynchronously request a Correlator state persistence operation.
	 *
	 * At some point after this action is called, the correlator will commit its persistent state to storage. Once the commit has completed
	 * successfully, the provided callback will be invoked.
	 */
	action persist(action<> callback) {
		integer uid := integer.getUnique();
		management.asyncRequestSeq("doPersistNow", new sequence<string>, uid);
		on ManagementAck(uid = uid) {
			callback();
		}
	}

	/** @private*/
	import "ManagementPlugin" as management;
}

/**
 * EPL interface to the generic component management functionality of the correlator.
 */
event Component {

	/**
	 * Argument for attach/detachAsEventConsumer - use legacy mode.
	 * In this mode, all events are delivered in serial to the receiver on the default channel.
	 */
	constant integer CONNECT_LEGACY := 0;
	/**
	 * Argument for attach/detachAsEventConsumer - use parallel mode.
	 * In this mode, all events are delivered in parallel per channel.
	 */
	constant integer CONNECT_PARALLEL := 1;

	/** @private*/
	import "ManagementPlugin" as management;
	/**
	 * Get the hostname of the server the correlator is running on.
 	 */
	action getHostname() returns string {
		return management.getHostname();
	}
	/**
	 * Get the component name of the correlator.
	 */
	action getComponentName() returns string {
		return management.getComponentName();
	}
	/**
	 * Get the port the correlator is running on.  This is the
	 * main port number; extra ports specified via the config file
	 * are not accessible.
	 */
	action getComponentPort() returns integer {
		return management.getComponentPort();
	}
	/** 
	 * Get the correlator's logical ID.  This is a unique ID assigned to every correlator process at startup.
	 */
	action getComponentLogicalId() returns string {
		return management.getComponentLogicalId();
	}
	/** 
	 * Get the correlator's physical ID.  This is a unique ID generated for a component.
	 */
	action getComponentPhysicalId() returns string {
		return management.getComponentPhysicalId();
	}
	/**
	 * Get the number of CPUs the correlator has available to it.
	 */
	action getNumberCPUs() returns integer {
		return management.getNumberCPUs();
	}
	/**
	 * Get whether or not correlator is running with external clocking on.
	 */
	action isExternallyClocked() returns boolean {
		return management.isExternallyClocked();
	}

	/** Get the current license mode of the correlator - either "nolicensefile" or "licensefilesupplied". */
	action getLicenseMode() returns string {
		return management.getLicenseMode();
	}

	/**
	* Get the correlator status, internal values and user added stats.
	*
	* @return EngineStatus a representation of all status values 
	* including user added values.
	*/
	action getStatus() returns EngineStatus {
		string statusString := management.getStatus();
		return EngineStatus(dictionary<string,string>.parse(statusString));
	}

	/**
	* Set a specific value on a user added status, If the status
	* doesn't already exist this will add it.
	*
	* Note the value must be in string format.
	*
	* @param name The name of the user status to add.
	* @param value The value associated with the user Status value.
	*/
	action setUserStatus(string name, string value) {
		management.setUserStatus(name, value);
	}

	/**
	* Delete a specific user added status.
	*
	* @param name The name of the user status value to delete.
	*/
	action deleteUserStatus(string name) {
		management.deleteUserStatus(name);
	}

	/** @private*/
	action _escapeChannel(string c) returns string {
		if c.find(" ")=-1 and c.find("\n")=-1 and c.find("\\")=-1 then {
			return c;
		}
		return c.replaceAll("\\", "\\\\").replaceAll(" ", "\\x20").replaceAll("\n","\\n");
	}


	/**
	 * Connect to another Apama component to receive events on the specified channels.
	 * connectMode should be one of CONNECT_LEGACY or CONNECT_PARALLEL.
	 */
	action attachAsEventConsumerTo(string host, integer port, sequence<string> channels, boolean disconnectSlow, integer connectMode) {
		string channel;
		string parallel:="";
		if connectMode = CONNECT_PARALLEL then {
			parallel := "parallel ";
		}
		string disconnectSlowStr := "";
		if disconnectSlow then {
			disconnectSlowStr := "disconnectSlow ";
		}
		for channel in channels {
			management.asyncRequestSeq("addReceiveConnection",
			                           [host + " "+disconnectSlowStr + parallel + port.toString() + " " + _escapeChannel(channel)], -1);
		}
	}
	/**
	 * Disconnect from another Apama component to receive events on the specified channels.
	 * connectMode should be one of CONNECT_LEGACY or CONNECT_PARALLEL.
	 */
	action detachAsEventConsumerFrom(string host, integer port, sequence<string> channels, integer connectMode) {
		string channel;
		string parallel:="";
		if connectMode = CONNECT_PARALLEL then {
			parallel := "parallel ";
		}
		for channel in channels {
			management.asyncRequestSeq("removeReceiveConnection", 
			                           [host + " "+ parallel + port.toString() + " " + _escapeChannel(channel)], -1);
		}
	}
}

/**
 * EPL interface to correlator logging functionality. All methods on this interface are identical to the equivalent engine_management
 * requests, which are described in more detail in the user documentation.
 */
event Logging {
	/** @private*/
	import "ManagementPlugin" as management;

	/**
	 * Schedule simultaneous rotation of all correlator logs, including application logs and the input log. The rotation will happen shortly
	 * after this call.
	 */
	action rotateLogs() {
		management.asyncRequestSeq("rotateLogs", new sequence<string>, -1);
	}

	/** Change the file that the correlator logs to. */
	action setLogFile(string filename) {
		string ignore := management.syncRequestSeq("setLogFile", [filename]);
	}

	/** Set the destination of EPL log messages from the given package. A blank package is the root package. */
	action setApplicationLogFile(string pkg, string filename) {
		if(pkg = "") then {
			string ignore := management.syncRequestSeq("setApplicationLogFile", [filename]);
		} else {
			string ignore := management.syncRequestSeq("setApplicationLogFile", [filename, pkg]);
		}
	}

	/** Set the log level threshold of EPL log messages from the given package. A blank package is the root package. */
	action setApplicationLogLevel(string pkg, string level) {
		if(pkg = "") then {
			string ignore := management.syncRequestSeq("setApplicationLogLevel", [level]);
		} else {
			string ignore := management.syncRequestSeq("setApplicationLogLevel", [level, pkg]);
		}
	}

	/** Return the destination file for EPL log messages from the given package. A blank package is the root package. */
	action getApplicationLogFile(string pkg) returns string {
		if(pkg = "") then {
			return management.syncRequestSeq("getApplicationLogFile", new sequence<string>);
		} else {
			return management.syncRequestSeq("getApplicationLogFile", [pkg]);
		}
	}

	/** Return the log level threshold of EPL log messages from the given package. A blank package is the root package. */
	action getApplicationLogLevel(string pkg) returns string {
		if(pkg = "") then {
			return management.syncRequestSeq("getApplicationLogLevel", new sequence<string>);
		} else {
			return management.syncRequestSeq("getApplicationLogLevel", [pkg]);
		}
	}

	/** Reset logging for the given package to the default. A blank package is the root package. */
	action unsetApplicationLogFile(string pkg) {
		if(pkg = "") then {
			string ignore := management.syncRequestSeq("unsetApplicationLogFile", new sequence<string>);
		} else {
			string ignore := management.syncRequestSeq("unsetApplicationLogFile", [pkg]);
		}
	}

	/** Remove the log level from the given package, returning it to default. A blank package is the root package. */
	action unsetApplicationLogLevel(string pkg) {
		if(pkg = "") then {
			string ignore := management.syncRequestSeq("unsetApplicationLogLevel", new sequence<string>);
		} else {
			string ignore := management.syncRequestSeq("unsetApplicationLogLevel", [pkg]);
		}
	}
}
 0000002b C:\SoftwareAG\Apama\monitors\Management.mon
MONF 00000528 //*****************************************************************************
// Title:       ScenarioDeleterSupport
// Description: Provides event definitions for deleting Scenario instances. 
//
// Revision:    $Id: ScenarioDeleterSupport.mon 249541 2015-03-09 11:42:24Z bsp $
//
// $Copyright(c) 2004-2005, 2008-2009 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.scenarios;

event DeleteAllScenarios {
	constant string CHANNEL := "ScenarioDeleter";
}

event DeleteScenariosByUser {
	string owner;
}

monitor ScenarioDeleterSupport {
	
	action onload() {
		
		DeleteAllScenarios deleteAll;
		on all DeleteAllScenarios():deleteAll {
			send deleteAll to DeleteAllScenarios.CHANNEL;
		}
		
		DeleteScenariosByUser deleteByUser;
		on all DeleteScenariosByUser():deleteByUser {
			send deleteByUser to DeleteAllScenarios.CHANNEL;
		}
	}
	
} 00000048 C:\SoftwareAG\Apama\monitors\scenario_support\ScenarioDeleterSupport.mon
MONF 0000476f /*
 * $Copyright (c) 2015 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$ 
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
 *
 * Event definitions for providing a set of functions to assist with date and time formatting.
 * 
 */

package com.apama.correlator.timeformat;

/** 
 * An event providing a time-parser object that you can then use 
 * to make multiple calls using its <tt>parseTime()</tt> function, specifying
 * the date/time string to be parsed. 
 * 
 * Reusing a <tt>CompiledPattern</tt> object is significantly more efficient than 
 * providing the same time pattern (<tt>format</tt>) in multiple calls to parse 
 * functions defined on the <tt>TimeFormat</tt> event object.
 */
event CompiledPattern {
	/** @private*/ import "TimeFormatPlugin" as __plugin;
	/** @private*/ wildcard chunk __c;
	
	/**
	 * Parses the <tt>timeDate</tt> string according to the format provided
	 * by this time/date parser event object returning the result 
	 * as a <tt>float</tt> of seconds since the epoch, or <tt>NaN</tt> 
	 * if it cannot parse the specified string. 
	 *
	 * For more information about the return value, see the description of 
	 * "Time Format plug-in parse functions" in "Developing Apama Applications."
	 *
	 * @param timeDate String that represents a time and/or a date.
	 * @returns The resulting value of seconds since the epoch.
	 */
	action parseTime(string timeDate) returns float 
	{
		return __plugin.parseTimeFromPattern(__c, timeDate);
	}	
}

/** 
 * An event object providing a set of functions to assist with date and 
 * time formatting.
 */
event TimeFormat
{
	// Public
	
	/** 
	 * Converts the <tt>time</tt> parameter to the local time and returns 
	 * that time in the format specified.
	 *
	 * @param time Float that indicates the time you want to format. 
	 * This value is the number of seconds since the epoch in UTC.
	 * This is the same format used by the <tt>currentTime</tt> variable. 
	 * For information about the <tt>currentTime</tt> variable, see
	 * "Getting the current time" in "Developing Apama Applications".
	 * @param format String that specifies the format that you want 
	 * the returned time to have. For details about what you can specify 
	 * for the <tt>format</tt> string, see "Format specification for the TimeFormat 
	 * functions" in the documentation for "Developing Apama Applications".
	 * @returns A string representing the local time in the specified
	 * format.
	 */
	action format(float time, string format) returns string 
	{
		return __plugin.format(time, format);
	}
	
	/** 
	 * Converts the <tt>time</tt> parameter to the local time and returns 
	 * that time in the format specified. 
	 *
	 * The <tt>formatUTC()</tt> function always returns UTC (GMT no matter 
	 * what the local time is).
	 *
	 * @param time Float that indicates the time you want to format. 
	 * This value is the number of seconds since the epoch in UTC.
	 * This is the same format used by the <tt>currentTime</tt> variable. 
	 * For information about the <tt>currentTime</tt> variable, see
	 * "Getting the current time" in "Developing Apama Applications".
	 * @param format String that specifies the format that you want 
	 * the returned time to have. For details about what you can specify 
	 * for the <tt>format</tt> string, see "Format specification for the TimeFormat 
	 * functions" in the documentation for "Developing Apama Applications".
	 * @returns A string representing the local time in the specified
	 * format.
	 */
	action formatUTC(float time, string format) returns string 
	{
		return __plugin.formatUTC(time, format);
	}
	
	/** 
	 * Converts the <tt>time</tt> parameter, which is UTC, to the time in the time
	 * zone you specify and returns that time in the format you specify.
	 *
	 * @param time Float that indicates the time you want to format. 
	 * This value is the number of seconds since the epoch in UTC.
	 * This is the same format used by the <tt>currentTime</tt> variable. 
	 * For information about the <tt>currentTime</tt> variable, see
	 * "Getting the current time" in "Developing Apama Applications".
	 * @param format String that specifies the format that you want 
	 * the returned time to have. For details about what you can specify 
	 * for the <tt>format</tt> string, see "Format specification for the TimeFormat 
	 * functions" in the documentation for "Developing Apama Applications".
	 * @param tzName String that specifies the name of a time zone.
	 * @returns A string representing the local time in the specified
	 * format.
	 */
	action formatWithTimeZone(float time, string format, string tzName) returns string 
	{
		return __plugin.formatWithTimeZone(time, format, tzName);
	}

	/**
	 * Returns the local time as a float of seconds since the epoch (UTC).
	 * 
	 * This value has the same format as the <tt>currentTime</tt> variable. However, 
	 * the <tt>getTime()</tt> function returns the actual local time whereas the <tt>currentTime</tt> 
	 * variable contains the time that the event being processed was received by the 
	 * correlator. The time returned by the <tt>getTime()</tt> function is accurate to the
	 * millisecond except on Windows. On Windows, it returns a time that is accurate to 
	 * within 10 or 16 milliseconds depending on the machine configuration and Windows 
	 * version it is running on. 
	 * 
	 * <i>The Windows and UNIX versions of the Time Format plug-in are not guaranteed to return 
	 * the same time all the time. This is because the underlying system libraries that the plug-in 
	 * relies on have different interpretations of what constitutes local time in certain country 
	 * locales, in particular during summer time. This discrepancy is caused by the fact that at the 
	 * epoch, January 1st 1970, Great Britain was temporarily one hour ahead of UTC. Some UNIX system 
	 * libraries, like those on Solaris, account for this, others, like that on Windows, do not.</i>
	 *
	 * @returns The local time as a float of seconds since the epoch (UTC).
	 */
	action getSystemTime() returns float 
	{
		return __plugin.getTime();	
	}
		
	/**
	 * Parses the value contained by the <tt>timeDate</tt> parameter
	 * according to the format you specify in the <tt>format</tt> parameter, 
	 * interpreting it as a date and time in the local timezone. 
	 *
	 * The function returns the resulting value as a <tt>float</tt> of 
	 * seconds since the epoch, or <tt>NaN</tt> if it cannot parse the 
	 * specified string.
	 *
	 * e.g. <tt>float secsSinceEpoc := timeMgr.parseTime("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56");</tt>
	 *
	 * @param format String that specifies the format of the value in the 
	 * <tt>timeDate</tt> parameter. For details about what you can specify here, 
	 * see "Format specification for the Time Format plug-in functions"
	 * in "Developing Apama Applications."
	 * @param timeDate String that contains the time you want to parse.
	 * @returns The resulting value of seconds since the epoch.
	 */
	action parseTime(string format, string timeDate) returns float 
	{
		return __plugin.parseTime(format, timeDate);
	}
	
	/**
	 * Parses the value contained by the <tt>timeDate</tt> parameter
	 * according to the format you specify in the <tt>format</tt> parameter, 
	 * interpreting the <tt>timeDate</tt> as a UTC date and time. 
	 * 
	 * The returned value is a <tt>float</tt> of seconds since the epoch, or 
	 * <tt>NaN</tt> if it cannot parse the specified string.
	 *
	 * e.g. <tt>float secsSinceEpoc := timeMgr.parseTimeUTC("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56");</tt>
	 *
	 * @param format String that specifies the format of the value in the 
	 * <tt>timeDate</tt> parameter. For details about what you can specify here, 
	 * see "Format specification for the Time Format plug-in functions"
	 * in "Developing Apama Applications."
	 * @param timeDate String that contains the time you want to parse.
	 * @returns The resulting value of seconds since the epoch.
	 */	
	action parseTimeUTC(string format, string timeDate) returns float 
	{
		return __plugin.parseTimeUTC(format, timeDate);
	}	
	
	/**
	 * Parses the value contained by the <tt>timeDate</tt> parameter
	 * according to the format you specify in the <tt>format</tt> parameter, 
	 * interpreting it as a date and time in the named timezone specified
	 * by the <tt>tzName</tt> parameter. 
	 *
	 * The function returns the resulting value as a <tt>float</tt> of seconds 
	 * since the epoch, or <tt>NaN</tt> if it cannot parse the specified string.
	 *
	 * e.g. <tt>float secsSinceEpoc := timeMgr.parseTimeWithTimeZone("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56", "Europe/London");</tt>
	 *
	 * @param format String that specifies the format of the value in the 
	 * <tt>timeDate</tt> parameter. For details about what you can specify here, 
	 * see "Format specification for the Time Format plug-in functions"
	 * in "Developing Apama Applications."
	 * @param timeDate String that contains the time you want to parse.
	 * @param tzName String that specifies the name of a time zone.
	 * @returns The resulting value of seconds since the epoch.
	 */
	action parseTimeWithTimeZone(string format, string timeDate, string tzName) returns float 
	{
		return __plugin.parseTimeWithTimeZone(format, timeDate, tzName);
	}	
	
	/**
	 * Returns a <tt>CompiledPattern</tt> object that can generate the time as a <tt>float</tt> 
	 * value that corresponds to the local date/time string to be parsed. 
	 *
	 * You can use the <tt>CompiledPattern</tt> object to make multiple calls using its <tt>parseTime()</tt> 
	 * function, specifying the date/time string to be parsed. Reusing a <tt>CompiledPattern</tt> object is 
	 * significantly more efficient than providing the same time pattern (<tt>format</tt>) in multiple calls to 
	 * the parse functions defined on the <tt>TimeFormat</tt> event object.
	 * 
	 * Example:
	 *
	 * The following example shows how you can use the <tt>CompiledPattern</tt> object 
	 * returned by the <tt>compilePattern()</tt> function to make multiple calls using its 
	 * <tt>parseTime()</tt> function:
	 *
	 * <tt>TimeFormat timeFormat := new TimeFormat;</tt><br />
	 * <tt>CompiledPattern timePattern := timeFormat.compilePattern(pattern);</tt><br />
	 * <tt>t1:=timePattern.parseTime(time1);</tt><br />
	 * <tt>t2:=timePattern.parseTime(time2);</tt><br />
	 * <tt>t3:=timePattern.parseTime(time3);</tt>
	 *
	 * When you call the <tt>compilePattern()</tt> function and then the <tt>CompiledPattern</tt> object's
	 * <tt>parseTime()</tt> function, the result is the same as calling one of the parse functions defined on the 
	 * <tt>TimeFormat</tt> object itself. The advantage of calling the <tt>compilePattern()</tt> function
	 * and then the <tt>CompiledPattern</tt> object's <tt>parseTime()</tt> function is that it is faster. 
	 * For example:
	 * 
	 * <tt>timeFormat.parse("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56")</tt>
	 *
	 * If you use this pattern many times, it is faster to call <tt>compilePattern()</tt>, as follows:
	 *
	 * <tt>CompiledPattern timePattern := timeFormat.compilePattern("yyyy.MM.dd G 'at' HH:mm:ss");</tt><br />
	 * <tt>timePattern.parseTime(c,"1996.07.10 AD at 15:08:56");</tt>
	 *
	 * @param format String that specifies a set of instructions for parsing a time/date 
	 * object.
	 * @returns A CompiledPattern object that can generate the time as a <tt>float</tt> value
   * that corresponds to the local date/time string to be parsed.
	 */
	action compilePattern(string format) returns CompiledPattern {
		return CompiledPattern(__plugin.compilePattern(format));
	}
	
	/**
	 * Returns a <tt>CompiledPattern</tt> object that can generate the time as a <tt>float</tt> 
	 * value that corresponds to the UTC date/time string to be parsed. 
	 *
	 * You can use the <tt>CompiledPattern</tt> object to make multiple calls using its <tt>parseTime()</tt> 
	 * function, specifying the date/time string to be parsed. Reusing a <tt>CompiledPattern</tt> object is 
	 * significantly more efficient than providing the same time pattern (<tt>format</tt>) in multiple calls to 
	 * the parse functions defined on the <tt>TimeFormat</tt> event object.
	 * 
	 * Example:
	 *
	 * The following example shows how you can use the <tt>CompiledPattern</tt> object  
	 * returned by the <tt>compilePatternUTC()</tt> function to make multiple calls using its 
	 * <tt>parseTime()</tt> function:
	 *
	 * <tt>TimeFormat timeFormat := new TimeFormat;</tt><br />
	 * <tt>CompiledPattern timePattern := timeFormat.compilePatternUTC(pattern);</tt><br />
	 * <tt>t1:=timePattern.parseTime(time1);</tt><br />
	 * <tt>t2:=timePattern.parseTime(time2);</tt><br />
	 * <tt>t3:=timePattern.parseTime(time3);</tt>
	 *
	 * When you call the <tt>compilePatternUTC()</tt> function and then the <tt>CompiledPattern</tt> object's
	 * <tt>parseTime()</tt> function, the result is the same as calling one of the parse functions defined on the 
	 * <tt>TimeFormat</tt> object itself. The advantage of calling the <tt>compilePatternUTC()</tt> function
	 * and then the <tt>CompiledPattern</tt> object's <tt>parseTime()</tt> function is that it is faster. 
	 * For example:
	 * 
	 * <tt>timeFormat.parse("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56")</tt>
	 *
	 * If you use this pattern many times, it is faster to call <tt>compilePatternUTC()</tt>, as follows:
	 *
	 * <tt>CompiledPattern timePattern := timeFormat.compilePatternUTC("yyyy.MM.dd G 'at' HH:mm:ss");</tt><br />
	 * <tt>timePattern.parseTime(c,"1996.07.10 AD at 15:08:56");</tt>
	 *
	 * @param format String that specifies a set of instructions for parsing a time/date 
	 * object.
	 * @returns A CompiledPattern object that can generate the time as a <tt>float</tt> value
   * that corresponds to the UTC date/time string to be parsed.
	 */
	action compilePatternUTC(string format) returns CompiledPattern
	{
		return CompiledPattern(__plugin.compilePatternUTC(format));
	}
	 
	/**
	 * Returns a <tt>CompiledPattern</tt> object that can generate the time as a <tt>float</tt> 
	 * value that corresponds to the date/time string to be parsed, in the specified timezone. 
	 *
	 * You can then use the <tt>CompiledPattern</tt> object to make multiple calls using its <tt>parseTime()</tt> 
	 * function, specifying the date/time string to be parsed. Reusing a <tt>CompiledPattern</tt> object is 
	 * significantly more efficient than providing the same time pattern (<tt>format</tt>) in multiple calls to 
	 * the parse functions defined on the <tt>TimeFormat</tt> event object.
	 * 
	 * Example:
	 *
	 * The following example shows how you can use the <tt>CompiledPattern</tt> object 
	 * returned by the <tt>compilePatternWithTimeZone()</tt> function to make multiple calls 
	 * using its <tt>parseTime()</tt> function:
	 *
	 * <tt>TimeFormat timeFormat := new TimeFormat;</tt><br />
	 * <tt>CompiledPattern timePattern := timeFormat.compilePatternWithTimeZone(pattern, tzone);</tt><br />
	 * <tt>t1:=timePattern.parseTime(time1);</tt><br />
	 * <tt>t2:=timePattern.parseTime(time2);</tt><br />
	 * <tt>t3:=timePattern.parseTime(time3);</tt>
	 *
	 * When you call the <tt>compilePatternWithTimeZone()</tt> function and then the <tt>CompiledPattern</tt> object's 
	 * <tt>parseTime()</tt> function, the result is the same as calling one of the parse functions defined on the 
	 * <tt>TimeFormat</tt> object itself. The advantage of calling the <tt>compilePatternWithTimeZone()</tt> function
	 * and then the <tt>CompiledPattern</tt> object's <tt>parseTime()</tt> function is that it is faster. 
	 * For example:
	 * 
	 * <tt>timeFormat.parse("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56")</tt>
	 *
	 * If you use this pattern many times, it is faster to call <tt>compilePatternWithTimeZone()</tt>, as follows:
	 *
	 * <tt>CompiledPattern timePattern := timeFormat.compilePatternWithTimeZone("yyyy.MM.dd G 'at' HH:mm:ss", "Europe/London");</tt><br />
	 * <tt>timePattern.parseTime(c,"1996.07.10 AD at 15:08:56");</tt>
	 *
	 * @param format String that specifies a set of instructions for parsing a time/date 
	 * object.
	 * @param name String that specifies the name of a time zone.
	 * @returns A CompiledPattern object that can generate the time as a <tt>float</tt> value
   * that corresponds to the date/time string to be parsed, in the specified timezone.
	 */
	action compilePatternWithTimeZone(string format, string name) returns CompiledPattern
	{
		return CompiledPattern(__plugin.compilePatternWithTimeZone(format, name));
	}
	
	/**
	 * Returns a floating point (<tt>float</tt>) timestamp that represents the 
	 * number of seconds since an unspecified epoch (a zero point).
	 *
	 * The timestamp is accurate to one microsecond or better. The return value has no 
	 * necessary relationship to wall time or correlator time and should be used only 
	 * to compare similar timestamps. 
	 *
	 * Because the epoch is unspecified, you should use these timestamps in calculations 
	 * only with other timestamps generated by the <tt>getMicroTime()</tt> function or 
	 * with equivalent high-resolution timestamps generated by an Apama adapter.
	 * 
	 * For example, you might want to use high-resolution timestamps for calculating 
	 * event processing latency in an Apama application. You can compare the timestamps 
	 * across processes on the same machine. The timestamps are not comparable between 
	 * different machines.
	 * 
	 * @returns A floating point (<tt>float</tt>) timestamp that represents the 
	 * number of seconds since an unspecified epoch (a zero point). 
	 */
	action getMicroTime() returns float 
	{
		return __plugin.getMicroTime();
	}
	
	// Private
	
	/** @private*/ import "TimeFormatPlugin" as __plugin;
} 00000031 C:\SoftwareAG\Apama\monitors\TimeFormatEvents.mon
MONF 0000a34a //
// MemoryStore.mon
//
// Provide shared and (optionally) persistent storage to MonitorScripts
//
// $Copyright(c) 2009,2012-2013 Progress Software Corporation (PSC). All rights reserved.\$
// $Copyright (c) 2013-2015 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.\$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG

package com.apama.memorystore;

/** Sent to the application when an asynchronous activity has finished. 
*/
event Finished {
	/** A unique identifier for the operation that has completed, 
		which will have been returned by the action that initiated the 
		operation. */
	integer id;
	/** True if the operation succeeded. */
	boolean success;
	/** An optional status or error message providing more detail 
		about why the operation succeeded or failed. */
	string status;
}

/** Represents the schema for a table in the store, specifying the field 
	names, types, and other behavioural information about the table. 

	The fields and types sequences must be the same length as one another, 
	specifying the names of fields and their corresponding types.
	
	Never construct a Schema using a "Schema(...)" expression. 
	Instead, always create a variable initialized to "new Schema", and then set 
	parameters individually with separate statements. This ensures that your 
	code will continue to work without modification if a subsequent version 
	of the MemoryStore adds more parameters to the Schema event.
	
	@see Store#prepare() The schema for a table is specified when it is 
		prepared. 
*/
event Schema {
	/** A sequence specifying the name of each field in this table. 

		For looking up the index of a specific field name (e.g. while 
		processing RowChanged events), use Table.getFieldIndex() which is 
		more efficient than using indexOf() on the fields sequence.
		
		@see Table#getFieldIndex() for efficiently obtaining the index of 
		a field.
	**/
	wildcard sequence<string> fields;
	
	/** A sequence specifying the type of each field in this table. 
	
		Permitted types are currently: 'integer', 'boolean', 'float' and 
		'string'. 
		
		This sequence must have the same length as the fields sequence. 
	*/
	wildcard sequence<string> types;
	
	/** When this field is true, the MemoryStore makes the rows in the 
		in-memory table associated with this schema available to the 
		scenario service, so they can be used by external clients and 
		dashboards. 
		
		That is, the MemoryStore creates DataViews that contain the state of 
		this table that has been committed (but not necessarily persisted) to 
		the shared in-memory representation of the table.
		
		Committing changes to the in-memory row in a table that is exposing 
		its in-memory state causes events to be sent to the main context. 
	 */
	boolean exposeMemoryView;
	/** When this field is true, the MemoryStore makes the rows in the 
		on-disk table associated with this schema available to the 
		scenario service, so they can be used by external clients and 
		dashboards.  
		
		That is, the MemoryStore creates DataViews that contain data from this 
		table that has been persisted to disk. 
		
		You cannot expose a persistent view of a table in a 
		correlator-persistent store.
 	*/
	boolean exposePersistentView;
	
	/** Specifies the display name for an in-memory table. */
	string memoryViewDisplayName;
	/** Describes an in-memory table. */
	string memoryViewDescription;
	/** Specifies the display name for an on-disk table. */
	string persistentViewDisplayName;
	/** Describes an on-disk table. */
	string persistentViewDescription;
}

/** Represents an ordered and typed set of named fields in a table, with a 
	key that uniquely identifies the row within the table. 

	A Row is an atomic snapshot of the data in the
	table and once returned, a Row's contents are guaranteed to be consistent 
	and unchanging.

	Any changes the user makes to a Row are local until commit is called.
	
	@see Table A table holds a collection of rows. 
*/
event Row {
	/** @private*/ import "MemoryStorePlugin" as plugin;
	/** @private*/ wildcard chunk c;

	/** Update the local Row event to reflect the current state of the shared
		MemoryStore table, losing any local modifications.
	
		row.update() has a very similar effect to r := t.get(r.getKey()),
		but is more efficient and doesn't require access to the table.
	*/
	action update() {
		plugin.RowChunk_update(c);
	}

	/** Copy the contents of the specified other Row into this one.
	
		The two rows that these Row events represent must have the same schema 
		but they need not be in the same table.

		r1.copy(r2) is a more efficient equivalent to
		r1.setX("a", r2.getX("a")) for every field. 
		
		You cannot copy a row between a correlator-persistent store and an 
		in-memory, on-disk or distributed store.
	*/
	action copy(Row other) {
		plugin.RowChunk_copy(c, other.c);
	}

	/** Mark the row for deletion when the table is committed.
	
		Fields cannot be accessed after this call, until the removal is
		successfully committed (or reverted using update).
	*/
	action remove() {
		plugin.RowChunk_remove(c);
	}
	
	/** Try to commit changes from this Row back to the table, returning false 
		if the Row is not up to date.
	
		If nothing else has modified the row in the table since this
		Row was created, the changes are committed so other users can
		see them and true is returned.
	
		Otherwise, false is returned and the table is left unchanged. 
		Do not repeatedly call tryCommit() without also calling update(), 
		or use the more efficient Row.tryCommitOrUpdate(). 
		
		Note that a MemoryStore commit operation synchronously writes changes 
		made to the local Row instance back to the table which is shared by all 
		monitors inside the Correlator (or the distributed store), but does not 
		cause a persistent write to disk (see Table#persist). 

		@return true if the table was modified; false if an error occurred and 
		the table was not changed. 
		
		@see Row#tryCommitOrUpdate()
	*/
	action tryCommit() returns boolean {
		return plugin.RowChunk_tryCommit(c,currentTime);
	}


	/** Try to commit changes from this Row back to the table, which could 
		result in an exception being thrown if the Row is not up to date.
	
		If nothing else has modified the row in the table since this
		Row was created, the changes are committed so other users can
		see them.
	
		Otherwise, the monitor instance terminates with an error and the table 
		is left unchanged.
		
		If there is any chance that the same row may be written to 
		concurrently - for example by multiple correlator contexts, and/or if 
		using a distributed MemoryStore - use Row.tryCommit() instead of 
		Row.commit() so that it is possible to recover from this situation 
		when it occurs. 

		Note that a MemoryStore commit operation synchronously writes changes 
		made to the local Row instance back to the table which is shared by all 
		monitors inside the Correlator (or the distributed store), but does not 
		cause a persistent write to disk (see Table#persist). 

		@see Row#tryCommit()
		@see Row#tryCommitOrUpdate()
	*/
	action commit() {
		plugin.RowChunk_commit(c,currentTime);
	}

	/** Try to commit, or update if not. 
	
		This is a more efficient equivalent to calling tryCommit then
		calling update if returning false.
	
		Note that a MemoryStore commit operation synchronously writes changes 
		made to the local Row instance back to the table which is shared by all 
		monitors inside the Correlator (or the distributed store), but does not 
		cause a persistent write to disk (see Table#persist). 
		
		@return true if the commit succeeded, false if the commit failed but 
		the row has been updated ready for a retry attempt. 
		
	*/
	action tryCommitOrUpdate() returns boolean {
		return plugin.RowChunk_tryCommitOrUpdate(c,currentTime);
	}

	/** Get the key for this Row. 
	
		It cannot be changed.
	*/
	action getKey() returns string {
		return plugin.RowChunk_getKey(c);
	}

	/** Indicate whether this row was in the table when the Row
		was created or updated. 
		
		It is possible to construct a Row that has no corresponding entry in 
		the table, in which case all fields have default values. 
		
		Calling commit on a Row for which inTable()=false will create the row.
	*/
	action inTable() returns boolean {
		return plugin.RowChunk_inTable(c);
	}

	// Get the value
	//
	// The correct variant must be called for the type of the column
	// in the table.

	/** Get the value of the specified field in this row 
		(must only be used on boolean fields). 
	*/
	action getBoolean(string name) returns boolean {
		return plugin.RowChunk_getBoolean(c,name);
	}

	/** Get the value of the specified field in this row 
		(must only be used on integer fields). 
	*/
	action getInteger(string name) returns integer {
		return plugin.RowChunk_getInteger(c,name);
	}

	/** Get the value of the specified field in this row 
		(must only be used on float fields). 
	*/
	action getFloat(string name) returns float {
		return plugin.RowChunk_getFloat(c,name);
	}

	/** Get the value of the specified field in this row 
		(must only be used on string fields). 
	*/
	action getString(string name) returns string {
		return plugin.RowChunk_getString(c,name);
	}

	// Set the value
	//
	// The correct variant must be called for the type of the column
	// in the table.

	/** Set the value of the specified field in this row 
		(must only be used on boolean fields). 
	*/
	action setBoolean(string name, boolean b) {
		plugin.RowChunk_setBoolean(c,name,b);
	}

	/** Set the value of the specified field in this row 
		(must only be used on integer fields). 
	*/
	action setInteger(string name, integer i) {
		plugin.RowChunk_setInteger(c,name,i);
	}

	/** Set the value of the specified field in this row 
		(must only be used on float fields). 
	*/
	action setFloat(string name, float f) {
		plugin.RowChunk_setFloat(c,name,f);
	}

	/** Set the value of the specified field in this row 
		(must only be used on string fields). 
	*/
	action setString(string name, string s) {
		plugin.RowChunk_setString(c,name,s);
	}

	/** Get the name of the Table that contains this Row. */
	action getTableName() returns string {
		return plugin.RowChunk_getTableName(c);
	}

	/** Get the name of the Store that contains this Row's Table. */
	action getStoreName() returns string {
		return plugin.RowChunk_getStoreName(c);
	}
}


/**
 * Sent to the application on every successful row commit in tables
 * the application has subscribed to.
 *
 * Supported in distributed stores only.
 *
 * Events are sent for every change, whether from the local or a
 * remote node, for tables where the subscribe method has been called.
 *
 * The old and new values are provided as sequences.  Access to previous 
 * and new values are thus available (though note the setting of
 * rowChangedOldValueRequired); for example:
 <pre>
<br/>	integer positionRowId := tbl.getFieldIndex("position");
<br/>	RowChanged rowChanged;
<br/>	on all RowChanged(storeName = STORE, 
<br/>	                  tableName = TABLE):rowChanged {
<br/>		// we handle things simply by treating an update as a remove followed by an insert:
<br/>		if (rowChanged.changeType = RowChanged.REMOVE or
<br/>		    rowChanged.changeType = RowChanged.UPDATE) then {
<br/>			position := position - float.parse(rowChanged.oldFieldValues[positionRowId]);
<br/>		}
<br/>		if rowChanged.changeType = RowChanged.INSERT or
<br/>		   rowChanged.changeType = RowChanged.UPDATE then {
<br/>			position := position + float.parse(rowChanged.newFieldValues[positionRowId]);
<br/>		}
<br/>		log "Position is now "+position.toString();
<br/>	}
 </pre>
 * @see Table#subscribeRowChanged() for subscribing to RowChanged events
 */
event RowChanged {
	/** Value for changeType when a row is added to a table. */
	constant integer INSERT := 1;

	/** Value for changeType when a row is removed from a table. */
	constant integer REMOVE := 2;

	/** Value for changeType when a row is modified in a table. */
	constant integer UPDATE := 3;

	/**
	 * One of INSERT, REMOVE, UPDATE for
	 * rows being added, removed, updated.
	 */
	integer changeType;

	/**
	 * Name of the store that the table is in.
	 */
	string storeName;

	/**
	 * Name of the table that the row is in.
	 */
	string tableName;

	/**
	 * The key value for the changed row.
	 */
	string key;

	/**
	 * Old values of the row, if available.
	 *
 	 * The old values of the row, in toString() format, in the
	 * order defined by the table's Schema.  For UPDATE
	 * changeTypes, this is only populated if the storeFactory
	 * bean property rowChangedOldValueRequired is true (the
	 * default value is provider-specific).
	 *
	 * For INSERT (or UPDATE if rowChangedOldValueRequired is
	 * false), this will be an empty sequence, otherwise it will
	 * have as many entries as there are fields in the schema.
	 *
	 * The field values can be recovered by using the parse method
	 * on the field's type
	 * (e.g. <tt>integer.parse(rc.oldFieldValues[i])</tt>),except
	 * for strings which are inserted without any escaping, so do
	 * not need to be parsed. 
	 *
	 * Use Table.getFieldIndex() to efficiently map a field name
	 * to an index in this sequence (although consider caching the
	 * index in a variable to avoid unnecessary lookups).
	 *
	 * @see Table#getFieldIndex() for mapping from field name to
	 * index.
	 */
	sequence<string> oldFieldValues;

	/**
	 * New values of the row.
	 *
 	 * The new values of the row, in toString() format, in the order defined 
	 * by the table's Schema.
	 *
	 * For REMOVE, this will be an empty sequence, otherwise it 
	 * will have as many entries as there are fields in the schema.
	 *
	 * The field values can be recovered by using the parse method
	 * on the field's type (e.g. <tt>integer.parse(rc.newFieldValues[i])</tt>), 
	 * except for strings which are inserted without any escaping, so do not 
	 * need to be parsed. 
	 *
	 * Use Table.getFieldIndex() to efficiently map a field name to an index 
	 * in this sequence (although consider caching the index in a 
	 * variable to avoid unnecessary lookups).
	 *
	 * @see Table#getFieldIndex() for mapping from field name to index. 
	 */
	sequence<string> newFieldValues;
	
	/** 
	 * Get a display string representing this event's change type. 
	 *
	 * @return "INSERT", "REMOVE" or "UPDATE". 
	 */
	action getChangeTypeString() returns string {
		if changeType = INSERT then {
			return "INSERT";
		} else if changeType = REMOVE then {
			return "REMOVE";
		} else if changeType = UPDATE then {
			return "UPDATE";
		} else {
			return "UNKNOWN:"+changeType.toString();
		}
	}
}

/** Represents an iterator that can be used to step through each 
	Row of a Table in turn, making changes or reading data from the row. 
	
	@see Table#begin() Gets an iterator, beginning from the start of the table.
*/
event Iterator {
	/** @private*/ import "MemoryStorePlugin" as plugin;
	/** @private*/ wildcard chunk c;

	/** Checks whether this Iterator has now reached the end of
		the Table. 
	
		You should check done() is not true before you call other Iterator 
		actions (except for appendKeys() and getKeys()).
	*/
	action done() returns boolean {
		return plugin.IteratorChunk_done(c);
	}

	/** Step this Iterator to the next row in the table.
	
		If there are no more rows the Iterator becomes done. 
		
		To avoid an error that will terminate the monitor instance, always 
		use done() to check that the iterator has not reached the end of the 
		table before calling this action. 		
	*/
	action step() {
		plugin.IteratorChunk_step(c);
	}
	
	/** Get the key for the row this Iterator is pointing at.
	
		To avoid an error that will terminate the monitor instance, always 
		use done() to check that the iterator has not reached the end of the 
		table before calling this action. 
	*/
	action getKey() returns string {
		return plugin.IteratorChunk_getKey(c);
	}

	/** Get the Row this Iterator is pointing at.
	
		It is possible that the row the iterator is pointing at is no longer 
		present. This can happen if another monitor deleted the row or table, 
		or cleared the table while the iterator was pointing at that row.

		If the requested row is no longer there, you receive a Row event that 
		represents a row in which all fields have default values and for which 
		Row.inTable() is false. This is the same result as if you call 
		Table.get() on a key that does not exist yet.
	
		To avoid an error that will terminate the monitor instance, always 
		use done() to check that the iterator has not reached the end of the 
		table before calling this action. 
	*/
	action getRow() returns Row {
		return Row(plugin.IteratorChunk_getRow(c));
	}

	/** Append to the specified sequence, keys for up to n consecutive
		rows of the Table, beginning where this Iterator is pointing.
	
		The iterator will be advanced. If it becomes
		done then fewer than n keys will be appended.
		
		@param seq The sequence which is to be updated with the keys from the 
		following n table rows. 
		@param n The number of keys to get and append to the sequence. 
	*/
	action appendKeys(sequence<string> seq, integer n) {
		integer start := seq.size();
		seq.setSize(start+n);
		seq.setSize(plugin.IteratorChunk_appendKeysImpl(c, seq, start));
	}

	/** Get the keys for up to n consecutive rows of the Table beginning
		where this Iterator is pointing.
	
		The iterator will be advanced. If it becomes
		done, a sequence of fewer than n keys will be returned.

		The first key in the returned sequence is the key of the row that the 
		iterator is pointing at when the action is called. When this action is 
		finished, the iterator is pointing at the row immediately beyond that 
		of the last key that was returned. 
		
		@param n The number of keys to get and append to the sequence. 
	*/
	action getKeys(integer n) returns sequence<string> {
		sequence<string> result := new sequence<string>;
		appendKeys(result, n);
		return result;
	}
}

/** Represents a collection of rows in a store, with a defined schema.
	
	A table consists of a series of rows, each identified by a key and
	containing other values with names and types according to the
	table's Schema.
	
	A table typically resides in memory, you can also store it on 
	disk if you want to, or a table can be stored on a distributed cache.
	
	@see Store#open() Tables exist within a named Store, which is used to 
		create and open tables. 
*/
event Table {
	/** @private*/ import "MemoryStorePlugin" as plugin;
	/** @private*/ wildcard chunk c;


	/** Add the table Row with the specified key.
	
		On distributed stores, for performance reasons this action doesn't
		check if there is a Row already present in the the table with the
		specified key. To check if the Row is present in the store, use the
		Table.get() action.
		
		@param key The name/key uniquely identifying the row. 
		@return An empty Row event.
	*/
	action add(string key) returns Row {
		return Row(plugin.TableChunk_add(c, key));
	}

	/** Get the table Row with the specified key. 
	
		If there is no row with the specified key, this action returns 
		without error, with a Row event that contains default values for the 
		fields in the row. A call to the Row.inTable() action returns false.
		
		@param key The name/key uniquely identifying the row. 
		@return A Row event representing an atomic snapshot of the committed 
			data in the table when the action was called. 		
	*/
	action get(string key) returns Row {
		return Row(plugin.TableChunk_get(c,key));
	}
	
	/** Remove the specified row from the table. 
	
		If the row does not exist, this action does nothing.

		@param key The name/key uniquely identifying the row. 
	*/
	action remove(string key) {
		plugin.TableChunk_remove(c,key);
	}

	/** Change the row with the specified key by applying an action to it.
	
		It is possible for another context to commit changes to this row 
		between the time mutate() obtains a Row event to represent the row and 
		the time mutate() tries to commit the changes that result from 
		executing the specified action. In this situation, the MemoryStore 
		automatically calls the specified action again on the most recently 
		committed row content; therefore mutation actions must be designed to 
		cope with being called repeatedly without causing unwanted side 
		effects.
	
		@param name The name/key uniquely identifying the row. 
		@param a An action that (idempotently) performs the desired change to 
			the row. 
	*/
	action mutate(string key, action<Row> a) {
		Row row := get(key);
		boolean done := false;
		while not done { a(row); done := row.tryCommitOrUpdate(); }
	}

	/** Mutate all rows in the Table by applying the specified action.
	
		This can temporarily consume a lot of memory when called on a 
		relatively large table because the Correlator does no garbage 
		collection until action execution is complete. A few thousand rows are 
		unlikely to present a problem. Beyond that, it depends on how many 
		fields are in each row, how many rows are in the table, and how much 
		RAM is available.

		@param a An action that performs the desired change to 
			each row in the table. 
	*/
	action mutateAll(action<Row> a) {
		Iterator i := begin();
		while not i.done() {
			Row row := i.getRow();
			boolean done := false;
			while row.inTable() and not done {
				a(row); done := row.tryCommitOrUpdate();
			}
			i.step();
		}
	}

	/** Remove all rows from the table. */
	action clear() {
		plugin.TableChunk_clear(c);
	}

	/** Indicate whether or not a row with the specified key is present
		in the table.
	
		t.hasKey("foo") is a more efficient alternative to
		t.get("foo").inTable()
		
		@param key The name/key uniquely identifying the row. 
	*/
	action hasKey(string key) returns boolean {
		return plugin.TableChunk_hasKey(c,key);
	}

	/** Return an iterator to the beginning of the Table.
	*/
	action begin() returns Iterator {
		return Iterator(plugin.TableChunk_begin(c));
	}

	/** Returns a sequence that contains the keys for all the rows in this 
		table. 
		
		The keys are in an arbitrary order.
 	*/
	action getKeys() returns sequence<string> {
		Iterator i := begin();
		sequence<string> result := i.getKeys(plugin.TableChunk_size(c));
		// Clean up any residue if a race means we didn't get everything
		while not i.done() { i.appendKeys(result, 16); }
		return result;
	}

	/** Persist this table's committed changes back to stable storage, asynchronously.
	
		Note that any local changes to a Row that were not committed will not 
		be written to disk (see Row#commit()). 

		Only on-disk persistent stores can be persisted using this action. 
		It is not possible to call this method on Correlator-persistent tables 
		since all changes committed to such tables will be written to disk 
		automatically in the same transaction as changes to the state of 
		persistent EPL monitors. 
		
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action persist() returns integer {
		return plugin.TableChunk_persist(c,currentTime);
	}

	/** Enqueue an event for each row in the table, taken by parsing the string 
		data in the specified table field/column as an event string.
		
		The field must be of string type, and its value for every row should be 
		an Apama event string, in the same form that you would send to the 
		Correlator (e.g. "mypackage.MyEvent(123, [false,true])")

	
		This action is most likely to be useful when you are migrating from the 
		StateStore Correlator plug-in to the MemoryStore. In the StateStore 
		plug-in, persistent data re-entered the Correlator as sent events.
		
		This is only supported for non-distributed stores.
	
		@param fieldName The name of the table field whose values are event 
			strings that should be sent. 
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the column data for 
			the last row has been sent. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action enqueueColumn(string fieldName) returns integer {
		return plugin.TableChunk_enqueueColumn(c, fieldName);
	}

	/** Get the name of this Table. */
	action getTableName() returns string {
		return plugin.TableChunk_getTableName(c);
	}

	/** Get the name of the Store that contains this table. */
	action getStoreName() returns string {
		return plugin.TableChunk_getStoreName(c);
	}

	/**
	 * Subscribe to be notified of all successful commits in
	 * this table.
	 *
 	 * This is only supported for tables in a distributed store, 
	 * and only if the underlying provider supports this feature. 
	 *
	 * The monitor instance will be terminated with an error if this 
	 * action is called on a store that does not support it. 
	 *
	 * It is important to note that (due to the nature of distributed store 
	 * technology) there is no way to atomically subscribe to notifications 
	 * and get an initial snapshot of the table's contents, so 
	 * applications that perform an initial iteration over the table's contents 
	 * to initialize some state before subscribing are at risk of 
	 * double-counting any keys that are mutated after the subscription 
	 * and during the iteration/initialization process. 
	 *
	 * For tables that are relatively small (and fit entirely inside the 
	 * memory of a single Correlator), a common pattern for addressing the need 
	 * for a table snapshot to initialize state before subscribing is to 
	 * maintain a per-key dictionary of last-seen values, updated by both the 
	 * initial iteration and the RowChanged notification events; any RowChanged 
	 * event whose old value does not match the last-seen dictionary must be 
	 * ignored, to avoid double-counting changes. To save memory, entries from 
	 * the last-seen dictionary can be removed after the first RowChanged event 
	 * for that key. 
	 *
	 * @return A unique subscriptionId that can be passed to any instance of 
	 * this Table to unsubscribe.
	 * @see RowChanged The event sent whenever a row is modified.
	 * @see Table#unsubscribe() Unsubscribe using this action. 
	 */
	action subscribeRowChanged() returns integer 
	{
		integer subscriptionId := integer.getUnique(); 
		plugin.TableChunk_subscribeRowChanged(c, subscriptionId);
		return subscriptionId;
	}
	
	/**
	 * Cancel a previous subscription.
	 *
	 * This is only supported for tables in a distributed store.
	 *
	 * If other monitors in this context have also subscribed,
	 * events will still be delivered until they have all unsubscribed.
	 * subscriptionId must be a value returned from a subscribeRowChanged() on 
	 * this table.
	 *
	 * @param subscriptionId Identifier for the subscription to remove, 
	 * returned by subscribeRowChanged().
	 */
	action unsubscribe(integer subscriptionId) 
	{ 
		plugin.TableChunk_unsubscribe(c, subscriptionId);
	}

	/**
	 * Return the index of a field.
	 *
	 * Returns what position in the Schema the specified field
	 * appears at. If a name that is not in Schema fieldName
	 * is passed in, the monitor instance will be terminated with an error.
	 *
	 * Using this action is more efficient that getting the same information 
	 * by using indexOf on the Schema.fields sequence. 
	 *
	 * @param fieldName A field name that exists in this table's Schema. 
	 */
	action getFieldIndex(string fieldName) returns integer 
	{ 
		return plugin.TableChunk_getFieldIndex(c, fieldName);
	}
}

/** Represents a store, which is a container for a uniquely named collection of 
	tables. 
	
	@see Storage Provides actions to prepare and open a Store. 
	@see Table Represents the tables in a Store. 
*/
event Store {
	/** @private*/ import "MemoryStorePlugin" as plugin;
	/** @private*/ wildcard chunk c;
	

	/** Prepare a table so that subsequent open calls for it will succeed.
	
		If the table already exists, the Schema provided to the prepare
		function must completely match the existing schema. If it does 
		not already exist, the Schema will be used to create the table.
	
		The function returns an id; once preparation is complete a
		Finished event with that id will be sent.
		
		This call is idempotent - if the table was already successfully 
		prepared, it will return success immediately.
		
		@param name A unique name that will be used to identify the new table. 
		@param schema The schema identifying the fields of the new table. 
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action prepare(string name, Schema schema) returns integer {
		return plugin.StoreChunk_prepare3(c, name, schema.fields.toString() + " " + schema.types.toString(), schema.fields, schema.types, schema.exposeMemoryView, schema.exposePersistentView, schema.memoryViewDisplayName, schema.memoryViewDescription, schema.persistentViewDisplayName, schema.persistentViewDescription, currentTime);
	}

	/** Indicate whether or not a Table with the specified name is
		present in the Store.
	
		@param name The unique table name to check for. 
		@return True if it is safe to call open() on the specified table; false 
			if preparation failed or is still in progress. 
	*/
	action hasTable(string name) returns boolean {
		return plugin.StoreChunk_hasTable(c, name);
	}

	/** Open the specified table, once it has been prepared.
	
		It is an error to call this before a prepare call for the table
		has finished without error.
		
		@param name The name of the table to be opened, which must be the same 
			as the name used when the table was first prepared. 
		@see #prepare() This action must not be called until prepare has 
			completed successfully. 
	*/
	action open(string name) returns Table {
		return Table(plugin.StoreChunk_open(c,name));
	}

	/** Persist committed changes back to stable storage, asynchronously.
	
		Only on-disk persistent stores can be persisted using this action. 
		It is not possible to call this method on Correlator-persistent tables 
		since all changes committed to such tables will be 
		written to disk automatically in the same transaction as changes to 
		the state of persistent EPL monitors. 
		
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action persist() returns integer {
		return plugin.StoreChunk_persist(c,currentTime);
	}

	/** Create a backup of the Store.
	
		The backup is created in the specified file, which is
		overwritten if it already exists.
	
		Only persistent (on-disk) stores can be backed up. 
		
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action backup(string filename) returns integer {
		return plugin.StoreChunk_backup(c, filename);
	}

	/** Get the name of this Store. */
	action getStoreName() returns string {
		return plugin.StoreChunk_getStoreName(c);
	}
}

/** MemoryStore factory interface for creating Store event objects. 

	There are several different types of Store supported by MemoryStore:
	<ul>
	<li>In-memory only (no persistence)</li>
	<li>Persistent (using a specified database file on disk; 
		committed changes go to disk when the persist() action is called)</li>
	<li>Correlator-persistent (using the Correlator's integrated data store; 
		committed changes go to disk periodically when the Correlator takes a 
		snapshot of persistent monitor state and persists the results). </li>
	<li>Distributed (Using a distributed cache technology to share and access
		data across multiple distributed nodes). </li>
	</ul>
	Correlator-persistent stores are only available if Correlator persistence 
	has been enabled. Non-persistent monitors may use any type of store, but 
	a monitor marked as 'persistent' may ONLY access Correlator-persistent 
	stores.

	To use the MemoryStore, create a monitor field (or variable) to hold the 
	Storage factory event, and use one of the prepare* actions to 
	asynchronously get a Store of the desired type ready for use, and give it 
	a unique name. Once the store has been prepared, use the open(name) action 
	to get a Store event that can be used to interact with the store. 
	
	e.g.<pre>
	<br/>using com.apama.memorystore.Storage; 
	<br/>using com.apama.memorystore.Store; 
	<br/>using com.apama.memorystore.Finished; 
	<br/>
	<br/>monitor Test { 
	<br/>	Storage storage; 
	<br/>	Store store; 
	<br/>
	<br/>	action onload() { 
	<br/>		integer id := storage.prepareOrCreate("storename", "/tmp/example.dat"); 
	<br/>		Finished f; 
	<br/>		on Finished(id=id):f
	<br/>		{
	<br/>			if not f.success then { log "Store creation failed: "+f.status at ERROR; die; } 
	<br/>			store := storage.open("storename");
	<br/>			...
	<br/>		}
	<br/>	} 
	<br/>}
	</pre>

	@see Store The purpose of the Storage event is to prepare and open stores. 
	@see #prepareOrCreate() The most commonly used action for preparing a 
		persistent Store. 
	@see #open() Once a store has been prepared it can be opened. 
*/
event Storage {
	/** @private*/ import "MemoryStorePlugin" as plugin;

	/** Prepare an in-memory read-write Store 
		to be opened and used by the application.
	
		@param name A unique name identifying this Store. 
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action prepareInMemory(string name) returns integer {
		return plugin.prepareInMemory(name);
	}

	/** Prepare a distributed store (e.g. distributed cache) 
		to be opened and used by the application.
	
		@param name A unique name identifying this Store, 
			which also specifies the id of its configuration bean in the XML 
			configuration file. This name should not contain spaces.
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 

	*/
	action prepareDistributed(string name) returns integer {
		return plugin.prepareDistributed(name);
	}

	/** Indicates whether configuration for the given distributed
	 	store name exists. 

		Returning false indicates that a prepareDistributed of
		the store name will definitely fail.  True indicates
		it may succeed, but is not a guarantee of success.
		Does not actually connect to the distributed store.

		@return false if prepareDistributed for the given
			store name will definitely fail
	*/
	action hasDistributedStore(string name) returns boolean {
		return plugin.hasDistributedStore(name);
	}


	/** Prepare a Correlator-persistent read-write Store 
		to be opened and used by the application.
		
		All committed changes made to a Correlator-persistent store are 
		persisted to disk automatically whenever the Correlator takes a 
		snapshot of the Correlator persistent application state. 
		Because the Correlator determines when to persist its state, you 
		cannot explicitly request persistence for a Correlator-persistent 
		store or any tables it contains.

		Attempts to create a Correlator-persistent store in a Correlator that 
		does not have persistence enabled will result in an error that will 
		terminate the monitor instance. 
	
		@param name A unique name identifying this Store. 
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action prepareCorrelatorPersistent(string name) returns integer {
		return plugin.prepareCorrelatorPersistent(name);
	}

	/** Prepare a persistent read-write Store associated with an existing 
		database file on disk. 
	
		The specified file must exist and must have been created by the 
		MemoryStore. If the specified file does not exist, or cannot be opened 
		for read-write, the Finished event will indicate failure. 
		
		@param name A unique name identifying this Store. 
		@param filename The path of the database file holding the persistent 
			store. If a relative path is specified, it is relative to the 
			directory that contains the associated Apama Studio project
			(i.e. the Correlator working directory). 
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/			
	action prepare(string name, string filename) returns integer {
		return plugin.prepare(name, filename);
	}

	/** Prepare a persistent read-write Store associated with a 
		database file on disk, which will be created if it does not exist 
		already. 
	
		@param name A unique name identifying this Store. 
		@param filename The path of the database file holding the persistent 
			store. If a relative path is specified, it is relative to the 
			directory that contains the associated Apama Studio project
			(i.e. the Correlator working directory). 
			The parent directory of the specified file must already exist. 
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/			
	action prepareOrCreate(string name, string filename) returns integer {
		return plugin.prepareOrCreate(name, filename);
	}

	/** Prepare a persistent read-only Store associated with an existing 
		database file on disk. 
	
		@param name A unique name identifying this Store. 
		@param filename The path of the database file holding the persistent 
			store. If a relative path is specified, it is relative to the 
			directory that contains the associated Apama Studio project
			(i.e. the Correlator working directory). 
		@return The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/			
	action prepareReadOnly(string name, string filename) returns integer {
		return plugin.prepareReadOnly(name, filename);
	}

	/** Indicate whether or not a Store with the specified name has been 
		prepared already. 
	
		@param name A unique name identifying this Store. 
		@return True if it is safe to call open() on the specified store; 
			false if preparation failed or is still in progress.
	*/
	action hasStore(string name) returns boolean {
		return plugin.hasStore(name);
	}

	/** Open a named Store that has already been prepared, ready for use by 
		this monitor instance.
	
		Every monitor instance should prepare and open the stores it needs. 
		Multiple monitor instances can have the same table open at the same 
		time.

		It is an error to call open() before a prepare call for the table
		has finished without error.
		
		Note that opening a store will not immediately bring all that store's 
		tables into memory, this only happens when each individual table is 
		itself prepared and opened. 
		
		A persistent monitor can access only Correlator-persistent stores. 
		If a persistent monitor tries to open any other type of store 
		(e.g. in-memory, on-disk or distributed) the monitor instance 
		will terminate with an error.
		
		@param name A unique name identifying this Store. 
	*/
	action open(string name) returns Store {
		return Store(plugin.open(name));
	}
}
 00000039 C:\SoftwareAG\Apama\monitors\data_storage\MemoryStore.mon
TIME 0000000e 1484234969.7,1
MONF 0001252f package com.apama.scenario;

/**
 * This file contains the shared event definitions that are generic across 
 * all Scenarios.  
 *
 * WARNING: 
 *    The event definitions contained in this file form an internal protocol 
 *    and may change between software releases.
 *
 * Notes:
 * 1) The Event definitions contained in this file MUST be considered
 *    as an internal implementation of the communications protocol
 *    between the Apama client API and an Apama server.  As such
 *    these event definitions MUST NOT be considered "stable" and are 
 *    subject to change in any future software release.
 *
 *    The ONLY supported public APIs to the Scenario Service are the 
 *    Java client API (in the com.apama.services.scenario package) and the 
 *    .NET client API (in the Apama.Services.Scenario namespace).  
 *    Customers should not attempt to interface at the event or 
 *    EPL layer. Some events have been changed over time (as 
 *    noted here).
 *
 * 2) Most events now contain an initial field called "scenarioId". This string 
 *    uniquely identifies a scenario inside the correlator, and is used as 
 *    the package name, in several events, and for making up a part of the 
 *    data and control channel names.
 *
 * 3) Events that are intended to be used in a request-response pattern contain
 *    a "messageId" field.  The value of this field must be copied from the 
 *    request event into the response event. The mechanism allows clients to 
 *    match up request-response pairs.
 *
 *
 * $Copyright(c) 2005-2011 Progress Software Corporation (PSC). All rights reserved.$
 * $Copyright (c) 2013-2015 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 *
 * $Revision: 267710 $
 */

/**
 * Request that a new instance of a specific scenario is created.
 *
 * See also: Created(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Create {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	string owner;                        // the owner (user) of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
}

/**
 * Notifies all interested clients that a new instance of a specific 
 * scenario has been created. 
 * The event provides the owner (user), initial state, and initial values for 
 * all input fields and all output fields.
 *
 * See also: Create()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Created { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * Notifies the interested clients of child scenarios created from
 * a parent scenario.
 *
 * Direction: Internal in the correlator
 *
 * Channel: <none>
 */
event ParentChildRelationship {
	string parentScenarioId;
	integer parentScenarioInstanceId;
	string childScenarioId;
	integer childScenarioInstanceId;
}


/**
 * Request that a specific instance of a specific scenario is edited (the input 
 * field values are changed).
 *
 * See also: Edited(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Edit { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
}


/**
 * Notifies all interested clients that a specific instance of a specific 
 * scenario has been edited (the input field values have changed).
 *
 * See also: Edit()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Edited { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * Request that a specific instance of a specific scenario is deleted.
 *
 * See also: Deleted(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Delete {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Notifies all interested clients that a specific instance of a specific 
 * scenario has been deleted.
 *
 * See also: Delete()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Deleted {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Indicates that a specific instance of a specific scenario has died.
 * This is sent as a result of a scenario instance use of MonitorScript ondie.
 * This occurs for any of deleting a running scenario, a scenario failing, or 
 * entering the end state.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event InstanceDied {
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Contains updated scenario instance output fields.
 * Note that this is the ONLY event type that is sendted on the 
 * "<scenarioId>.Data" channel.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Update { 
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
	float timeStamp;                     // the time of the update (seconds since epoch)
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * A general Acknowledgement event that is the "response" to various "request"
 * events such as Create, Edit, Delete.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Control
 */
event Acknowledge { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the id of the scenario instance
	boolean success;                     // boolean indication of success
	sequence<string> outputFieldValues;  // sequence of the OUTPUT field values in string form, 
	                                     //   or an empty sequence if success = false
}


/**
 * Indicates that a specific instance of a specific scenario has changed 
 * state, where valid states include "ENDED", "FAILED", "RUNNING".
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event StateChange { 
	string scenarioId;                   // the unique name of the scenario.
	integer scenarioInstanceId;          // the ID of the scenario instance.
	string state;                        // the new state.
}


/**
 * Request that each scenario loaded in the correlator send its meta
 * information out on the supplied channel. When all scenarios have
 * sent out this information, a final RequestScenariosDone event will
 * be sent on the same channel.
 *
 * As soon as this event is received, a RequestScenariosAck will be
 * sent on the same channel so client can stop resending the RequestScenarios
 * event.
 *
 * See also: Scenario, RequestScenariosDone, RequestScenariosAck
 *
 * Direction: From the client to the correlator.
 *
 * Response: Scenario() from each loaded scenario.
 */
event RequestScenarios { 
	// renamed for clarity - was Request
	string channel;                      // Name of the private response channel.
}


/**
 * This is a simple marker event that is sent by the correlator to indicate 
 * that it has finished sending all of the Scenario events in response
 * to a RequestScenarios event.
 * 
 * See also: RequestScenarios, Scenario.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: The private channel that was specified in the RequestScenarios event.
 */
event RequestScenariosDone {}

/* This is a simple ack event that is sent by the correlator to indicate the
 * RequestScenarios event is received and the request is being processed
 *
 * See also: RequestScenarios
 *
 * Direction: From the correlator to the client.
 *
 * Channel: The private channel that was specified in the RequestScenarios event.
 */
event RequestScenariosAck {}

/**
 * Request that each instance of the specified scenario send an Instance event 
 * out on the supplied channel. When all instances for the scenario have been 
 * sent out, a final RequestInstancesDone event will be sent on the same channel.
 *
 * See also: Instance, RequestInstancesDone
 *
 * Direction: From the client to the correlator.
 *
 * Response: Instance() from each scenario instance.
 */
event RequestInstancesOnChannel { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
}

/**
 * Request that each instance for the specified user of the specified scenario
 * send an Instance event out on the supplied channel. When all instances for
 * the scenario have been sent out, a final RequestInstancesDone event will be 
 * sent on the same channel.
 *
 * See also: Instance, RequestInstancesDone
 *
 * Direction: From the client to the correlator.
 *
 * Response: Instance() from each scenario instance.
 */
event RequestInstancesOnChannelByUser { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
	string owner;                        // the username to filter by
}


/**
 * This is a simple marker event that is sent by the correlator to indicate 
 * that it has finished sending all of the Instance events in response
 * to a RequestInstancesInternal event.
 * 
 * See also: RequestInstancesInternal, Scenario.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: A unique private channel as specified by the client in a 
 *          RequestScenariosOnChannel event.
 *
 *          Note that previously it would have been on <scenarioId>.Data and 
 *          <scenarioId>.Data.Raw, but that behaviour is now deprecated.
 */
event RequestInstancesDone {
	string scenarioId;                   // Identifier of the scenario for instances were returned. 	
	integer messageId;                   // the unique message ID (for request-response matching)
}


/**
 * Describes the meta-information about a scenario that is loaded in the 
 * correlator.
 * 
 * See also: RequestScenarios, RequestScenariosDone, ScenarioUnloaded
 * 
 * Direction: From correlator to client.
 *
 * Channel:   1) com.apama.scenario to broadcast when loaded.
 *            2) A unique private channel as specified by the client in a 
 *               RequestScenarios event.
 *
 * This event has gained the executionMode field in Apama 4.2
 */
event Scenario {
	string scenarioId;                   // unique identifier for Scenario, e.g. Scenario_statistical$002darbitrage
	string displayName;                  // user-specified name for Scenario, e.g. statistical-arbitrage
	string description;                  // description of the Scenario
	sequence<string> inputNames;         // input parameter names
	sequence<string> inputTypes;         // input parameter types
	sequence<string> inputConstraints;   // input parameter contraints
	sequence<string> inputDefaults;      // input parameter default values
	sequence<string> outputNames;        // output parameter names
	sequence<string> outputTypes;        // output parameter types
	integer executionMode;               // 0 = serial, 1 = parallel, 2 = parallel child. New as of 4.2
	dictionary<string, string> extraParams; // Additional parameters
}



/**
 * Indicates that a specific Scenario definition is being unloaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Control
 */
event ScenarioUnloaded { 
	string scenarioId;                   // the unique name of the scenario
}

/**
 * Provides a dump of the current state of a scenario instance.
 * The event definition is identical to the Created event, and includes the 
 * owner (user), initial state, and current values for all input fields and 
 * all output fields.
 *
 * Instance events are sent in response to RequestInstancesOnChannel event 
 * and the deprecated RequestInstancesInternal event; 
 *
 * See also: RequestInstancesOnChannel, RequestInstancesDone, RequestInstancesInternal
 *
 * Direction: From the correlator to the client.
 *
 * Channel: A unique private channel as specified by the client in a 
 *          RequestScenariosOnChannel event.
 *
 *          Note that previously it would have been on <scenarioId>.Data and 
 *          <scenarioId>.Data.Raw, but that behaviour is now deprecated.
 */
event Instance {
	string scenarioId;                   // the unique name of the scenario. 
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance. 
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form. 
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form. 
}


/**
 * Indicates this shared MonitorScript has been loaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: com.apama.scenario to broadcast when loaded.
 */
event ScenarioServiceLoaded { 
}

/**
 * Indicates this shared MonitorScript is being unloaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: com.apama.scenario to broadcast when unloaded.
 */
event ScenarioServiceUnloaded { 
}


/**
 * Set the period over which updates will be queued and coalesced before being
 * sent out on the data channel. Defaults to zero, which means they won't be
 * queued. If it is negative then we won't send any updates on the data channel.
 * This event is deprecated and the ConfigureUpdates event should be used 
 * instead (see below)
 */
event SetThrottlingPeriod {
	float period;   // The period in seconds. Default zero.
}


/**
 * Configures how updates are sent from scenarios.
 * Each scenario is controlled by two configurations - a global default,
 * and an optional per scenario configuration.  The per scenario
 * configuration takes precedence over the global default.
 * The configuration is made up of a number of entries in 
 * the configuration dictionary. The ConfigureUpdate event 
 * is merged into any previous configuration.
 *
 * Global configuration can be modified by specifying an empty string 
 * for scenarioId, and empty values remove values.
 */
event ConfigureUpdates {
	/** Specifies the scenario the configuratio will apply to, or use 
		empty string "" to specify a global default. 
	*/
	string scenarioId;
	/** 
	 * A set of the configurations modified by this event
	 * the key and meaning is one of:
	 * sendThrottled - boolean - whether to send Updates to the 
	 *                           Throttled (.Data) channel (default=true)
	 * throttlePeriod - float - period with which to send Updates. 
	 *                          0.0 means updates are not throttled - 
	 *                          every update is sent on the Throttled 
	 *                          channel. (default=0.0)
	 * sendRaw - boolean - whether to send Updates on the Raw channel 
	 *                     (.Raw) (default=true)
 	 * sendThrottledUser - boolean - whether to send Updates to the 
	 *                     throttled filtered (.Data:username) channel
	 *                     (default=false)
 	 * sendRawUser - boolean - whether to send Updates to the Raw 
	 *                     channel (.Raw:username) (default=false)
	 * routeUpdate - boolean - whether to route Update (and Edited, Deleted) events.
	 * An empty value removes that entry from the configuration
	 */
	dictionary<string,string> configuration;
}

/**
 * Immediately flushes to receivers any scenario Update events that were 
 * waiting for the next throttling period before being sent. 
 * 
 */
event SendQueuedUpdatesNow {
	
}

/* ==========================================================================
 * The following describes INTERNAL event definitions that should not be sent 
 * into the correlator, nor relied upon.
 * ==========================================================================
 */

/**
 * Request that each instance of the specified scenario send an Instance event 
 * out on the scenario Data or Raw channel. When all instances for the scenario
 * have been sent out, a final RequestInstancesDone event will be sent on the 
 * same channel.
 *
 * See also: Instance, RequestInstancesDone, RequestInstancesOnChannel, RequestInstancesOnChannelByUser
 *
 * Direction: From the ScenarioService to the scenario
 *
 * Response: Instance() from each scenario instance, RequestInstancesDone when finished.
 */
event RequestInstancesInternal { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
	boolean internal;                    // if true, events should be routed/ send-to'd the main context
	string owner;                        // owner filter (optional)
	boolean ownerFilter;                 // whether to filter by owner
}

/**
 * A scenario has finished running, but is still discoverable.
 * (i.e. entered end state or failed - but not deleted).
 * Note that this event contains the state as of the last
 * Update/ Edited event - i.e. if an action modified an output variable 
 * and then caused the scenario to fail, the prior modification
 * would not be reflected in this event.
 *
 * This event contains sufficient information for discovery of the
 * scenario instance later
 * 
 * Direction: from scenarios to the ScenarioService sub-monitor (spawned per scenario)
 */
event ScenarioFinished {
	string scenarioId;                   // Identifier of the scenario which has failed. 
	integer scenarioInstanceId;          // the ID of the scenario instance. 
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form. 
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form. 
}
/**
 * Only used internally to tell all the scenarios to start routing their
 * meta data (Scenario). It is followed by a sweeper FinishedScenarioRecovery
 * event which indicates that all the scenarios have reported in.
 */
event StartScenarioRecovery {}

/**
 * Sweeper event to indicate that scenario recovery is done. Only used internally.
 */
event FinishedScenarioRecovery {}

/**
 * Trigger discovery of a parallel scenario. Sent from a sub-monitor of
 * ScenarioService to RequestInstancesHandler to create a new sub-monitor.
 */
event RequestInstancesParallel {
	RequestInstancesInternal request;          // the original request event
	dictionary<integer, context> instances;    // all scenario instances and their running context
	integer highestInstanceId;                 // the highest scenarioInstanceId listed in instances (or more accurately, the highest when discovery started)
}

/**
 * Discovery protocol of a parallel scenario. Sent from a scenario instance
 * to RequestInstancesHandler.
 */
event RequestInstancesParallelDone {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}

/**
 * Notification of a new scenario instance
 */
event ParallelStarting {
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
	string owner;                        // the owner of the scenario instance
	context runningCtx;                  // the context the scenario is running in
}

/**
 * Get the current configuration for a given scenario and the default configuration
 */
event GetConfiguration {
	string scenarioId;                   // the unique name of the scenario
}

/**
 * The current configuration for a given scenario and the default configuration
 * @see ConfigureUpdates
 */
event Configuration {
	string scenarioId;                        // the unique name of the scenario
	dictionary<string, string> defaults;      // the global defaults
	dictionary<string, string> configuration; // the scenario configuration (takes precedence)
}


/**
 * An operation has completed. Sent from parallel scenarios to the main context.
 */
event OperationCompleted {
	string scenarioId;
	integer scenarioInstanceId;
	integer messageId;
}

/**
 * Notification that a scenario has loaded a ConfigureUpdates event
 */
event ScenarioProcessedUpdates {
	string scenarioId;
}

/**
 * Request all configuration
 */
event GetAllConfiguration {
	integer requestId;
}

/** 
 * Response all configuration
 */
event AllConfiguration {
	integer requestId;
	dictionary<string, string> defaultConfig;
	dictionary<string, dictionary<string, string> > configurations;
}


/**
 * Library of utiltiy actions
 */
event ScenarioServiceLibrary {

	/**
	 * Get the control channel for a scenario Id. This channel
	 * is always enabled (uses an event set scenario ID)
	 */
	action getControlChannel(string scenarioId) returns string
	{
		return scenarioId+".Control";
	}
	/**
	 * Get the data channel for a scenario ID. This channel 
	 * is enabled by the sendThrottled configuration key and 
	 * the throttlePeriod key (Update events may be throttled)
	 */
	action getDataChannel(string scenarioId) returns string
	{
		return scenarioId+".Data";
	}
	/**
	 * Get the raw channel for a scenario ID. This channel
	 * is enabled by the sendRaw configuration key.
	 */
	action getRawChannel(string scenarioId) returns string
	{
		return scenarioId+".Data.Raw";
	}
	/**
	 * Get the data channel for a scenario Id. This channel 
	 * is enabled by the sendThrottledUser configuration key and 
	 * the throttlePeriod key (Update events may be throttled)
	 */
	action getDataUserChannel(string channel, string owner) returns string
	{
		return channel+":"+owner;
	}
	/**
	 * Get the raw channel for a scenario Id. This channel
	 * is enabled by the sendRawUser configuration key.
	 */
	action getRawUserChannel(string channel, string owner) returns string
	{
		return channel+":"+owner;
	}
	
	/**
	 * Merge configuration. Any entries in updates overwrite entries in configuration.
	 * An empty string value removes the value.
	 * @see ConfigureUpdates
	 */
	action mergeConfiguration(dictionary<string, string> updates, dictionary<string, string> configuration) {
		string k;
		for k in updates.keys() {
			configuration[k]:=updates[k];
			if updates[k]="" then {
				configuration.remove(k);
			}
		}
	}
	
	// implementation note: the defaults for sendThrottled, sendRaw, throttlePeriod, etc are in the following actions:
	/**
	 * Get the sendThrottled value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendThrottled(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendThrottled", "true");
		return c = "true";
	}

	/**
	 * Get the sendThrottledUser value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendThrottledUser(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendThrottledUser", "false");
		return c = "true";
	}
	
	/**
	 * Get the sendRaw value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendRaw(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendRaw", "true");
		return c = "true";
	}
	
	/**
	 * Get the sendRawUser value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendRawUser(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendRawUser", "false");
		return c = "true";
	}
	
	/**
	 * Get the throttlePeriod value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getThrottlePeriod(dictionary<string,string> defaults, dictionary<string,string> config) returns float {
		string c:=getConfig(defaults, config, "throttlePeriod", "0.0");
		return float.parse(c);
	}
	
	/**
	 * Get the routeUpdate value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getRouteUpdate(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "routeUpdate", "false");
		return c = "true";
	}
	

	/**
	 * Get the specified key from the configuration dictionaries, reverting to the default 
	 * if none specified.
	 */
	action getConfig(dictionary<string,string> defaults,
	                 dictionary<string,string> config, 
	                 string key, string _default) returns string {
		if config.hasKey(key) then {
			return config[key];
		}
		if defaults.hasKey(key) then {
			return defaults[key];
		}
		return _default;
	}

	action configurationManager(dictionary<string, string> defaultConfig, dictionary<string, dictionary<string, string> > configurations) {
		// the recognised ConfigureUpdates configuration keys, as above:
		dictionary<string,boolean> KNOWN_CONFIG_KEYS := {"sendThrottled":true, "throttlePeriod":false,
		 "sendRaw":true, "sendThrottledUser":true, "sendRawUser":true, "routeUpdate":true};

		dictionary <string,string> EMPTY_DICT:=new dictionary<string,string>;
		ConfigureUpdates cu;
		on all ConfigureUpdates():cu {
			string key;
			for key in cu.configuration.keys() {
				if not KNOWN_CONFIG_KEYS.hasKey(key) then {
					log "Unrecognized configuration property "+key+" in event "+cu.toString() at WARN;
				}
			}
			if cu.scenarioId = "" then {
				mergeConfiguration(cu.configuration, defaultConfig);
				log "Received "+cu.toString()+" : defaults applicable to all scenarios" at INFO;
			} else {
				if not configurations.hasKey(cu.scenarioId) then {
					configurations.add(cu.scenarioId, new dictionary<string,string>);
				}
				mergeConfiguration(cu.configuration, configurations[cu.scenarioId]);
				on ScenarioProcessedUpdates(cu.scenarioId) -> completed ConfigureUpdates(scenarioId=cu.scenarioId) {
					log "Received "+cu.toString()+" : applied to scenario" at INFO;
				}
				on completed ConfigureUpdates(scenarioId=cu.scenarioId) and not ScenarioProcessedUpdates(cu.scenarioId) {
					log "Received "+cu.toString()+" : for scenario that is not yet defined" at INFO;
				}
			}
		}

		GetConfiguration getConfig;
		on all GetConfiguration():getConfig {
			dictionary<string,string> config:=EMPTY_DICT;
			if configurations.hasKey(getConfig.scenarioId) then {
				config:=configurations[getConfig.scenarioId];
			}
			route Configuration(getConfig.scenarioId, defaultConfig, config);
		}	
		GetAllConfiguration gac;
		on all GetAllConfiguration():gac {
			route AllConfiguration(gac.requestId, defaultConfig, configurations);
		}
	}
		
}

event CallbackHelper {
	sequence<action<> > callbacks;
	action callback() {
		action<> c;
		for c in callbacks {
			c();
		}
	}
}



/**
 * Base event for tracking configuration for a given scenario
 */
event ScenarioServiceUpdaterBase {
	// these are internal and should not be set by users
	string scenarioId;
	dictionary<string,string> defaultConfig;
	dictionary<string,string> config;
	ScenarioServiceLibrary lib;
	boolean sendThrottled;
	boolean sendRaw;
	boolean sendAny;
	boolean emitAny;
	boolean sendThrottledUser;
	boolean sendRawUser;
	boolean routeUpdate;
	float throttlePeriod;
	float throttleStart;
	sequence<listener> listeners;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario
	 * @param sId the scenarioId
	 */
	action init(string sId, action<> cb_onUpdate) {
		scenarioId:=sId;
		controlChannel := lib.getControlChannel(scenarioId);
		rawChannel := lib.getRawChannel(scenarioId);
		dataChannel := lib.getDataChannel(scenarioId);
		route GetConfiguration(scenarioId);
		Configuration c;
		listener l:=on Configuration(scenarioId=scenarioId):c {
			config := c.configuration;
			defaultConfig := c.defaults;
			configurationUpdated();
			cb_onUpdate();
		}
		listeners.append(l);
	}

	/**
	 * Listen for further configuration changes.
	 * @param cb_onUpdate callback upon configuration having been updated
	 */	
	action listenToConfigureUpdates(action<> cb_onUpdate) {
		ConfigureUpdates cu;
		listener l:=on all ConfigureUpdates(scenarioId=""):cu or all ConfigureUpdates(scenarioId=scenarioId):cu {
			if(cu.scenarioId != "") then {
				route ScenarioProcessedUpdates(cu.scenarioId);
			}
			onConfigureUpdates(cu);
			cb_onUpdate();
		}
		listeners.append(l);
	}

	/**
	 * Called when new ConfigureUpdates event available
	 * @param sId the scenarioId
	 */
	action onConfigureUpdates(ConfigureUpdates cu) {
		if cu.scenarioId = "" then {
			lib.mergeConfiguration(cu.configuration, defaultConfig);
		} else {
			lib.mergeConfiguration(cu.configuration, config);
		}
		configurationUpdated();
	}
	
	/**
	 * Called when the configuration should be re-parsed.
	 * @param sId the scenarioId
	 */
	action configurationUpdated() {
		sendThrottled:=lib.getSendThrottled(defaultConfig, config);
		sendThrottledUser:=lib.getSendThrottledUser(defaultConfig, config);
		if sendThrottled or sendThrottledUser then {
			throttlePeriod:=lib.getThrottlePeriod(defaultConfig, config);
			if(throttlePeriod < 0.0) then {
				sendThrottled:=false;
				sendThrottledUser:=false;
			}
			throttleStart:=currentTime;
		}
		sendRaw:=lib.getSendRaw(defaultConfig, config);
		sendRawUser:=lib.getSendRawUser(defaultConfig, config);
		routeUpdate:=lib.getRouteUpdate(defaultConfig, config);
		sendAny:= sendRaw or sendThrottled or routeUpdate or sendRawUser or sendThrottledUser;
		emitAny:= sendRaw or sendThrottled or sendRawUser or sendThrottledUser;
	}

	/** 
	 * Get whether this scenario should send on the throttled (Data) channel
	 */
	action isSendThrottled() returns boolean {
		return sendThrottled or sendThrottledUser;
	}

	/** 
	 * Get whether this scenario should send on the raw channel
	 */
	action isSendRaw() returns boolean {
		return sendRaw or sendRawUser;
	}

	action doEmit(string emitted, string owner) {
		if sendRaw then {
			emit emitted to rawChannel;
		}
		if sendThrottled then {
			emit emitted to dataChannel;
		}
		if sendRawUser then {
			emit emitted to lib.getRawUserChannel(rawChannel, owner);
		}
		if sendThrottledUser then {
			emit emitted to lib.getDataUserChannel(dataChannel, owner);
		}
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		listener l;
		for l in listeners {
			l.quit();
		}
	}
}


/**
 * Utility event for tracking configuration for a given scenario.
 * This event is suitable for use by monitors which spawn per instance
 * (e.g. Scenarios)
 * 
 * This event also uses a callback to get the updates (supplied in
 * instanceInit). If the scenario is configured to only send throttled 
 * updates, the callback is only called when the throttling period 
 * determines an update should be sent - thus, the scenario does not
 * need to generate the output sequence<string> except when needed,
 * which can improve performance in such a configuration.
 * 
 * actions starting with an underscore should be considered private 
 * and not called by users of this event.
 */
event ScenarioServiceUpdaterSingleInstance {
	// these are internal and should not be set by users
	string scenarioId;
	integer scenarioInstanceId;
	ScenarioServiceLibrary lib;
	listener throttlingListener;
	ScenarioServiceUpdaterBase base;
	boolean havePending;
	float latestUpdate;
	action<> returns sequence<string> getUpdate;
	Update update;
	boolean needUpdate;
	context mainContext;
	string owner;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario
	 */
	action init(string sId) {
		init_cb(sId, _noopAction);
	}
	
	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario.
	 * cb_init is called when initialisation is complete
	 */
	action init_cb(string sId, action<> cb_init) {
		base.init(sId, cb_init);
		scenarioId:=sId;
		controlChannel := lib.getControlChannel(scenarioId);
		rawChannel := lib.getRawChannel(scenarioId);
		dataChannel := lib.getDataChannel(scenarioId);
		base.listenToConfigureUpdates(_noopAction);
		mainContext:=context.current();
	}

	action _noopAction() {
	}
	

	/**
	 * Called by monitor after spawn
	 * Will maintain configuration for this scenario, and update listeners appropriately.
	 * @param getUpdateCallback a callback to get the latest outputFieldValues - may be called at any time, must 
         *        always return a consistent set of outputs
	 */
	action instanceInit(integer id, action<> returns sequence<string> getUpdateCallback, string _owner) {
		scenarioInstanceId:=id;
		owner:=_owner;
		getUpdate:=getUpdateCallback;
		update.scenarioId:=scenarioId;
		update.scenarioInstanceId:=scenarioInstanceId;
		base.listenToConfigureUpdates(_configurationUpdated);
		_configurationUpdated();
		listener l:=on all SendQueuedUpdatesNow() {
			_sendThrottledUpdate();
		}
		base.listeners.append(l);
	}

	/** 
	 * Get whether this scenario should route updates
	 */
	action isRouteUpdate() returns boolean {
		return base.routeUpdate;
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		base.destroy();
		throttlingListener.quit();
	}
	  
	/**
	 * called in instances (not factories) when configuration has changed
	 */
	action _configurationUpdated() {
		if base.isSendThrottled() then {
			throttlingListener.quit();
			flushPending();
			if(base.throttlePeriod >= 0.0) then {
				if havePending then {
					_setupThrottleListener();
				}
			}
		}
	}

	/**
	 * set up a throttled listener according to throttlePeriod control
	 */
	action _setupThrottleListener() {
		if base.throttlePeriod > 0.0 then {
			float offset:=currentTime-base.throttleStart;
			float t:=((offset/base.throttlePeriod).floor()+1).toFloat();
			throttlingListener:=on wait((t*base.throttlePeriod)-offset) {
				_sendThrottledUpdate();
			}
		} else {
			_sendThrottledUpdate();
		}
	}

	/**
	 * actually send an update on the throttled channel
	 */
	action _sendThrottledUpdate() {
		if not havePending then {
			return;
		}
		if needUpdate then {
			update.outputFieldValues:=getUpdate();
			update.timeStamp:=latestUpdate;
			needUpdate:=false;
		}
		if base.sendThrottled then {
			send update to dataChannel;
		}
		if base.sendThrottledUser then {
			send update to lib.getDataUserChannel(dataChannel, owner);
		}
		havePending:=false;
	}

	/**
	 * flush any pending update on the throttled channel.
	 */
	action flushPending() {
		if havePending then {
			_sendThrottledUpdate();
			throttlingListener.quit();
		}
	}	

	/**
 	 * Called when a new update is available.
	 */
	action newUpdateAvailable() {
		needUpdate:=true;
		latestUpdate:=currentTime;
 		if base.sendRaw or base.routeUpdate then {
			if needUpdate then {
				update.outputFieldValues:=getUpdate();
				update.timeStamp:=currentTime;
				needUpdate:=false;
			}
			if base.sendRaw then {
				send update to rawChannel;
			}
			if base.sendRawUser then {
				send update to lib.getRawUserChannel(rawChannel, owner);
			}
			if base.routeUpdate then {
				route update;
			}
		}
		if base.isSendThrottled() and not havePending then {
			havePending:=true;
			_setupThrottleListener();
		}
	}
	
	/**
 	 * Called to send a new Acknowledgement event.
	 */
	action emitAcknowledgement(integer messageId) {
		Acknowledge ack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, true, getUpdate());
		if base.routeUpdate then {
			route ack;
		}
		if base.emitAny then {
			send ack to controlChannel;
		}
	}
				
	/**
 	 * Called to send a new Nak event.
	 */
	action emitNack(integer messageId) {
		Acknowledge nack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, false, new sequence<string>);
		if base.routeUpdate then {
			route nack;
		}
		if base.emitAny then {
			send nack to controlChannel;
		}
	}
	
	/**
 	 * Called to send a new Created event.
	 */
	action emitCreated(integer messageId, string owner, string state, sequence<string> inputVariables, sequence<string> outputVariables) {
		if base.sendAny then {
			Created created:=Created(scenarioId, messageId, scenarioInstanceId, owner, state, inputVariables, outputVariables);
			route created;
			if base.emitAny then {
				base.doEmit(created.toString(), owner);
			}
		}
	}
	
	/**
 	 * Called to send a new Edited event.
	 */
	action emitEdited(integer messageId, sequence<string> inputVariables) {
		flushPending();
		if base.sendAny then {
			Edited edited:=Edited(scenarioId, messageId, scenarioInstanceId, inputVariables, getUpdate());
			if base.routeUpdate then {
				route edited;
			}
			if base.emitAny then {
				base.doEmit(edited.toString(), owner);
			}
		}
		emitOpCompleted(messageId);
	}

	/**
 	 * Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.
	 */
	action emitOpCompleted(integer messageId) {
		if(context.current().getId()!=mainContext.getId()) then {
			send OperationCompleted(scenarioId, scenarioInstanceId, messageId) to mainContext;
		}
	}

	/**
 	 * Called to send a new Deleted event.
	 */
	action emitDeleted(integer messageId) {
		flushPending();
		if base.sendAny then {
			Deleted deleted:=Deleted(scenarioId, messageId, scenarioInstanceId);
			if base.routeUpdate then {
				route deleted;
			}
			if base.emitAny then {
				base.doEmit(deleted.toString(), owner);
			}
		}
		throttlingListener.quit();
		notifyInstanceDied();
	}

	/**
 	 * Called to send an instance Died event (either of failed, ended)
	 */
	action emitInstanceDied() {
		flushPending();
		if base.sendAny then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			if base.emitAny then {
				base.doEmit(iDied.toString(), owner);
			}
			if mainContext.getId()=context.current().getId() then {
				route iDied;
			}
		}
		throttlingListener.quit();
	}

	/**
 	 * Called to notify the scenario service monitor that we have gone away - must be called 
 	 * after emitting any events regarding this instance going away. Implied by emitDeleted.
	 */
	action notifyInstanceDied() {
		if mainContext.getId()!=context.current().getId() then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			
			// give a chance for anyone monitoring this from its own context 
			// to handle the InstanceDied before the main context
			if base.routeUpdate then {
				route InstanceDied(scenarioId, scenarioInstanceId);
			}

			send iDied to mainContext;
		}
	}
	
	/**
 	 * Called to send a new StateChange event.
	 */
	action emitStateChange(string state) {
		flushPending();
		StateChange stchange:=StateChange(scenarioId, scenarioInstanceId, state);
		if mainContext.getId()!=context.current().getId() then {
			send stchange to mainContext;
		} else {
			route stchange;
		}
		if base.emitAny then {
			base.doEmit(stchange.toString(), owner);
		}
	}

	/**
 	 * Called to send an instance in response to a RequestInstancesInternal event
	 */
	action emitInstance(RequestInstancesInternal request, string owner, string state, sequence<string> input, sequence<string> output) {
		Instance instance:=Instance(scenarioId, request.messageId, scenarioInstanceId, owner, state, input, output);
		if request.internal then {
			if mainContext.getId() != context.current().getId() then {
				send instance to mainContext;
			} else {
				route instance;
			}
		} else {
			if(base.emitAny) then {
				send instance to request.channel;
			}
		}
		if mainContext.getId() != context.current().getId() then {
			send RequestInstancesParallelDone(scenarioId, request.messageId, scenarioInstanceId) to mainContext;
		}
	}

	/**
 	 * Called when the instance has failed.  input and output are the input
 	 * and output variables as at the last Update/ Edited point.
	 */
	action finished(string state, string owner, sequence<string> input, sequence<string> output) {
		ScenarioFinished scenFinished:=ScenarioFinished(scenarioId, scenarioInstanceId, owner, state, input, output);
		if mainContext.getId() != context.current().getId() then {
			send scenFinished to mainContext;
		} else {
			route scenFinished;
		}
	}
	
}


/**
 * Utilitiy event for tracking configuration for a given scenario.
 * This event is suitable for use by monitors which spawn per scenario,
 * but not per instance. (e.g. ScenarioService, DataViewService)
 * 
 * actions starting with an underscore should be considered private 
 * and not called by users of this event.
 * 
 * Note that this updater only honours sendThrottledUser changes at the next throttling period
 * (it does not record the owner if sendThrottledUser is not true)
 */
event ScenarioServiceUpdaterMultipleInstances {
	// these are internal and should not be set by users
	string scenarioId;
	ScenarioServiceLibrary lib;
	listener throttlingListener;
	ScenarioServiceUpdaterBase base;
	boolean currentlySendingThrottledUser;
	dictionary<integer, Update> updates;
	dictionary<integer, string> owners;
	context mainContext;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor for each scenario
	 * Will maintain configuration for this scenario Id
	 */
	action init(string sId, context mainCtx) {
		_init(sId, mainCtx, _configurationUpdated);
	}
	
	/**
	 * Called by monitor for each scenario
	 * Will maintain configuration for this scenario Id
	 */
	action init_cb(string sId, context mainCtx, action<> cb_initComplete) {
		CallbackHelper callbackHelper:=new CallbackHelper;
		callbackHelper.callbacks.append(cb_initComplete);
		callbackHelper.callbacks.append(_configurationUpdated);
		_init(sId, mainCtx, callbackHelper.callback);
	}

	/**
	 * Implementation of init and init_cb
	 */
	action _init(string sId, context mainCtx, action<> cb_initComplete) {
		base.init(sId, cb_initComplete);
		mainContext:=mainCtx;
		scenarioId:=sId;
		controlChannel := lib.getControlChannel(scenarioId);
		rawChannel := lib.getRawChannel(scenarioId);
		dataChannel := lib.getDataChannel(scenarioId);
		listener l:=on all SendQueuedUpdatesNow() {
			_sendThrottledUpdates();
		}
		base.listeners.append(l);
		base.listenToConfigureUpdates(_configurationUpdated);
	}
	
	/** 
	 * Get whether this scenario should route updates
	 */
	action isRouteUpdate() returns boolean {
		return base.routeUpdate;
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		base.destroy();
		throttlingListener.quit();
	}
	  

	/**
	 * called in instances (not factories) when configuration has changed
	 */
	action _configurationUpdated() {
		if base.isSendThrottled() then {
			throttlingListener.quit();
			flushPending();
			if(base.throttlePeriod >= 0.0) then {
				_setupThrottleListener();
			}
		}
	}

	/**
	 * set up a throttled listener according to throttlePeriod control
	 */
	action _setupThrottleListener() {
		if base.throttlePeriod > 0.0 then {
			throttlingListener:=on all wait(base.throttlePeriod) {
				_sendThrottledUpdates();
			}
		} else {
			_sendThrottledUpdates();
		}
	}

	/**
	 * actually send an update on the throttled channel
	 */
	action _sendThrottledUpdates() {
		integer instance;
		if base.sendThrottled then {
			for instance in updates.keys() {
				send updates[instance] to dataChannel;
			}
		}
		if currentlySendingThrottledUser then {
			for instance in updates.keys() {
				send updates[instance] to lib.getDataUserChannel(dataChannel, owners[instance]);
			}
		}
		owners.clear();
		updates.clear();
		currentlySendingThrottledUser := base.sendThrottledUser;
	}

	/**
	 * flush any pending update on the throttled channel.
	 */
	action flushPending() {
		_sendThrottledUpdates();
	}	

	/**
 	 * Flush pending throttled data for one instance
	 */
	action flushPendingInstance(integer scenarioInstanceId) {
		if updates.hasKey(scenarioInstanceId) then {
			if base.sendThrottled then {
				send updates[scenarioInstanceId] to dataChannel;
			}
			if currentlySendingThrottledUser then {
				send updates[scenarioInstanceId] to lib.getDataUserChannel(dataChannel, owners[scenarioInstanceId]);
			}
			updates.remove(scenarioInstanceId);
			if owners.hasKey(scenarioInstanceId) then {
				owners.remove(scenarioInstanceId);
			}
		}
	}	

	/**
 	 * Called when a new update is available. (This variant allows setting of the time parameter)
	 */
	action emitUpdate_time(integer scenarioInstanceId, float time, sequence<string> output, string owner) {
		if base.sendAny then {
			Update update:=Update(scenarioId, scenarioInstanceId, time, output);
			if base.sendRaw then {
				send update to rawChannel;
			}
			if base.sendRawUser then {
				send update to lib.getRawUserChannel(rawChannel, owner);
			}
			if base.routeUpdate then {
				route update;
			}
			if base.isSendThrottled() then {
				if base.throttlePeriod > 0.0 then {
					updates.add(scenarioInstanceId, update);
					if currentlySendingThrottledUser then {
						owners.add(scenarioInstanceId, owner);
					}
				} else {
					send update to dataChannel;
				}
			}
		}
	}
	
	/**
 	 * Called when a new update is available.
	 */
	action emitUpdate(integer scenarioInstanceId, sequence<string> output, string owner) {
		emitUpdate_time(scenarioInstanceId, currentTime, output, owner);
	}

	/**
 	 * Called to send a new Acknowledgement event.
	 */
	action emitAcknowledgement(integer messageId, integer scenarioInstanceId, sequence<string> output) {
		Acknowledge ack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, true, output);
		if base.routeUpdate then {
			route ack;
		}
		if base.emitAny then {
			send ack to controlChannel;
		}
	}
				
	/**
 	 * Called to send a new Nak event.
	 */
	action emitNack(integer messageId, integer scenarioInstanceId) {
		Acknowledge nack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, false, new sequence<string>);
		if base.routeUpdate then {
			route nack;
		}
		if base.emitAny then {
			send nack to controlChannel;
		}
	}
	
	/**
 	 * Called to send a new Created event.
	 */
	action emitCreated(integer messageId, integer scenarioInstanceId, string owner, string state, sequence<string> inputVariables, sequence<string> outputVariables) {
		if base.sendAny then {
			Created created:=Created(scenarioId, messageId, scenarioInstanceId, owner, state, inputVariables, outputVariables);
			route created;
			if base.emitAny then {
				string sCreated:=created.toString();
				base.doEmit(sCreated, owner);
			}
		}
	}

	/**
 	 * Called to send any received events (except for instance) for this scenario.
	 */
	action emitReceivedEvents() {
		dictionary<integer, string> instanceOwners:=new dictionary<integer, string>;
		{
			Update update;
			listener l:=on all Update(scenarioId = scenarioId):update {
				if base.sendRaw then {
					send update to rawChannel;
				}
				if base.sendRawUser and instanceOwners.hasKey(update.scenarioInstanceId) then {	
					send update to lib.getRawUserChannel(rawChannel, instanceOwners[update.scenarioInstanceId]);
				}
				if base.isSendThrottled() then {
					if base.throttlePeriod > 0.0 then {
						updates.add(update.scenarioInstanceId, update);
						string owner:="*";
						if instanceOwners.hasKey(update.scenarioInstanceId) then {
							owner:=instanceOwners[update.scenarioInstanceId];
						}
						if currentlySendingThrottledUser then {
							owners.add(update.scenarioInstanceId, owner);
						}
					} else {
						send update to dataChannel;
					}
				}
			}
			base.listeners.append(l);
		}
		{
			Created created;
			listener l:=on all Created(scenarioId = scenarioId):created {
				if(created.owner != "*") then {
					instanceOwners.add(created.scenarioInstanceId, created.owner);
				}
				base.doEmit(created.toString(), created.owner);				
			}
			base.listeners.append(l);
		}
		{
			Deleted deleted;
			listener l:=on all Deleted(scenarioId = scenarioId):deleted {
				flushPendingInstance(deleted.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(deleted.scenarioInstanceId) then {
					owner:=instanceOwners[deleted.scenarioInstanceId];
					instanceOwners.remove(deleted.scenarioInstanceId);
				}
				base.doEmit(deleted.toString(), owner);		
			}
			base.listeners.append(l);
		}
		{
			Edited edited;
			listener l:=on all Edited(scenarioId = scenarioId):edited {
				flushPendingInstance(edited.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(edited.scenarioInstanceId) then {
					owner:=instanceOwners[edited.scenarioInstanceId];
				}
				base.doEmit(edited.toString(), owner);		
			}
			base.listeners.append(l);
		}
		{
			InstanceDied instanceDied;
			listener l:=on all InstanceDied(scenarioId = scenarioId):instanceDied {
				flushPendingInstance(instanceDied.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(instanceDied.scenarioInstanceId) then {
					owner:=instanceOwners[instanceDied.scenarioInstanceId];
				}
				base.doEmit(instanceDied.toString(), owner);		
			}
			base.listeners.append(l);
		}
	}
	
	/**
 	 * Called to send a new Edited event.
	 */
	action emitEdited(integer messageId, integer scenarioInstanceId, sequence<string> inputVariables, sequence<string> outputVariables, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny then {
			Edited edited:=Edited(scenarioId, messageId, scenarioInstanceId, inputVariables, outputVariables);
			if base.routeUpdate then {
				route edited;
			}
			if base.emitAny then {
				base.doEmit(edited.toString(), owner);
			}
		}
		emitOpCompleted(messageId, scenarioInstanceId);
	}

	/**
 	 * Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.
	 */
	action emitOpCompleted(integer messageId, integer scenarioInstanceId) {
		if(context.current().getId()!=mainContext.getId()) then {
			send OperationCompleted(scenarioId, scenarioInstanceId, messageId) to mainContext;
		}
	}

	/**
 	 * Called to send a new Deleted event.
	 */
	action emitDeleted(integer messageId, integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny then {
			Deleted deleted:=Deleted(scenarioId, messageId, scenarioInstanceId);
			if base.routeUpdate then {
				route deleted;
			}
			if base.emitAny then {
				base.doEmit(deleted.toString(), owner);
			}
		}
		notifyInstanceDied(scenarioInstanceId);
	}

	/**
 	 * Called to notify the scenario service monitor that we have gone away - must be called 
 	 * after emitting any events regarding this instance going away. Implied by emitDeleted.
	 */
	action notifyInstanceDied(integer scenarioInstanceId) {
		if mainContext.getId()!=context.current().getId() then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			send iDied to mainContext;
		}
	}
	

	
	/**
 	 * Called to send an instance Died event (either of failed, ended)
	 */
	action emitInstanceDied(integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			if base.emitAny then {
				base.doEmit(iDied.toString(), owner);
			}
			if mainContext.getId()=context.current().getId() then {
				route iDied;
			}
		}
	}
	
	/**
 	 * Called to send a new StateChange event.
	 */
	action emitStateChange(string state, integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		StateChange stchange:=StateChange(scenarioId, scenarioInstanceId, state);
		if mainContext.getId()!=context.current().getId() then {
			send stchange to mainContext;
		} else {
			route stchange;
		}
		if base.emitAny then {
			base.doEmit(stchange.toString(), owner);
		}
	}

	/**
 	 * Called to send an instance in response to a RequestInstancesInternal event
	 */
	action emitInstance(RequestInstancesInternal request, integer scenarioInstanceId, string owner, string state, sequence<string> input, sequence<string> output) {
		Instance instance:=Instance(scenarioId, request.messageId, scenarioInstanceId, owner, state, input, output);
		if request.internal then {
			if mainContext.getId() != context.current().getId() then {
				send instance to mainContext;
			} else {
				route instance;
			}
		} else {
			if(base.emitAny) then {
				send instance to request.channel;
			}
		}
		if mainContext.getId() != context.current().getId() then {
				send RequestInstancesParallelDone(scenarioId, request.messageId, scenarioInstanceId) to mainContext;
		}
	}
	/**
 	 * Called to send an instance that has already been seen in the current context
	 */
	action emitReceivedInstance(RequestInstancesInternal request, Instance instance) {
		if request.internal then {
			if mainContext.getId() != context.current().getId() then {
				send instance to mainContext;
			}
		} else {
			if(base.emitAny) then {
				send instance to request.channel;
			}
		}
	}
	
}


/*
 * Monitor that performs the following tasks:
 *   - routing/emitting ScenarioServiceLoaded when the service is loaded
 *   - routing/emitting ScenarioServiceUnloaded when the service is unloaded
 *   - routing/emitting a nack if a Create request is ignored
 *   - maintains latest configuration
 *   - tracks state of ended/ failed scenarios
 *   - forwards Edit, delete events to scenarios in other contexts
 *
 */
monitor ScenarioService {

	event PendingOperation {
		integer messageId;
		integer type; // 0 = delete, 1 = edit
	}

	listener throttledSenderListener;
	ScenarioServiceLibrary lib;
	RequestScenarios requestScenarios;
	boolean requestingScenarios;
	
	// MetaData relating to the interface
	dictionary<string,string> interfaceMetaData := {
		"interface.package"     :"com.apama.scenario",
		"interface.name"        :"ScenarioService",
		"interface.fileName"    :"ScenarioService.mon",
		"interface.vendor"      :"Apama",
		"interface.version"     :"9.10.0.0.275046",
		"interface.fullVersion" :"rel/9.10.0.x@275046",
		"interface.language"    :"MonitorScript"
	};
	
	// Channel names	
	string scenarioServiceChannel := "com.apama.scenario";
	integer highestInstanceId;


	// the first mThread handles scenario discovery and maps some events to internal events
	action onload() {
		// print version
		log "ScenarioService interface loaded. MetaData: "+interfaceMetaData.toString() at INFO;
		
		// generate the ScenarioServiceLoaded event
		route ScenarioServiceLoaded();
		send ScenarioServiceLoaded() to scenarioServiceChannel;

		dictionary <string,string> defaultConfig:=new dictionary<string,string>;
		dictionary <string, dictionary<string,string> > configurations:=new dictionary<string, dictionary<string,string> >;
		lib.configurationManager(defaultConfig, configurations);
		RequestInstancesOnChannel requestInstancesOnChannel;
		on all RequestInstancesOnChannel():requestInstancesOnChannel {
			route RequestInstancesInternal(requestInstancesOnChannel.scenarioId, requestInstancesOnChannel.messageId, requestInstancesOnChannel.channel, false, "", false);
			on RequestInstancesDone(scenarioId=requestInstancesOnChannel.scenarioId, messageId=requestInstancesOnChannel.messageId) {
				send RequestInstancesDone(requestInstancesOnChannel.scenarioId, requestInstancesOnChannel.messageId) to requestInstancesOnChannel.channel;
			}
		}

		RequestInstancesOnChannelByUser requestInstancesOnChannelByUser;
		on all RequestInstancesOnChannelByUser():requestInstancesOnChannelByUser {
			route RequestInstancesInternal(requestInstancesOnChannelByUser.scenarioId, requestInstancesOnChannelByUser.messageId, requestInstancesOnChannelByUser.channel, false, requestInstancesOnChannelByUser.owner, true);
			on RequestInstancesDone(scenarioId=requestInstancesOnChannelByUser.scenarioId, messageId=requestInstancesOnChannelByUser.messageId) {
				send RequestInstancesDone(requestInstancesOnChannelByUser.scenarioId, requestInstancesOnChannelByUser.messageId) to requestInstancesOnChannelByUser.channel;
			}
		}
		Scenario scenario;
		on all Scenario():scenario {
			if requestingScenarios then {
				send scenario to requestScenarios.channel;
			} else {
				spawn trackScenario(scenario);
			}
		}
		
		ScenarioUnloaded scenarioUnloaded;
		on all ScenarioUnloaded(): scenarioUnloaded {
			send scenarioUnloaded to scenarioServiceChannel;
		}

		
		on all RequestScenarios():requestScenarios {
			send RequestScenariosAck() to requestScenarios.channel;
			route StartScenarioRecovery();
			route FinishedScenarioRecovery();
			requestingScenarios:=true;
			on FinishedScenarioRecovery() {
				requestingScenarios:=false;
				send RequestScenariosDone() to requestScenarios.channel;
			}
		}

		dictionary <string,string> EMPTY_DICT:=new dictionary<string,string>;
		// Pick up any requests for operations on invalid scenarioIds
		Create create;
		on all unmatched Create(): create {
			dictionary<string,string> config:=EMPTY_DICT;
			if configurations.hasKey(create.scenarioId) then {
				config:=configurations[create.scenarioId];
			}
			Acknowledge nack := new Acknowledge;
			nack.scenarioId := create.scenarioId;
			nack.messageId := create.messageId;
			nack.success := false;
			log create.scenarioId+": Scenario create ignored - unknown scenarioId." at WARN;
			send nack to lib.getControlChannel(create.scenarioId);
			if lib.getRouteUpdate(defaultConfig, config) then {
				route nack;
			}
		}

		// The old SetThrottlingPeriod is mapped to a ConfigureUpdates event
		SetThrottlingPeriod setThrottlingPeriod;		
		on all SetThrottlingPeriod():setThrottlingPeriod {
			dictionary<string, string> configChanges:=new dictionary<string,string>;
			if setThrottlingPeriod.period >= 0.0 then {
				configChanges["sendThrottled"]:="true";
				configChanges["throttlePeriod"]:=setThrottlingPeriod.period.toString();
			} else {
				configChanges["sendThrottled"]:="false";
			}
			ConfigureUpdates cu:=ConfigureUpdates("", configChanges);
			log "Received deprecated event "+setThrottlingPeriod.toString()+", will re-route as "+cu.toString() at WARN;
			route cu;
		}
	}		
				
	
	action onunload() {
		// generate the ScenarioServiceUnloaded event
		ScenarioServiceUnloaded unloaded := new ScenarioServiceUnloaded;
		route unloaded;
		send unloaded to scenarioServiceChannel;
	}
	
	/**
	 * spawned per scenario, and handles any finished scenario instances.
	 * For parallel scenarios, it also tracks which instance runs in 
	 * which context and forwards Edit and Delete events.
	 */
	action trackScenario(Scenario scenario) {
		on ScenarioUnloaded(scenarioId=scenario.scenarioId) {
			die;
		}
		ScenarioServiceUpdaterMultipleInstances updater:=new ScenarioServiceUpdaterMultipleInstances;
		updater.init(scenario.scenarioId, context.current());
		ScenarioFinished finished;
		on all ScenarioFinished(scenarioId=scenario.scenarioId):finished {
			// Finished scenarios can be deleted (which terminates all listeners for this instance), 
			// discovered, and edits are Nacked 
			Delete delete;
			on Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId):delete {
				updater.emitAcknowledgement(delete.messageId, finished.scenarioInstanceId, finished.outputFieldValues);
				updater.emitDeleted(delete.messageId, finished.scenarioInstanceId, finished.owner);
			}
			Edit edit;
			on all Edit(scenarioId=scenario.scenarioId, scenarioInstanceId=finished.scenarioInstanceId):edit and not 
			            Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
				updater.emitNack(edit.messageId, finished.scenarioInstanceId);
				log scenario.displayName+"("+finished.scenarioInstanceId.toString()+ "): Scenario edit ignored - Scenario is in "+finished.state+" state." at WARN;
			}
			RequestInstancesInternal requestInstances;
			if finished.owner = "*" then {
				on all RequestInstancesInternal(scenarioId=scenario.scenarioId):requestInstances and not
						Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
					updater.emitInstance(requestInstances, finished.scenarioInstanceId,
						finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
				}
			} else {
				on all (RequestInstancesInternal(scenarioId=scenario.scenarioId, ownerFilter=false):requestInstances or
					RequestInstancesInternal(scenarioId=scenario.scenarioId, owner=finished.owner, ownerFilter=true):requestInstances) and not
						Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
					updater.emitInstance(requestInstances, finished.scenarioInstanceId,
						finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
				}
			}
		}
		if scenario.executionMode > 0 then {
			// for parallel scenarios, we keep track of instance to context mapping:
			dictionary<integer, context> runningCtxs := new dictionary<integer, context>;
			// and to owner mapping:
			dictionary<integer, string> ownerCtxs := new dictionary<integer, string>;
			// and by user:
			dictionary<string, dictionary<integer, context> > runningCtxsByOwner := new dictionary<string, dictionary<integer, context> >;
			// maps from instanceId to sequence<messageId>
			dictionary<integer, sequence<PendingOperation> > pendingOperations := new dictionary<integer, sequence<PendingOperation> >;
			ParallelStarting starting;
			on all ParallelStarting(scenarioId = scenario.scenarioId):starting {
				runningCtxs.add(starting.scenarioInstanceId, starting.runningCtx);
				ownerCtxs.add(starting.scenarioInstanceId, starting.owner);
				if not runningCtxsByOwner.hasKey(starting.owner) then {
					runningCtxsByOwner.add(starting.owner, new dictionary<integer, context>);
				}
				runningCtxsByOwner[starting.owner].add(starting.scenarioInstanceId, starting.runningCtx);
				highestInstanceId := starting.scenarioInstanceId;
			}
			
			InstanceDied died;
			on all InstanceDied(scenarioId = scenario.scenarioId):died {
				if runningCtxs.hasKey(died.scenarioInstanceId) then {
					runningCtxs.remove(died.scenarioInstanceId);
				}
				if ownerCtxs.hasKey(died.scenarioInstanceId) then {
					string owner:=ownerCtxs[died.scenarioInstanceId];
					ownerCtxs.remove(died.scenarioInstanceId);
					if runningCtxsByOwner.hasKey(owner) then {
						if runningCtxsByOwner[owner].hasKey(died.scenarioInstanceId) then {
							runningCtxsByOwner[owner].remove(died.scenarioInstanceId);
						}
						if runningCtxsByOwner[owner].size()=0 then {
							runningCtxsByOwner.remove(owner);
						}
					}
				}
				if pendingOperations.hasKey(died.scenarioInstanceId) then {
					PendingOperation pending;
					for pending in pendingOperations[died.scenarioInstanceId] {
						if pending.type = 0 then {
							route Delete(scenario.scenarioId, pending.messageId, died.scenarioInstanceId);
						} else {
							if pending.type = 1 then {
								route Edit(scenario.scenarioId, pending.messageId, died.scenarioInstanceId, new sequence<string>);
							} else {
								log "error: unknown pending operation type "+pending.toString() at ERROR;
							}
						}
					}
					pendingOperations.remove(died.scenarioInstanceId);
				}
			}
			
			// and forward edits, deletes:
			Edit edit;
			on all unmatched Edit(scenarioId = scenario.scenarioId):edit {
				if runningCtxs.hasKey(edit.scenarioInstanceId) then {
					send edit to runningCtxs[edit.scenarioInstanceId];
					addPendingOperation(pendingOperations, edit.scenarioInstanceId, edit.messageId, 1);
					on OperationCompleted(scenarioId = scenario.scenarioId, scenarioInstanceId = edit.scenarioInstanceId, messageId = edit.messageId) and not
					   ScenarioFinished(scenarioId = scenario.scenarioId, scenarioInstanceId = edit.scenarioInstanceId){
						removePendingOperation(pendingOperations, edit.scenarioInstanceId, edit.messageId);
					}
				} else {
					log scenario.displayName+"("+edit.scenarioInstanceId.toString()+"): Scenario edit ignored - unknown scenarioInstanceId." at WARN;
					updater.emitNack(edit.messageId, edit.scenarioInstanceId);
				}
			}
			Delete delete;
			on all unmatched Delete(scenarioId = scenario.scenarioId):delete {
				if runningCtxs.hasKey(delete.scenarioInstanceId) then {
					send delete to runningCtxs[delete.scenarioInstanceId];
					addPendingOperation(pendingOperations, delete.scenarioInstanceId, delete.messageId, 0);
					on OperationCompleted(scenarioId = scenario.scenarioId, scenarioInstanceId = delete.scenarioInstanceId, messageId = delete.messageId) and not
					   ScenarioFinished(scenarioId = scenario.scenarioId, scenarioInstanceId = delete.scenarioInstanceId){
						removePendingOperation(pendingOperations, delete.scenarioInstanceId, delete.messageId);
					}
				} else {
					log scenario.displayName+"("+delete.scenarioInstanceId.toString()+"): Scenario delete ignored - unknown scenarioInstanceId." at WARN;
					updater.emitNack(delete.messageId, delete.scenarioInstanceId);
				}
			}
			
			// and request instances is handled by a separate monitor. Note that 
			// Finished scenarios are not in the dictionary, but are handled by the finished
			// listener above.
			RequestInstancesInternal reqInstances;
			on all RequestInstancesInternal(scenarioId=scenario.scenarioId):reqInstances {
				if reqInstances.ownerFilter then {
					if runningCtxsByOwner.hasKey(reqInstances.owner) then {
						dictionary<integer, context> rCtxs:=runningCtxsByOwner[reqInstances.owner];
						if runningCtxsByOwner.hasKey("*") then {
							rCtxs:=rCtxs.clone();
							integer i;
							dictionary<integer, context> wildcards:=runningCtxsByOwner["*"];
							for i in wildcards.keys() {
								rCtxs.add(i, wildcards[i]);
							}
						}
						route RequestInstancesParallel(reqInstances, rCtxs, highestInstanceId);
					} else {
						if runningCtxsByOwner.hasKey("*") then {
							route RequestInstancesParallel(reqInstances, runningCtxsByOwner["*"], highestInstanceId);
						} else {
							route RequestInstancesParallel(reqInstances, new dictionary<integer,context>, highestInstanceId);
						}
					}
				} else {
					route RequestInstancesParallel(reqInstances, runningCtxs, highestInstanceId);
				}
			}
			ConfigureUpdates cu;
			on all ConfigureUpdates(scenarioId=""):cu or all ConfigureUpdates(scenarioId=scenario.scenarioId):cu {
				integer inst;
				for inst in runningCtxs.keys() {
					send cu to runningCtxs[inst];
				}
			}
			on all SendQueuedUpdatesNow() {
				SendQueuedUpdatesNow snow:=SendQueuedUpdatesNow();
				integer inst;
				for inst in runningCtxs.keys() {
					send snow to runningCtxs[inst];
				}
			}
		}
	}
	
	action addPendingOperation(dictionary<integer,  sequence<PendingOperation> > pendingOperations, integer scenarioInstanceId, integer messageId, integer type) {
		if not pendingOperations.hasKey(scenarioInstanceId) then {
			pendingOperations.add(scenarioInstanceId, new sequence<PendingOperation>);
		}
		pendingOperations[scenarioInstanceId].append(PendingOperation(messageId, type));
	}
	
	action removePendingOperation(dictionary<integer, sequence<PendingOperation> > pendingOperations, integer scenarioInstanceId, integer messageId) {
		if not pendingOperations.hasKey(scenarioInstanceId) then {
			return;
		}
		integer idx:=-1, i:=0;
		while(i < pendingOperations[scenarioInstanceId].size()) {
			if pendingOperations[scenarioInstanceId][i].messageId = messageId then {
				idx:=i;
				break;
			}
			i:=i+1;
		}
		if(idx>=0) then {
			pendingOperations[scenarioInstanceId].remove(idx);
		}
		if pendingOperations[scenarioInstanceId].size() = 0 then {
			pendingOperations.remove(scenarioInstanceId);
		}
	}	
}

/*
 * Monitor that handles request instances for parallel scenarios:
 * - on a RequestInstancesOnChannel for a parallel scenario, the ScenarioService 
 *   routes a RequestInstancesParallel which triggers this monitor to spawn.
 * - this waits for a response (be it to say the request instances has been 
 *   handled or that the scenario has finished) before sending the 
 *   RequestInstancesDone event 
 *
 * Note that this monitor assumes scenarioInstancesIds always increase over time.
 */
monitor RequestInstancesHandler {
	RequestInstancesParallel req;
	action onload() {
		on all RequestInstancesParallel():req {
			spawn handleRequest();
		}
	}
	
	/**
	 * Forward the request to every context and await responses. We remove 
	 * instances from the dictionary upon receiving an update for them. 
	 */
	action handleRequest() {
		ScenarioServiceUpdaterMultipleInstances updater:=new ScenarioServiceUpdaterMultipleInstances;
		updater.init(req.request.scenarioId, context.current());
		integer k;
		for k in req.instances.keys() {
			send req.request to req.instances[k];
		}
		// if a scenario dies, it will send events in the order ScenarioFinished, InstanceDied:
		ScenarioFinished finished;
		on all ScenarioFinished(scenarioId=req.request.scenarioId, scenarioInstanceId <= req.highestInstanceId):finished {
			// if a scenario dies after it has sent the Instance, do not send another 
			// (the StateChange/ InstanceDied events are sufficient)
			if(req.instances.hasKey(finished.scenarioInstanceId)) then {
				updater.emitInstance(req.request, finished.scenarioInstanceId,
					finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
			}
		}
		// A finished scenario should not be counted
		InstanceDied died;
		on all InstanceDied(scenarioId = req.request.scenarioId, scenarioInstanceId <= req.highestInstanceId):died {
			if(req.instances.hasKey(died.scenarioInstanceId)) then {
				req.instances.remove(died.scenarioInstanceId);
				checkFinished();
			}
		}
		RequestInstancesParallelDone pdone;
		on all RequestInstancesParallelDone(scenarioId = req.request.scenarioId, messageId = req.request.messageId):pdone {
			if(req.instances.hasKey(pdone.scenarioInstanceId)) then {
				req.instances.remove(pdone.scenarioInstanceId);
				checkFinished();
			}
		}
		checkFinished();
	}
	
	/**
	 * Check whether we are finished.
	 * We are finished if we have no instances left in our dictionary, in which 
	 * case we route a RequestInstancesDone (handled by the ScenarioService monitor)
	 * and terminate.
	 */
	action checkFinished() {
		if req.instances.size()=0 then {
			route RequestInstancesDone(req.request.scenarioId, req.request.messageId);
			die;
		}
	}
}

 00000030 C:\SoftwareAG\Apama\monitors\ScenarioService.mon
CDPF 000143da 4170616d614344503100872513420288e4c86dd785802a614c00bc50091167e3ac92c4cc842084ad1ba2ba6de2424e9ab86dd8ccd0c8b858ba495ba16c937ab2a5291b0780800af6eb2f976d8d6b70464cc6449c4ee4f2ebf5bf5e411478bac644c490e9c8c80a93011be4038aa531c1ab3c4d36d80a0b8043818c838b09191b8b001b17122600870d048001581308260023509011992a2a0ac314f20426e8b060028ef40118809a580a1a0349676a262134be89af33d93243e732f826348dc9d65988a6cee2c2569849a609118bd0c465f10cbe89adc90c85c5370143c83f58fc92a2326453a6a3cb2a57d599aa2627183a1a9aca51754680c540d154a6c979f6b36485291b006cdf81286b7c93a92133152e9dc7508f67065367c9681a936f22d3d15f827e70cc179eabca3c8e22d3ff4155361f6c14155d65685c5303c7d39019a6fe1f236b3c15ed41e670104f3a7895fb10d0ee579689a8d09926d4fdff9987cad434b6c66298482a032531e31edd2731519ee73f8aca78109ec5c3d39f53651c570cc5d49191357d0521c087242fc7f417e4813c934c9ec266d31f144453e3aacb769ec2646a1cfd052431010aa0b88a0ea0d0351502a10c19f18503509ece064563a0d2791000200d9d89a8001440dde7b001066091751e041d75c53374649dad1bc03f81ff7310030cc0d26595859a21cfd19f4fd9c02bc0ec32095074164be3d82187e70c02858dacb0feb834643254b6f6ac60eb0c03f30183be80d9c1666b6c8589f88496a919d055962aa3685cea3271191af338a72e135b41a222fd58834a8d3b2c1e8ac6d6a9ca7d007afaa65c2a55c9983a3ac72a597ea2f5785579ca67a1a9a874a62e4e6f411e537b1c49533ade133d9a10f0358e4643f891cea5291b5b7b4226337059bf9e59bf5371594f7b2c9d836090f19f2cd29480d580532cb977194464ee9f9889f552385af14b310810591c45e7d2600c164367320a7c6c8da780ff95f2e0030cc0c206c26c6d28bdbad5e6c66429bf84798f817f65929c6c727228bafcef913f80a4bf8d7effc9b79dd9faaf6cb60306128aca43f945a8cabf946e7ff63646a1a393f294bf06388639422d80e6ed1e93abe99c9162de02473485c57c539ed30a5e32da63b3dda98b436e81eca291f99e78eabf40e7debde563c2014e47361df14cd2fd7478cc823c5afc189869f8a281f2fbe3a43035f937b1fc3b82733b4c41335135d62dfee3bb2811e35704b8df7e466d1472721f2aa27b39e77c32b28ec49ad5916ec940d1198be06af22f42d9634c607514d976a808497a1fe7782351d047e186a3840be91c6d2e2415f4ef6c137108fa93d047a534701a8fbe601ce22bf7438b757c4a8e20d9a81977e8593d4c83a6bfd4032a7dd8bfb5279250165044298d94f1740b5b98b3d41d6a564c248509e1e92413789016f6e0574203b006a15172610f40a4f5a16cd024d58f495b42136d29ae2f0ca73f007b542f5b4e33025274ed239f77f3259d27fb49365de7dc7cfc4fecaa7da91af8234e460ff3bb826193520ce0c93309399cdfb52cd219464d548e82fedc8f60a65007afab9c4355efbec3e8ba2c9b2e334c74ed7f7e1c02ee49eabea69b5c857e12560c3a8bfb37fa697e41f8c1f12889fef3ff31996da23115f6cdb14cd2ddee372e1e47260311599387d594b09932004d8898b850713171f1b04c7813093ebe820d9b968826c833f7914266fd3c049171a4f9c60e50390a0f8209464281e16f26de90e9a737ae292b1ceddf4547cc44a08933df2caa41d19ebccbcacd114fd2590ac3e4edec3c1b5a676b43fc1f9d7ed4bcf128806abbdd0251ffe6f9d078ceacd81fcb4d21325305ff220b9a042dca6382a2717e8868627a63858efadd3feaa28edfd0f3e89c9d4e17039b00d6a22fae1db03130709fe8803381031880253f5e7fb799ea4dfa1928b80706b61102739af76f3951234f47067e0b7dfbce3ac4437b863dfedd89cfdc81efdaf3bf3e17f164a10f8a6e2ac8da9d54a81a9a11417d088d039a6902da6fd4ebd227e24f2d5dde15fcc8dcedebd9ada6d0d97702fe50cea162bf15389a197af1a745a67260d019277a3c8e8946670d2249fb33ece6c4ffacf9c2f53efac6fc61b091ef60bf65e5e373276a46b80afa2d2d9ea682ffa79adce5565ae473a82bf01299fdbaf8337fca9fbd70a28e14cecf92816b245d2eaa0e9c2d1930967b72b49fd9184176643971e67918bae7116aead289fc6dd4214511928a565d91c6e59bcac94552e5c1c712214cf03a87be84f48412f84f8f28e9ef789befc2ef088ce993021f376dfd847e54ed9dae51e14814b1c2050fbfb0bfd538fafd2199395dc8116fd69c0dae9cb9dfd173713d4f4165a980bc31577e0a3b64f130af2245f5023db5b8c3385eb3de1c3641c326c4810895101b17135026099109cb80050be60e16e43b57909bf3563e4cfcaa88035745fbb9fe615f8dfcbf652069da0f4c740e43457e6caf301f592cf4531e76a35c659fd5c85ccf15bb22c32f8137633ed70c54c304d5d4997fa6dfaf2a9bfd03e473f7cb4a47fbf56d129a49d80806ff1616a806aac638da120a4ca29f82035038e6a386a062e31102160fdb1c5eed97cd92ebb2b0e6ac52429e175695a9bf7fe141a089335ade8a2e1fe93e1cc1bec2a849066527b03b07240e1d5565911d3db05d78c4e4b06183662269b748387ffb27d65cf50935e34e2c1f74aec282fb78eafe43d694a3673495cb8db3eb3ff9009267001fe1be9be141826a22318f4299d38342789cfc5843dd399a7e63ef0f49cb5dd77b6da2fe78f2347904ffe956bf1aafe019772413b68909191f32c9a3a5d7947f6ffe82b06fced8e157fe560f69913a8d236b000ee089966bdf4121043406c810f1b00185818f071d17e78767c83858180490a14081f8c001858187bf708f1e01829886f8b83858988438047860060624426c4c5a3cc0221ea644c16506f3685f2a050387100ade814d06d253f121e27a97f5b4398cb744c85aa06969ffcd25b54cfd6675280af7c80553fb36e5515c74e5e76e7d506bf281f7e8a54b600f7f37591b308c1fb0b9423296d2bfdff3640213c6637ac17102b6b03dd03817e23d410432cf8440173308bedf7baa693600e966a347800e4d98d1a8fbaae94aa4339011e7a8df5d50951d350b95e628a8b3d00f4f7375e6d651d8bf701e0043111b76ecdd38bfaf38b417d3e6f29bf323008d05816f38388f8e138b8ea525a7e06509855bff237c55476529df32f2e404599521e9cc97f208eb2122117932f17f9ae6fe959541458b857fd77f6010346d2fff48a67ce5109d316803f2cfca2ffb98775086198388f6eee72aff9d30bc5f355fbe991f2294f33bfcdab80f1d8a8c9a80413d0104b3cb0bd6ef68507eccd0aee8424efef367e0fc9eebed4c1e24dec2b45f901cecee089b0c8796c977352f97ce0b229c65a0704c321293ec00cea0914984590699b78108b171c87c5114549b7873cca3e0033b31d4150e17073a6484097760d3160e0f1b1b3236c2445b90690b069d1093102ac2045b90690b46f09319c2443bb0690b878f072a446808136d412eea68aae8256c5e1a505a655a4c5a95c9c277b26dcf7ad8afc89090064e15c16f8d1f07dba0e99ccbf249f05289147116316d867a4bcd44fbaeee9712856c9cb90317ad4495a7c099d6e48c7d3b7a21a91cceacce306afcd055b7f6ae9a373d3c9fd45d47c0fe907dddae3bffa470851c849e13331e1b245ca8501fd0cb765d6758b5fd6e32a6acefddb93986bebfc79571626a5c5011273b1a8fab31990a33dd7229b9eefc88ca53a207d6e35d0693de0ba518cb53e81ceea3b68f6ca0e8e0af59bc7ef131eca1ac558069e1425ba2cb32fd69072f9ff8d83f05fe4be4b4f8452bbd93dc8733ae49849dacd39d77d6a6f6486c0e870454c5602858cb86ed11c9a6d189844b5e2973e985d25444ba30c2016711f0cdc58b0209d22afae412f2f8e6157c95bf1a7cf3d0f7c021fce97008f41465b752bda7633a046826f840326371ff1fe441f8069fa77944f2717d4c6e502393e090997857b8bec432df8c209a9a8504ce1611474f3c92e1704716c4e892e5f6787bccf4fa6e0400c25a1891e05fff8a750cc23c060905fcfa544255f0f7fac0d9ba3c22b2d6848e34c082328b5cfa716e5a81fa8615c8dba6c307034c3c1c7c603c370e2f7967601440f87dcc24808c838907684c130a210e21343c28783898267cbf0874900750e8e8a4049d1a99d22413286e5f76c0475f6ea6ee2c7785789fec6256c7c79a4cfaa15e06981f7539853429b34afc4e27823df9a9454f3130fed07de94627f9fbb5fe03cf2f0b143afa36588f7a33d4591ca8facdfe7fc27a8776f791c468be9cb6a39ac20abfe725e0c7930cadf94bdd894ce75d6d20559b0aa1a1ec1bcadf190181f3db84add5138b33be119dce4a36d244efa477c78e6b53387db443e1ce30af72b59caefeb680a1f014ce56ff180c8ee6a3269d2317baff46c4277ecc6f1e408bc984061cc6220fe88fbc35b2c254e87f7c3b3384518c28d4a0a4368a5217ea7f6785248cc213054149d49a50d14cd568ea4a933d79bd25540d1eff2427123f4f7ba8c5f67b917b388fce80dc8d6f27b2f2f40947c8d2909c8a83c0b0d498e090cd78f3ff2a48b2183894d558f228f5e280ec765fb241e635133bf6e1abdae4739e347f43deb1d70dd24fd8238fab6a7d6967401fdccd56c0c7e0ed99979f4e1ffe268b79b77ae9ac8bb1a70cb3ac88c00115585e42066a7f5f52918001ae8aa6da2f7a09f30311135434e6830c8f7591dd3a8d18a750c745f6ff2488c5c818ac9d11fa69416e573663893725fbd7da568cb5c1beba7c49186155a3aef1e04dc211cdd4c12bea86ad1ee48d586c717fe67a12b36fab2c643a23e612958802a32ae6e2c90d863929fdf152a98cb26d1c53939b3299dfa0635abfb97eefc25a784c157d8a42f7f413079dce61ecffbc09385a9ee14a0383e0c650591397d1fcc5d25562ed3cb6457754f549d965ad6db79b1ed7ba117429e99eed6998e60f091da57244673f7e62f37bfff6fca6d5b8269d3191b44d6b53f90864225c70b027b6870d37049ed3b81d3facfbad705c5ed364d1d9e8da44a3c40815bc8950b163a622af81c53505039791a68d7412418c7271637f33498860b9a91c00e36c38a26c3d574b5f9459b65da9a56f0c7c26d750b4985f6a0ca16ccc95b0bab37bbbe84b4806b243396483bcfb0cb6836e1fec0bb40d39cf0f0b77c1ef45bbc17029d04e8daa84684910af2185bd680add3a1c6945690424cc3c652f0ad6f08d464e7cb4eba1082d48aa358f77244a388c864164025ba45120f01f9f8b1e75747063baf6651250f48be1afa0b9c7aeff3a5742320e03fc42e8c8d715c63a3df71c5e679620f2068fcebcb8f9eb35ec7073cd99bcb2580d146c8fd88de79b16e074d4fa306b936b155ecb5c947902b721b0ae68dfcdc8c890ceb21e5a4b2465bc201eebaa9543a7262cef24ce87a4308bd16013d3078010783f95c1f7563b7f2b75024965023e577cdefd1e865b16558e2e42159235eeb1439622d12d8b2676ac72aec865c9c8283c34509ec800927741407d33b03b0fc8d20a5cc98fc3d11e7fb36fa8aca17ae20410183e636b0a8e114c25244c377458bb24faba7d57705c2dc03c1760698c71e9ee0b02e785c05a848a819f9e40b22b0e94936917e80a1fb838d04876748bd3431ecad01f50ed2252d02ea62b07805c1639c77f98eb135bb3902f2c128aca911916909e967fe8d0f499aeb40b36d51fc9faa1e45700fa8635f444b3026d4c64888088adf4cf82cc1c786774bc0542e9ac6747e17540a45c45610a28a22651cabfa16a62d9109f29cb70fd8692ffaac1563526dc13589e18d31aca42d45314559733bf135b84e6827de2bcd48a6330fc183797f0e381abb83602efe30e236b46f697629ffa7162416c6204ada2a5fef223f52eb18cc2d706d1bedbdfbfd6b75179183c06b8eb83f50b8fa95b33c0c91522b6a29e633213fc388f71e8f277ef3fc9e706f10818aafe84703de07eadf7dcf3dca9acef0486bb2309dfe64edb3a3544d9e28d2e37a13af2b581533b041679a1cb17b485a423f24d74fa8888a44de8df7a625d74c5d23d8b5b71585e1bb7ce510fc2916f3fd40871c564af9711ea619f5b7b53f647d174f088263482c1472285f8f1986ee2fce4770af147049e85a08512e95f2775cc43efc43456e8c628cc3dd19e9d4abe237f99b36d7fd34d7465eebe49ce35249336fbff198292784fd859db744bc14bc9b778e178e48e3f7bf308eee6ae18b2c6413368bd362358fd95560ca10c217adea28dbb8cd9f38c28ce5f9ecf37460e390d64e549222943215dc0f9c54e526695ed9075c6e142aa041e5ab858aa2a5902045231a41d5d80ac0fe41a87e7a34e39d986cf22abec7b9183b209997236fd7654fb9d538b613ba407d6871c322745da5953dbfe4d7e6105bfed9158b3f8ae538b6de08baea2c146ba1e3a21290783b7ce3432d5ab55911c9559e108d23edc7e12be87d99cb65b42405f7a8a0920f7a2a55586b08a11d6950ac35458381a525cff21b2bc835eac173475ee0380b387e3f2cf05fb22ca4de470b91381b8f02efd0291a53e74e134ddd5384b58278c205455c04ab298a1286087227c526412e5b7052426b3db57fff842a6d1844690820d3b8cba12bec9ffe310ac21ecdc698990b489a5d697b43691cb38688524a4793b635896768cec357c19aaf0592ddb582d4b590d462d617b9436168c0e61ffd1797ccfcd6787125eebd4d5588f0cff6e5538b40b7e0bb2bddc37b1555b698a13225374488cdeded15bf4a50ed61519e37a6a5c2cb1dc93fa23c65390c6ba818eebcf8cf878d0092142c5c480f2008c0b092a2e1ef69110c01bb052fcd0f3450009a2ecc06d6ea8edac6601e10eca3f7a02287d3a7b706325bc6b70181325fafc2b96328d5125334db357a2c6e549acd264d0aa67fb252d5b393b55abbb62d59fd0a85a8924ff3af0ae0ad6609e050c89c176539c7fbb6865f0ec316678eb4a72eebc85d647e743b993863b4b9df5ede42c69671e46b1ae89f811e42d95451be182db70384b9e4e7e6fb72b655152cbca75c8dfc85b2a73ac600b598aef2d2e5802c1bffd79434715cb06bb02eea271bff31ac49fa59430e7c6f33dfb7ab5ad5b2c7bbd757edf3dd811778e63e4eff0eff5a1bcfcb3387ffcc295720c3a2cb34429505624cf7db77113e007a31020d35fae3e9d33dceb90e9b2de4e25332a2cd12127b76026c019b04cd885ab0c8602fd308830c742e6dd2834879ae36e9288263007acc1cfd095c325684d888ad622445c169ae241cc018c8d1d6f4e7a4ea70bf410e1da3a0ede72cada7ca743e24b1a2207c7893f3064d5e1df94655e425d1d088bb4cabc1cdc52b174e74bbed2fc5544e6876278d40fd3cc94ecb2dc94d9cee309ca7ece16ff5cb20468be4e09c1b77e8607ee3ed768bf8507ae9fd242b6fa801ab9ec0ee31cfffcea0435e676663c084eb4e17eae30297aca3f3fadebbb621703ec11eff0f31d1c93cc30715159bfa7b9004de6bbbffbb1f8552f6e2f8d3175deee97d61aad6ca2eb37af57aa287c8baccbf246a3780bc2bdb7530a0ece8f35f3772a2f4cf990a6bc78a9a55fb379823f0af0208046e425a8f74ec1a7cc445ebfc53363ad302b7894fd23da8dba28bfd360cd30eb1e54fa3cccb4f8daa730dc1d08deaf6185090c9ea6729c6d89ad2173f4abacafd9f175029b99f3269b36addea38c610a018b8b8525a82da9b19e34d37742f70afece0cee34b07ed0442042f681d30c713d0916403f0a5356b3af6a6cc82a200f75223561fa0853bf27fd6f26f524fc5ca5c8e6d1cba214ced847dc6121dd83ac1f50838572de67df2a9ba059d91f059987d627862b0ca919e09988181b4b91b16ec451e4cbaffa506066dc1b85ebd25dcaa59c88d0087ae2b4f1e281d3f26a3c4c3d73c48679892d39a9701f968274e177ac6883fa189eaf2f0d41f066027f5d5850a5d42157a1b98acdb9ee6f9838e84685074e8562636827083d8e7b218b4db305b025e2ec8d9318e2e20dee43f46d0557a6d7b7d93b120109d34dd2d9fa15a6a172f9761a057af275d1f50841b94a4008e7a36a68f2c847933d4067f6ee50b9b13599bef40247abc82fb741e79804ac66b50247e9830c6dc53208d9f4c337e967bdb1b2952bec70652e42182a546737b7928e265e2ab6e8ac76c3a59f0beb8aeef2893d66bb37f65b41bf1c7b55fb8edfcb642fae18f3e837afa36b55a2e3ae80a148f7e01bf9b50ba3bf3697118347af8d6b470325f1ec9faeeb223a633e3acf238dc9403482ef0c5619defe9e4a772aaae740bb15d5fd29e64c1ba67a4d2a55ff198f28566d79593c55511b8fc2b55f7e7d7e0c911deb7f907ebd295c63edf12bcc597d2f13ffdb17448d3b2e2250350d49475cc965d3bac3d37c1e2b30ec1e064cb1b29278ce9f9ec07b7662ca92f4bea854ab3ebda7800ca78ccc10ad97d8f17ab11cfb313072aa9a6d01a6c3638ca3fd336fddae77979bd47f9b4797cfaa220c913b82d6a5890a345be88683be59efe4206f5bfbf0d9e2475d0ce4e82d06a3df8a31461c3423e3a999851ba85f49b17e2d0c92ba38327221d3199b467e7e48882ee4b882fd988c19bc35a6703e4fd1a07976b11f650ba763e27fcbaf3965ee545fb14e96904206d89e8df1bbe1dbb548d623f7bd7e18da232ebb55e2e0bb31eb1db660928d38646348917159220692929de9f803ae5eeefad1e69b5e69986d219f3591fc16e8d1d7fe2fd206f4a245d14344555942fe06a4b3b8599f484648c9e293067bfa47a47191e0ad73b7c6519012016c4cfc847000ed5a987ded00cf4343f52644895ca1141b9889ac08484eec508d17ceb9befb3d18c602f582d7463e4992df8dfb7c34c2f337af20c1ff8258a897e0f225046eebf0cf0ae371f3e71ea7ae2bd510acba8e84576267d1150e715179721a54e765377ed133910fabafb7ac9d4a2ba93e73eca2e012a4757991a3777d325746f9667112d704bd8310cb58579c4775c690273af2cecd4320322256f8dbfa22c5e97d3ecd8d42338dcfa7144f368b257b8192bd117133d5b5e136b962d87350e6c1cfb97a0d6c53e5284cea997294ea2251e8e83209514b586ebe118182fabde421787e62cfdd1a71d36ccb943327d1789c835ea7649c3d63fa8b8680012e1bff478a418c1b4a1c17c978b02b4bf1b32c52e43469ceb704b3c15ed842cb215906157853a1beef43113a669cbac05ef25381dd917cd7b27b84fa853a0ab1e8beb0e6cb0223f81dfa1a42f52e4dcd54d1e99de70eb8c0c3cee278fc52822c2e65a8aac6d899469816622c7a0a170f47845f82fa07082444790188a3ae47e108c6c98d9b819f4ac138b4bed037dee4cc555e0c166cfc7438f92a4af7821f403ed898d812251a9e070b54fb3320bcf20f08efdc40c50ce7148731b50de03c16012983575014a41ccf7c76fc58dcabfac377a4ab25facbccf6bf4394622c55071b189e55e35fb33f6a0a288e418c864a45ddd468db788217bf3a717b45cd909b84513d43451848bafae8057d5599c7c10f239e354f8930321ce874162fc49ee709d9ab10f0a5b7b5355f66e47e4bbc88f921ab578be4605523084c0ef9fef0cbc10c738cc7e645f51c3e7afe70875f37813e7bc1e33ab651e4186ba0ab04d35216434a8099c4766e0b52f0cf3589bc9bc7db1365e060f02858d7a41a8f993b7eec0dd30b950bff2019e8e5b7c95bccb286a8d114f61ad60c020c13968f7089f14b9a728f36b67a0c96cab6f17019bc75d38a27f45ef649b110a870e705b2ae01784508d7da33306f301be0d7dab309050f0a646c4091626142c6c683bfe301f5333294b5c440baba754d484ced9114a074501ebe5072400af23e1ccb917a9b38a8bef316f5aa636631544e77994a69fa5c66c3b70f679e8b5ba4f1992e15b22283731f6c6e4475748e713d5e3cc1da3b79360c2bd3b9999a4ce73068179a97a37e9eeb8fd889d3fa75f9774c4405fbcce4b1ee75a6e9a955113a147dd429e6c77de34bac94fb47a8a7e7085aef83026f84996a408f84c9f1a6d79068dc86982ed7a2ec454a19a689a6b2fcfeb0e918463d079995854d89e47987eee8e85fc649b5fbb95622fa0cbb468341928d5ee988f86520198084fd0079c37ea4b717c3a27c77154be36ad3b6b75c3f46f5ec0362dc0a0f0f1191b5096db21a74ca0c718f1dfefa3bacef4d1d09ca1ffae487c4ff95103cdceae7fe91134807dc707dc9ddd8bf17ae709e67dd3f06fba623bbc2f13376e61f362abbb20d9ca133e872e5e93d8ec81d1c533542db33c9e0be17bdd7a0c8795f9e30e3d99677e19656d9c8a723d4c1c2b5851d7af0af2645dc539e31d07a6a854599e7b2b115da2dfb0fa08ebd0c9aeb3a1075848e88ed46a4e67dea5bcca9f5741ed0f8b984e6775b8c5fb75d5c91c8ec970d145dce90e7e881abb263c6d3193c14613604d6278e764b8447925c9e059e79a8f2938cb1077d7e81d1f48ecb9a4953cac161e3a23ba1ca2552b902922780452a659ff890a92cd299ac2bb2b14da307dbe1f58aff6dddbb7fce0c973e4ceb63f7e55ca421b31b373771cac3b189b2d2cec94b6a261a1ee14bd3e3a391c253dc1afaac8c759a824d33844ac541f688e081b7518256f2166c639d705ee44c3644e21b8438ee09b6147124ba26356abc06d3546115bbb6370e80e3624c782b63941904c93b0c0f77fd601ccce32663bd1db7a0227cd90175cd0390ba3f86f73671bb0860bc0903f8b418456a124085888589870d3f06a342eb70c654943513d24ad4cf523e6334435e40c0f9f4f1ca6b6cadd56d1fbb73494514ca8b94b4cdc895dcf1d227e9914b98b04cf96234b8b2619ebdc731ba2147ce46e0231793ec7fbc2123b278a6ce632ab2ecbfca504ad5aa6ea26dd043106845be0ef7c1554f695cc7598ef1b9d52ca2fe67a7fe5acb6ea70aebacd9af105b0c589107be4cecf311f34c6b03703d824ed5488cb82b998cf5c8b99c517d05f34401dd8408099f10130f03121e362e647cd914863b4ff4778cdfff17041bf2b622138c38d57697e1f7731a0d4afc18ab11edd05d9ffee4155e88a2c80c926d2f1e6145efe29ea053cb9101177d793436ca3ecb12c2e596196b447f810fbfa50d134d65ca7306e1fa00ca0a7307f73bf1f9ad23314f0507ab822a079cd3bfb8f42e5465c2d3c22a30ff73badc0151379637093cfbd0e87f5d763d174e8dbb1c5c2a4769739245bc91e94cd4b3a8a7739d9b1b31f44b63b5713ab5f5ed55e86b11b4b261a77647b1914dabb7915bae4edb8004e3031529619842ac8dbabae07e420ea73b2adc82a2816708927d62896c335b8e1f0bc73ecb8d36b9a69947537cb3cad0bacba2607a4e0812ca685a8d4ccaeacb0f376fc5f6e91bbc3ab8f822ef194c8585ca19b3df3a17fcaaee473d82b82a1a99434993d1e136799f6918f6a628606ba7d7b3a288652d47c69cf9e08eb374e857e01b622e623064bec28a4179a6b02acacbdba8521fad9e57efae556287d417a50a560dde77216271fa5659a3b47de3c6e2459606ae897b86b93165bd3030b0306fed13804288838307f556fcc948a25cb49496b2686b7eec1c7da7858d0aeb0aa3951d48004ce94296c6fc74df10ad6f45d5e9879d5c615054e448ff874ccba395ccb014652d947c9558a9f14523d55d137592110733b7a5d3eec820ecc55b5905586f54d659e99a8f3d3231102812d225344bd1c3a6480516ae112fbebab886ced151ad215f93f4b04ef8567e2b904bc2bc188f45c886e2b310abab746d539f16abec34332667b32da345d67bff5729cd67078c4687f4a3c050bd83d676a00e952a02ba6b393bc51ddae6dd7ec36965ad0333023e0b865b4b85a709440e83586e4478a0001195417c26960ff2e899f220a6529bcffa8531d08025b6200796b8821c219882dc71f42298ab083d42c60b61407dcde0dcd5d8a942194fa3173336004f8cd75a8fc65ad3a74b9e23599dbdff94c01a546966c855fcb5bf8fe9edf3d789d37d567cbdce6183977d5b1f477d64707819a65581f682c2b38327158ed86ef16357d5d4e0793993df447354328d192d6e40fbd750d6e2af2e3f345613f6643a4027e251672593d40b06576329ad1fe5b41ad7705ae1ed4fdbc6208983bc26f473b0c7ee3ac3b6a600f0445627a49c1b11545c2eadd95c74d8f006e901732adf40ee29b8866dbf2336d210dc8a39dd7178da27ec88506d03eb91e9687ed59dfe17cba0471464a8b9374c1b30acc1371a1604849979a5c4d39ff9289977a315c0e7d332aa519f7b1ddaa464eaedae8accc9f7897d37f353f4b5aba1ba286700f2d5551cbd55ca1182a621cbd71ef020889faa3255eae8c907af3210f94d53dc31d6c5dd4e2e60c6b565f688fba97d65221a41ffff5977e3c8e77ca928f2069a68b9ab99f5c62f36c7c23bf85335491f329ff56d985cfaaa8f2d5d0ad1fad57cc037a111981a83671886608aee6b5a2e3409c77ca6567e9c7958a69de3712bf671a15e08db59731476b15d10357ab81b1df95f930d9bd611bf3cbee6ed6119b0805cd9254923c2079699a445bb244201c2a58a0e1409b3634cdc8465d8e427b1c15a7c733bbf486c4be658a9bab2c87ca740c0371d3a96266b4432397e629ea6054227be3ac5b6cf65a4b9f8365b483462084c92902daa4c8eb06057caddf3e27462a2efbf007a8a7e7e00b178281a5b37e501b8326a0bb41c3217b8f18d3687bb9ee02092dd9c4ff6a4f6d0860388f35b14d27346068207f2e5851becf9f5e4f4510fb0c5060eb81a38e45f71932c078cfa2ffb89b1c94e55b4b43445a7206b2c61645ce56342c03571343c9072850b7ee5fc849884a042ad6cf03c2b1090a025bb036836e5b9e4e40c744ea5e8b4f93a081af5f34f9a136bc447a37356857f534fdc68c120f316c2c8bcbce40138b27bdd081b9f47bedd0403f9e8bc15a2b9990357bdbf0fee45c69bdfde42d719bf25a26215ce59d4443c6d70a81363ecc5f4f6f2723df4682cfbfec1cf1a7626a936a61fba3e1ac3319a111835cdf31b37070f5e3da97d15fa21a2cdc9523a44d6d45914f328d35af65dea823d944e6292c119c13d25b21de99d53423d45e7c0c52e9d44bb1d765e73a16fd6abda11efdc7690bd0437577c020d2472c7516fe6d96135da3cdc4ccc00da5821423d89d7e8401f551ae7a47aeadc4a6280baf2e688e89c1cbfc846bc967c3cfe5ab0db72d57dcf8eabddc546dc26dd91135f3e4803bab5fe7a20fa3084c307bf0512e44f21688827a35f844346721dccc9753b9862face9b80d556f7e3ccd6b717c7b03f21e34c3930167b1fac71bffc29e0a22c36fd3dd4ea7c2217a5882a2a1619fd299ded872ba6c56dac56ba8b6235a68f86a75cc3bb96f922e9316ebe06f118e323d43003cdc9bf44075bf5eadeefbe8b236520888667da3b653ed51b78d4e61c279c5e5cabb69d3743bc9f9d1359bb501edb770ab7cbfec1f2e5a6c31e8e6d5a9803b399466873fb3014adf975ea88d84a95f1da781d079160ac4208a3c6dfae45129b94a3fd73c2f8591cda561b87ae32847e7f1f27361b98f6284d1bf5f16d85670b4585fb55156fec989d75e447634f6b0ff7ccaba2955d30ee58f35e57a659e1679bf410c75e58b71ab11ea1d7d8b7ae82c9ad93492ad9ca2668a6777cd8a01b9e5bf4cce9105464e42dd39f4bb509608fa4b685eae3da0d22c6c42624c023168f6695be4f42f45fb6165cecff8d8d88ddcc455f360b7f3fb5cee1837cd6e99bcf1ae7660bb9927107dd17d6c496f748903b0610c358c617bb9cc08f657cbad548884664c6798bb1d92a231d85b1b2a597f356228939e02d8a8168329f2533ab93f465d02a193fd92aa7b4f99fa078e6fec08e0343a7e707398671c8eb0c3433ece0322e597f368f187d1a740d5565f5076b5271830e5586716c3f7c38ac3f812bbc4e5d14eb51ceba32f9c3fe1791859efe8d4b406ce7b3bfeb93764e2e2d3c9db731186b44f2d14d6e2975d8d0a90685bd57a77f6f0052d4e2b061eb70e595a83f3961a26a055ab0cb22cd4834d3e5880284e0c1d1b4b8c2a3a95dfcdd88fdba07128a72832c5cfda2fbe19284939e99c011696cf28d29a24b26bcbc234032882a08f172cfaf0a076642755f7ca224be801a39c6518e44ff56be4aa3a9a31ddb70a774ae73b997149ef2c154773bae7be2d38e025dc36d1ed6bad6bf87eb23cafd41632f7712ffc55180bdac84dc17a6af2bc4e4e4395a0430338c141586464df61c7a5978e9c28d11f7c3ccdd32a4610a711953466a25d7973286b045c5db936767541f6d8465bff557a4ca8ce20b5cfb4c76b356e1e505e83b66166acc62491ebe88bb01c53c0033733a9d87b2e39af9d3da19b2934241f666b38d8153c714dd4877def1039262a1cea770d7e88abd6bbfbbb4f18295ca0e141044ce0e0005e1c77b8f0c5b52cf3e469792612fde8761daf7675880bf626054fab5392321eadd477331d6f6181c94d6a2d7662c923a5bfe4aca2bf1610a63e3735f0e07f685e6619312f77bf8096a2e2970c8f61cf7f0860aa368a7bb7b8386bf1f24832304bc010b08dee8ec69f889e1a255b0513bea379339975cdfba4fa7ac5d305f7af108ee226858abaccd17bdb79ca3980f810b5b94b09d2aac4bd4cd62dce8d744ba68122e30205b89fc37fc5be34d6f6b2a2f9d3f92e4e5cf3add095d5ae09b01be3f0dfb90bdb958204018e36d9eec3d5c0dfe0f8d514888d4dc0b5c18bcc29ce8cc9007b833960a0a556a4c7939cd6b06f8c3bbdc918837ec3e4af48ba9402b43cb9d7d04a4c654cae2f4c21c7c3d5f5c5a164947243192bd1bd1f1d01f710437e83c36fdd6d2c3a4b1e69c3ac053b76a9fca2be27d4ca2c8e67dcbd264d91a8e1f1bff3a8f3d1457bc19880dab0f69e6a242cf63a93cc4277b839fb3ba4e59452d3a17b1df78edb3d0aacb93b47d64b1f925a9cefa0746f4a731c468f4e001e34ddfc8cf75d513fe6fdf0a1f07655bbb7c41b48438e7b1df37e25f81ef991960a90f4d878b2c9ba44984cae83a71c07003c12de8c605e015746d78c986a188a3f284e58e289477fdbdc6f61181a5b5bc86bd99bb24a504a4757b80159d236c07715f24ce78359f61e2bbe1372463dd1180a9700c60e12d810798ff9614245c1c7cc8200182784bace12d3346d202e90c0a8f11375485a1c670dcd9da15e5d2d37f68cf1a4276b3800decc833e58682bf6b629d15e943221ff1bdaa7f7c773304aba1a18cfb5cbed4a06929185fd1e41cb28977060752087a6fd35f3a4b7ba9f07133b967126ff2505a7c6eb203179e51cf6d46656d014cd38ba097dcb73c0d8b92a7c0daefc7d359e0af313f2bd3e3457e7f03dbe385578f63b5b260b41eaefc49be6afc16dede25886251a7b1799b81080c1a944dd6feb969eb3faeec805e74c46cd6801a13b37158a92d7c2b43ed526360910cf5ef6391dcb75c1e3aed22eefc411bcbf24dbe8554a74c0155d12dd4d4c2fbcff8d6589bfd1891f97cc7f4eab1216a42ef7bd20cec8fc2ae75dd74e60761afe6a53ece4b780b71b74a3bddd42a0e7764013438709999fc9a2250951315a0539e8af681858181c5f8e8ed541e285ceaa2475c4e946f3a6b91682ba1f1c4a1e8487bd15a058c2ac68789f9954ce78e263e483a93a1f254e4556a35f6dcc2463f6da5bcce3f05bf013ba1a4f5713c8f9d740acdfc5ab87ecc85fb17a28423dbfd3267564a8f7c8066fa141ecbd3544e65cf482318db3881c76274401ba3f56fa6b3a569e0b3884f6383fdc41ca41b1bb6d9e29b9cd3a775d3fbe8aa45d6ae7984c052903c724e3101f88123be4a9b783b2422d350180602ab8516a3565167a1322634b2b2c21c7fb2da7c26227f42b536becfdbe21d5ab0514c67be43013f45221f3da64d7deeaab15222c36eafb26939c52f488e1ab0bcf5b440add3099075cc007a1800d2e8d500d2b5dda3bca2fccb2e801365e3512bb08aaba2a169ab7cdd53492283a1a628d8a68935fcb70e891c47143dafd6f14cbdbdc08eb608d035ce4bb9bcafca56393a333a1026f2ca2ebdd23aba027e0dc72d4349562820989092aa8f68522bfd7da110bbf2375c466b10f1d61ba5c398f489b0197df7a707e2669baa208e93528372cea12a6b5499a0231a2d26eef9674b388b7842f644951957ee3b83b0fc2b856c816f4568735423461676791e6395f4c80c28118a3c132f7ba2fa4e6cd2f6d6e071ce6b64d917ffe3682c54060a3f9a2fcdff246f9696d2295eb60e4e65d3d9e5a7d9b0465439388d1af62751dba773036898e3ccd262c482c0ac9c2d4b05870895d90f944744446455d6dfd1f8ce5937e9acac41de155f048c7a0c9ace44bfb8409ec2e9d177e3283aed580c5e00c6baece113cbb3eb2c0fe55710d692015c2e891934b4b7477a05560c81bdb2ea9d024de53056ff5fe9589f8e893564d030319114079b8d41ffe5b66eb844e198a826ca5699f1e166c80ec73c9d338cee50c1ff6bccf3c6d04239907bee68f41ae21b9c91d7aa66144438de13aba76a696a536a68c3f84b6868f28573b3f551fa4d3a2effcc41398f38c9580a9dc9d3ae34d27efe23dc18d8effe137826e2dd698f3cb0e9dbb55f0c766e81e6a9d637eb5d71b14a08740834d97b7a45289849b08c5d663b147eee7bae8ff41f7e8d31ee1be1c4fcb3038da245f89d4452655730b8f21c74361b305ffbfd0f8373ffb73982a0a39d394ee8dce87e3b58a6f04c3b314e5d7aaf553fd1300a33081dd41114b818b337c6e1f1db40c786ed91c2acae52d618becdbc237ab464b560baba81c12b1b9655fa3e02450707d24b5ba9bd346b712e839fa16b87f4d2cf4f8dcf9e1694750ea56083b2d3556fa332e8eb49815601135c2c968e2ca3280c7ed0d53c4ecdebdc035ee5d29fc69b22689e7184dc61b567f45c8a9635e03114b46f691832b1698e42cc853cce4b314703681837ef3c46007439e8dc124efe417b6618c32486ce469689ed90e488c982e4b9d6e58518e89a1ece309226d8abd0f98bed8ad2f826e98264e0e240c7c5c1c50454be500bf587047f7ec0a0502c44c9a190fb58c81c4f43652384db35acd18ab9484d8ddbafebace05a320e391a37869fcf6caf32e4c138dba18fe2a796f722448fa5c59b9bde7b1e7c6e65c38434f1b97269929e75f10c03c28300843836163f4b60c6f6f5c62a8791b0d77564a6c75aea2a3a3d82e393c4de9f110fc775d9941e6a758d12315554d43174bdd1c12d9891c2727a11793135cbfde9446ea7bc593ba7e0299ce2d1dcd80e4949311e789d13c9537ce8940bc98c08c3ec31df0f9dd14e99bcdec1487db0fb87abeeb4af3311a346613bd68271b482b718ed393bc4e186b27857c3afebdd6f9059b771f1c021abcc1c92a21d108d7b5057ede9e27f2ba4ef430b220606d465e1349e9c00c87eddc3b7eccf8fc2e03b457a11f66c4158fba67067d511389099bd88803f7403c4db951ab8ccd68bb524e470a09cdd426d6e7f292a96bc66f7945f152487e5ae12cfcf8aa4d1d43100d728cac673aa689932cb014bd12632bb89e9e3c4ad0ec6dddfe82257f177ca928942f38cc2091d605d637efb293e02e8e3e80d0d285c1c34178e85e49be8981a1a6f0d602c299b594c3808f64acd5e8702832aaa96f8827822104c74b76f1f88ab7118babf572a742d0ee3f05d84101bdebd3d1a27777c6d22428e3878dbb8bb702a533dc1c8036e098c3fc23fb61b4097acde51e0deae86db0be8e66aebb97f66a0b35972dcfec2b2491b66a81314e3e913a336678f52aa5fb65d6296b88f3a45fd116af90dea1eb531c1a3fbc8e83c1b26bf1e05c1c2bbbd94bd0fe1cfceda356ef27530bcaba2262bdb8fb16c88e2642cf9f36b8f17a8eada0a1d3c7603c8ce8168cab51f7f8955f8a52e3a979bd59e71f669bf2fab63350fb16398ecdb0f6d87cb5ce3aca8daf5920ef67653898b694419ba81f4e308d4e9fc619641236526e1d09e30f3d14fbfaf26ce84a749cae07cdf42c9b91a51e791b2652e92384bcf853c5e1c82f59b71494546e09b9267d184e239df9f90c546d8a8a6297e4ffb1a5a1149e9d687e7a3e039e8eea3ab4fcca45de23460cc3172c37db246c8426ce78b8e017e5c9a551db3105baf5a39334c3949372d54b5a2e666653e6a2f81d6c456d6b907891b2116e425352f5be38edf44c6755d203768aa215ed67ab44b9560af92f0a486cf42b1fc610a37ce3336028f7a08888ea45f2c3e9a1849940783ad0f016291cb60589d0aaeb7e6307c329c67c626b87c17f585d1447d80ca766cec6a7b11ff9e3f419d43296218f31740696261cb1a07bcb6b605976c77d5b5edd9b6dc217188201f2198384b86aa91a2ff8e8470f53d4a6f6b4b18d87067f34b4dd3bf2f02beaaa3b29453d0935719988120d996b1eba668c5d77c3517a0b9d09d397c90d124d6ce8650239cecc297a4aea7f9088ba502326bbd1f1bc039166f75937238b9ab844690c7b16715776d5adfde814670c5535519b4492f23efea4690256389257391b9f394e0d2391ace73058dc088e5730653e144f07d15636286d27ba7a14a6a5ac9c01c96c62866d3b4693ec6de2811a47ac365a6afa5c421c235973f0fa566a2a9569721c8a26759aa5f751a075e8b8e4667d0692afef68e248667436915527d1089312a8f600931d830b6acfba2bb9f3d6e69ced0b41f2f12766f4357985175a6f374fee765766f06dfdaf652b8b03f49e1e917df622b2455aa396a0e8b1966e36c65f1aebcacee8c1453cc4ef090da1564cf3833f73ba11d72d41db1a656bf2f77431c6c1f8fcb4469eb3e323389a3a9ece52521e588737d9aca7dde46cdf67c7d4847b4e6346019977b98e1a2d2b3fbf466bb91d4339d5db17b2a2b2e7054adb2db65bc07bcaa9b6ee178584c5ce294c83ca6a68f4d4d76b003cb32d08db2f2fae07d479d149de84c1e8a7ae6711ea7f373c1c7453c2a04a2295aaf44e96632f50d7da87352d587201da77b5d43f975d169f9ad9155451654c490b05e5c7c81317d775c363287a4cd0fc60aeb8d3e9d8e6e3b70d996b1034a8c7288c6f70bb36262e3428386878d870f2aa030361a694d06139b5b5c02c69f894b24e63007230b3bdf791d1953002cd88c8d0732443cac6531e8c4c0249b63f928d60a81e52ba0e0116263828a47b88f00be1f11df7451775c98ef23dc56aaf238d095c542044507afe51e6054194a06596726c7602312c4817c2c4563eca20e86da317634cf0332c66139ac3c0807456c0f1d14bff6ee473aaf0e9a33602943c8a47be3a7383c3aa771403412093e1528aac49e6c863d3a339e2ad21cdc2db5a1ca927ec21a26281b27b0e5ead0e657477a3933c3c46e6fed5c80ee7ffbe1dd4db63a41ad95e1665320881aa3171532533993cc9b42f2dda541b39790f8636eb40186111da307d5c38807c5bdfff0e341ef1a183c74628a8f5189aa85355147f6cfdb3ca5b400c6e88af4a1785d0c586b916bd038a5d9cb3a57a440e1f5a327609c7b98a89beb65d24fff08e5d48bf94dfa50f04b622abf58f40db4f5679a55b00c7e36c23c1f9708ea5ae26f51269eb016c0a9734ae43fd45e52f676af2f4af22f8abd2ba23fd1504423de0b1e0d4480fb9c11084569ff4080bd2a034611fe914729311e9b76ca18fc0e93c094f93bee641bfcc1f4937e45d6c7b02cbb72451a8bc751e4f59708fc628cae41bcb08d84285489bc636f09b406b80eee5d13468cb92b08e212f3356365aaaad4304c8c01ec47aeb966dff232dfb1fe1cf5584223208ee1bf8c537774ac19dbb7a4951dfe23dd35cbaed40d687749f9ea71df818c8be0c15a6645de315079501b90f03aa65716b8e6d86e91501091d2958bf1a0cf4852c662a61ebc1889abfcd0610a170986462098e0e8c3076abb269591e7de354f68768a69eebefd6c150cf15900f7c22a30b8dfd8074ea0e863c27ca7f698266c621c5099cd03afc0768c5fa5088c02015309b9a307afd1b7ed26999b9164d2594b809e546eba8239c1d850559e768d309423085e80022b4b6c99279546d082588d8a4fa372c5172914532d884b83bc10fab9136c30b6a3a915b76d6a5d463f28b30a1535bcf39399f6ad6bf36d56c643dcf4d809b497b81732d0b7f5d3da4f9c2004b1a08e5a501304a846bfa50838bff44fb6893f7eb2953acb99ef59798646e0518a2567ca1f1391623823aefa5ee22f63c2664cf28d56a8f2da4f20b1eed8906b0859537e453e93ad7f67241a10fdd967e3272c32a953d49a06a53232b698d283ac9b9415ed68f013093b492e3a1a05eade7fbda0fdfe5e5881663976d3a766411639da7b8bed7b43cf8db41f14309086a01ff488f416d423e007bdd1f77404bf315f70127c1003ad6d983f643461a25f01085948690b2b1532087eb3d519ff2685991862419c5764979c05504551f068afec71e5c05a89b2c003fd64ad17fe6ebd89013c2acc76d0beabdaf6f1420d84f1e08202f7c2dde5034f9551caa4f08ca7248e8bad18922e8c3898df7b24b46bd196be5fd1642029536f5e0b624fe049b315df35230ab72b386db2d7cf1faab299b9db30e02d1f757039731c16b6b62a8b7bb652cee8f523f1186af61e4feec1b4919420a820d9d95d5b665e85754decb6a117370582aa6c3ce1cc42c7003238e13bcfe61606aa42b812a1f40d9283c5da46a2eca76222bc9c321abc6f6bf8dd8855acc60678900cab9b3dae3526eab7c33575f61a0d2ee14873303c4bc9653383f6e5ce6edb64c7fec12d66f547dffc4e7d0b5549989b5c342388d4e6fd827bad4da2e5860212a468c48f366b40f9aebec3c56292d125da70c8e6ce647012d227a6c36defaf73bf95619c4983df809dfd6b2a4dce8661bf5b46bab4e6131fb582cb6236d24649fa229044fb3e89e821f87ea278cbfea247946ab007cd7b269a5ca649fe90148fe5c086ce0356892c7a726ef8191f718541e20451dae5472b70e2493d12a24617450c1b0e22dc96c06561342f2eccd6256178b6edc660f718d20b608c15485820146babaf5fae5f4a32ee1d227b30fe62854a6670965ea12ff2dd45bed67c28ff011c21ab92e7087ad63d018c0c0e4376edc11e9abc663fc9c83ce3a8d2139a6ef88c81ac3f66151e923167b6288d91080c4b423163e5965adfe90fc27cd38e9e546a35222311260692dfac3bb4d28ce747bff9ae491d5c97f582f9e0d7975df9ba38f3c7a48d63bb2b744eb60870a711937ac989e01ecce068d635d1348327a41c0e5998697f7f93c1e9838ae19927cefeece399102cd43011daae790e06c042a133feadb3c8dbc89e479ee35069bbb650b21fa59365935667ac08c88fd4226ace7b675ba841152c37509c207770f658913274ec24a9852b6016b81b29038710876f4df54635f5d1182bec98163cbfda2da28d87e00df9249405207b78be028fcd1d934ea395dcc1075e854d96c48f5bb16ac88f14a4277c2095f7b624e18b71997aec75ba3e15afc489b6eda3dfdcc7c67c43e73e02264ee0a3a84289d108094a8b90d0599a8f1e4174a261c5fff5f6bd6dbc7716be3846a579d8b6b517e767334c4e3d5d5ce0a6ac14bc9bc3275b61180605dbb849f02600e2ba76bf165dd033b486f6f7bf69c7c08e39e4c7a0bf1c9b1c7cc56e4c9a2402bb6db659380886f60456370feac325df826b73579dcb25c6153b8416eb8d8ef98e68b485f21a9968289f25d4ce2962512f2f518f609218ce48b63c1e824fac027198cbd82b707331a831162c18d2c99d6b5032f13475656b9f12c58c5bd0327827c8c6b4ac06304ad79f74ccf7add1516c7962f8e579cf4aac249ad5b1c3053fd8efd2507252807be155fc69c87fccb9485a89b9321edbe9fb6e4f5444c54e1059f3a06b5c69baabca31af5279cfbc4373bd361e0a15f1d8b9153f76426e5cea29338b9c8497995ae56d1bbb0a737178a336a7dc5dfb95530d14d5080d2e52db3fb631154ccbfc0292138b5aad7b8801c9af2ab6b6194f19c2e698d19ce0966c8654a451b02d58b1da37712abcdb11b363bfd133cc02c24b73ab389537a5d2a4b1a6cf415f4d6e2fd671c82a1ab5445970914699ac4bc5d4473eaf9b798ae6354dd342f95ee6b001be19648150ea9a847efd4498f23bfc423662352ad5c9f48e5788710db40315261875aabbae3cd2ad517b210586dfa1581173d1f3cc8d8e58adb7a9b344aa1e9cd1c1688bcd89dd1991a738a9b22c289501617b4b69738fa08291551010171a08b495c247e4cc9b07c427cea52daa9d7b4f00a6cce44537b6685059986019aa8ccbdaccf5a1617f56171a8e8e238161826666d5f24f09d689c2281711cf48099ad0ef88a56628663942555049ced0f2c47977d8f2acd163cbb76a1d03f61856e526b7d2f98f0c8ecf706fe673cd68ec1650940bd8dfb0ea71529e63af6824155d1dfc9948c455af4b5b49592621a2bca54c2ff125c17641efe1d1e0cf6895b2dc32b57d3e93dba4d2fa8c71bac484de16e6c1800cc6f55de40f25a58e2b3707f04cd242783ac01b298b41657c8fe0c307b18a9381fb139893487e0cc5ca7150911c792ca75e744ebaa4bdf26f417e10986b75db874451d47e1bf12721020eecb4511d4d1bfd58b26e9a0d01eb197d2341788bedb98377c4fd124888626d37f24f788ad3a516e64ffb395ad09b873a21a9ab24d2e4d2db504a2b466fdeec4ceb9071a955778f75f8574ee6acf17a9bdf8429dc88d90d0e08bb7bf812735828a319befce5cdb7af162ce85f0771c3cba92da6b3ce1a1f1e57ad74f14bc051188f07312b8f79e152abf68d6b6edea63a80a98a7355d4a0130a9943475dfbb963c4513449720c5ceb1c5db541d1e5b3e971861026972c6ce82de0f24480426741c0584e1a124f60c2104d6d4021043406c810f1b0018501e9f10d2e262e641c2c0c02c850a040bcf0320c3cfc852bd1e58c1b8211da77f6922c64702c5c4bc55b7580bfd9b6dab713982c060e85df797ad6c73e6fa0b4b5f86a82ecfb581b649ec6bbaa53cdef1e9608d345696d654a32ce8e6edcdbf5825048c9abb6ed72f79a174797dde610bb644483fa57b430e1e4df4300bd93e28c5fb4969d2dca66cbd74eecc6e0da5ee65c3f3879f7a61f38441cc4e17227046bf977a35e020aa8f3988a2cb70fc18472acf5d5680cd48f6139dfdeb6ea1444475d07e875ad39b718ef1fb60e2eccfbff11a9f5a168868c81915ced9efe66197d63f53bb6da74c93ef52044fd7a1a23ca0edbe0d149d06ef78f16522fce6cdd7591b275eb8e115f8a3eabe4da4671a09da923743a632cdcd2d1a742da12e52e5953d9897e7f1b35ad928fa34c38fb76b6551c31dae6bcab51287af097de7c7b7e2f09e6a4d562ae4d2abe9f50a32d7a422b5668321041208ba9386160bf1713ab82e0ea24960aecbffc90f65ff1a79d494a36a5a3b195f7fc95a72c89dc6abb5546ca39ab2070ce5505364f5e4722b6b0289a2f9a988ae2084465fb2c1748cdc94ae18ba793e6b9b497f263c451aee11b5615c33675c71cd4240dd3140dc50431d116081e094541c768c5e264fedf18646be6d1e53ad3aff47f7b0e249b40cecbba9187e1464a78910c9b75d2d668e20a0ae2880d82a87e9ac0b69be6348724f4f75185cc3f146549984ce3470b554abea525f6083e24afde0e1f820db8b601b59fe82a6ec3d02720e2bc8a112704b130bebd866c837f2291b853e44dfb7e136e12d989ad4378dba661408cd7edddef7788c418e5521ed501d8bf90158b258e22d671d1bba0a6f8f9cbfac822455bfa1c97a629c29ab6d7c44fee50640dfe4794d36a3f422c0858e2450c7b2c69dd5c6a4fd040b4ca228509c24bf1c7699ff9ced04ca970aeea4a34ff813bac1f70e22e66d18990adb2841e443e352745a15c7103c6b35b98abcc7c9f31024becb2918cc0091c1d8f41295ac3cd03b011fdf7fc1326cebc39b29545ba716bb430d178f5f891d77654e4ced280c5ac820ca24fff45a1ee0029899f100631c542712581ee7c93c69df9a643536318d22b66f71b811808a95f44bae75c8249652337bda4cd9e66340c2fa8341cd9c876c9ea215f6c7f3e131139e352c9dabdf94c1aa6e0b02ef1950737da6fb8c6c4acdbafb35e813c856555eaed8492c802ef4b49e19799b5166a0d8b2cb3e99065a6a1b2b637932a549308486baa4418469dbb393f522528e2a886b8a0e2ab953aef08a6ebb89c7d4656158f1954c240668e5abf9829f5d9bf0a745ad04d2fb0cf5d075d9bda1bfa59d445f24471beae323c0951840c368569ba584e882116ebb6a889430971a9f3676bf9719719b07ca596660f61b527b4a2c20ca6467ac1309b56ec4da87338986334ee5020eb761bbf365b629144122a5bf97cdf0ccece82300d58c462123c0b382341444a65dc4f222c9a222514cf2a27ef02f1cab225d0d1430a63857f81ae7b0d65992cc7c8eca19db67c970a4244a07846b4eee65c068649319dfbe80f857428c299839d447e04ed4e60e3437224ebd2cfc2b8445a9c25ae546a2c91103e11ce68b2a4c82b0c1a494bca293e93322bf7b47ff7c9010c2a431d959f1d5c2bca25c56706cd3a8adabe77f117f5d3478525f6b8cb76d0a810ee84bc633c6e42d2995ce81cba8c126453d7880b8dc0749d690ea634f7e308d2515f233e5741e565b7405b849d14a21bdcfa6245f49928c5bdbe20cdbe977227151e5c239b453549530e28068d6f24e282c150162023da3495869c3be1918e22a4f20738e701d867d881d1263376ccdfe0c81994d70a342a8f90c3b91080368279dae37fdd0b91551e84d1b02f6b6d2b75e49731e0dde342057d112acee9b8a1b3e432e7df41756e7ca961a32c97b61cab9b2e1d1561adf03511ba0b8107ce46f4f4058d79a7f6ef2fc377417bfde8ca9ea54b7a395ffe8010acb3b0cefa9c098dc09a2d21f7ed348a2387d210235144f937868f3d8350948a0f876a543e104cd01b45b9675b08d04c980e47991f98853e64a7da769cf6a82d85dd0e1876cf6cc158f50bbe3bc47e6053a304678466ad786d8413ac0e70a28e411080799aefe77ff75e000ac7841986fc0087c84c58622d20fab73c29a2a1507ed77e8eb2b11a1ab057f4d1fda5c53bcb17423c70a7d9f968296cedc92f06376a909ef0ffd2e741c064ea3ccdee6be95609fc5d22a67911ff6232e0a2f2e01e4e189ff6cb36849c99677dc53031d740af3c2d7f32ab5b4af885d17debe7044114ed66c890865c0b12eb5779c0e6eb0d2f58dcb7213e3aea09f3d7863b44006ee4fe9b72b80c93a3e9100ce9a6ceb7a1eaaa0b8d60738d63d6605d2f55ad02aaec66fbe16cf2880c4ede0462a10041d9c6162e47cccd62251d1baeef352acfebe1b337c0c0a678c9f34d587c1a2b9ee20a2818c771df431da89ef5698829d470356ac422e7b65af8d2e0e82c58902d404066ef31838492c030a347b1a8543379544bc51465f4683d0d1f99bc17d049f3b9425229b1013953796ed0b0069ee24a978b9dc4cb5dd2ef290fe54b582e56c9a5e2e6c296b5f40746053478a89f514a2880e1ea59cc2876e258f25127ae894c58eec3d1f0218783c74666203ac95a9140710445c6c37354bd7832c18fa21c788f4d4c2755455e2c23214a16e2f7ee67ca230001eba4bdc8475be3dcd61589591ef6b6fcd502e42d03da3536a742e581976939f99ca8c6cf99c8d2362bf83465abd3a286520f52f6696a4a9d363ac9364e8b77f3dae531b2218ff83a43cfae1323251029e2a46baa8de20056d390cf04ddd91efc9e10653ce0111d35ea511be00db0d3096b67da6606f253ca76064c4e7f66478d3e15715677322035a672f9e6b31b2fd5d71ad528da55fa97362311d5c7652f84b02cefadd5b5d25f7c6ae258bf34b9186b8c30c4d4b582b260db30195a925a356cf3caf5b21482a4b30ab25d453631d02249f79dfc9075a4ed74f61367121b38358d95bfb8545061ef8d0a51b0fedb55afb5f22c81241490a84d02f6ddfa57b8fda86af012d120b75a121cc2cfd247755da9d935c40c0ac6ae9231fa78b56d786511a3853454ebc6e10d12f3f4b579da160e8c86b192bd230cb99a38ac2657ae9f59b839706940115367cb231631372e95723e7e75855e2ab5c749883a62cb175ee005b6f18c601636a483fc5b55b07114c743de3c392046a9db2989408363f28ca8f0d5ca53922345fa826a3ae071b924440dec580971e3a0c2a2289290a84fd81b100aa174b993f147b03c7efae4dc94639cb8c27288b2b07d5ad66d7444269191f3ccb478dc4e9cc3917e7c4336b6b7eab328b58b85dbd0dd5ecd6a76484648bf33ffcd460627d0a96da6f150d3ad142d9d5f4cb37b950e89397b2a8b6519536bdf95b3795992c4231cb203c6739b2fe8849884502d481a2d12ec916eb0d6627ee34debad1cfc1edde3f3818073cdef458b9507f3c9bb608c5c06d0cb81617a162d2bade2051cd0564f18e89c6821710476693ab41b0c12a297e2f71db9a162b8fdd4c9eaf9f9218e7dea38a33d6cc9901ed5cb572553baebec2ad4a9a14d41f7fa3d7ae3107485c9d6272a062243e5f83a219bdcc068adf6040c70b95e0320880d5087d894df633120abbee653ab65b80864a3a359f4ff5a46ba4258f03df5b470cb2c54172d746b442f3e2bd6b1a61ac29a7ea2c8e576db88ff02fb885eb6d47adc185daf915447c8bb6295649e9aadef5c601ab0f8fba62df83e82c8ea6213245a20c51a4aa3364502519967584e65fc6cc06898b224f83f43134a4cda348e2ddbd60dd4e03d0eadddeec32c1b6b056f6cd2f40a0fb86c634a3388e155fbc019acb3dfd1fdb42ead94655d6e28abcc300d9c1ff40a089bce61a8c8df5b3125246e0e13a3dd198f0a5dafcd516e0b28a6ccf97e7a2b40a7d76b09f42667d7465ff3fc6023552eba8dac1cd4b1f314ec308ea8e8abcbe897c1996a10b2e93c1481c9b92c681420648faf076ecddd65230dbcc63c1c7d16509849692d8fa3f020ac2a495cd6945cce5e1fbff91a33076b985d61ad416399370aa0e9c853285999ab4abf53ac4def35422eb9ca2e1a19efb734103dd920a494e8122271899d05df7c1be33484463a35051ef745e2dca789735233eb7dbd993432f55cbb1f7150d11729e22066b9e361c0398c183dbafa00e7c67c76957765992c0d55bf5aa9fc28fe2984582f5464e4cd26be083f17abbc2d4b94c8cb83bc94f96b1c66dbf0926b4b33765fc38c5573ebe27d5e23d1bc787698de068e84f48835ba86f298cc42d09bb01e5568471991749c7ded4b1f8c7e61dd949f2e7706d7d935594672b629398da323cbdb1ee7cdf9d83060c64c7f40f8ad0993f6e6eba4e3e6433daae267a421da815cd99b84e17b7995a73c7fd6970c8649cfe8ed1478d515eb03780a14688bd8a370297f8d00817a946b82915060fc1bd0c10c48da6a00213d1a05cad8f1f819f3f014fa723344525e2c3f1a3107cf037135155da4c95a37d54f75d56dfafb61aaad3b6c3cd98a2627cb12309aae720e3f18c3696bbae9e947b0208d1656ee256648d7030779878703b693d680857d29d8930141431c53de55ebc4d8c773777b78842e8f16ee8b91d32e6a5d5fb732b41d58d6dc815c4a4f0e85dd0ce5aeb41761f883d84e37876a6e3e6d14bf2f9f8350cafc98a73b04fb767029d6e49e9d3a605a0f4daae1adfebe52339f75b15fcaa9ad5517c5b33777b2a06eb997947b369255f49b6706fe68eb6e64b828697474a1958ad0c0bea0fda98dcb3e60e0b77cafcbd516d354bfb55c6e3a69707fd6acb8dc5eaf98342b163fbe56b8c9723f8ae32956b46bb5408a3a2a1c3b81aa0c7d89450799061561da65750e89ecab8f961e731023aef54ee37b94cfe4a9a24ea61e134834b44a2d97137d8f397f2775810b03d7d7dd17a2ce3130f63e5095d56ec159808925c1b6ec18735bdaf11767450bf8309a31841c8e7df292d29a336ca1337fc0fc199441c8e212ac775474923ae31bf263ddee1096850b48b41fde2e562bd175e640ddf8dd61a0908c60628495d375bc7290673d15150eda61a1c37585a9ab7d6fb7de2364297ac76a043d0482c776c3bf138cdbbfd94e2788452563eab6e3a98264c7066dc998d156bfaa6a759e528f24e9c5b1e69a6874ce0e89436ab8a581355d7b9df0c2191c4f90b33db4c480c22b6e883bd9f883f74bb1d6bc1ce232aa332bfe5271796acb4b732da5cbca793ec4f697a8fecdc0a8998b6f9e2ebc2576f82573f7ebe99d1bb25486e9daeab574838da4df1409dfd4b82a8fb6e0d37411056f2463f9fae6cb88a461b093c09f11a5f8b972256ea2b5321e7df8586a051126083b1f16017fe865113090591055107cba3f1f59a17a41af0213203339f30cdf14a7b9201a3d28a5a4133b12d52bcea7dd0626a4faaf06f9d0e8ae66debc3e822eefcc1bffa37ebc21429d3cbd127aa13a2c85ab959013a17b46c9c02bea59eafec983a777d171b14aef4961266e3e3ea01d434a7bf9167674562f45177ec044823d2deb354e0935396cb277e2e4e598e9eb839656313475357c326e3cf7c7c175ca7387c1663b6d2435617cf9f1fdde5582d0562587a7b17e532a3e6ae1210ca2c8a7143df7908b892cc41995af47f0f16375fac83c846d7d2a1b55b49b58109975e060a93b0fb7ebb7374f2583c6c8a55169c01c1da2819f9576353beeae6cbdf5c234317f92a5a1a13d591870e2bcb59a02a7321587d06f4b7e94ea17710c508d0e2294db08d24c44ea04315d30e41919bf301d05ad78a44f37f520a023e6fa4ff1ceefe5b7e17e7f349d5b338d9c869a3db6a57c6a5f8c30ea2a43c08993d24a661a8cb3aa4a6900cbb446d200165ccf44888311bb73299676d40ffa86b65cb75fe9351dad23c4a2a2a3499d5f5fb04a29912b917a95d436a03ba6b0e78e23f25fb2e44dd563e010b4ceb3320d02c869bb7928b75b559924cb3a0027600e39e725e5d6652ae4a10b5c390720290c3be69b829705fc0697876e0aed7c12440df0a5d92f090ea448f30f4b3c25a8a6740d1fb9926ce7a86333aa13dddd0c63c522404f1113222a6c03df9b4bf577e2481f3e57cf6b5c93ad62376f4f2fbaedb113b4e8dcdf842eaa77223fdafc819635ea9b07d0b6731ea1aebc1a0d7fd8c003f79b81a111a00b23c837ac83a2c80cd60e7f7cd3871ec585b491cffcbab567e803d2e053b950bd6fa0524076deba174b3d3d556b73f250baa88fe9b4cba1fcafa32ded3999e2e180ab0ddb47775c5495767ad0ca966f987d6a951e8638642eaad791532ef498cab7b49f52c2e3a752f826f4074946a13c141eb624bad6a7efb256ae9c11931a058615e2e48b5764cc4f176cd09178b2c0c93714510d394faac9069324903a3f8a3da686da5ef7ecbb082b78d147a8d34a4b8b4504ad63436f3f6951a4c81e4abed8ec88f2f7cd24379dde0553c6e2614c9852c0510777459b32ad4c1654657bf3e0dc3ae8534f7d2ac9b4a921a7619d871090d578b079df41ebffd002dc5864e055a4cd0237d0548dc34db63622e4b38968833e0619a1ac7e04c0a81a525ac2ddb83b0475520e4d7b7e1cfa8a56af146637d188a382de822954b9442b20bfba02a2510b4962a285c83f74619beeb7660046d37faffeb8ff5dfbe334789ba1c5e74c4a1f8432228b87c2545867366f2e3bd4f71fb727f1d5c334ee50019a5f6b23db4872b750bfecec14cbd1db54c0894562b469b7e24df74d6297ac44ec772460e1463c396545d14f455e4d6e7b9690df45af6aeec69865e6c7fd3a2927dc1e6185929260429402acd9970554129dd668ef99a4fda9e4a2dc54561a3aae9a76adff6e75a7ef67e4dd20ef10606f93d531ff97e7196d55b14fe6f3f8511a959d4215104dadc28b0c670f5ca3602d76eddf9678ab0ec49a32885f0cb32ec9203314bf6cb7ec677f22daf7297eb55ad1f4a93f18543aabd9356048383b53c7b479ac84cb3969affafe992142af7bc02d25b70313942b534f34d3a9413d0a56e5769fbddbabbfd3368fce3e622f04319051bee964e8411064e046342017e2d773d55288705105c434cc3fe5180e26c6038f3cbab4d6b5cbb14fae2025ebe4d1fe57b2da16edb95f388378a84963088f9e8e367daa6af649e8a8f32a542928ddb0c146c801bdef5a68ea8430547e2b6eb7e05ffa684ee8d77703eae1f118acc79979f362fbc5d35cf7572758bddd109bdc54797456780fc3fa99f69e88d279c6dbddf687a6ba8de17f5284f431756da33a43ac99582b4a186052500a266b6204552e9a85a0aa256bfea7ffbe30c36f7513b6ead6196a1c6fb18490fba168bffd3bfa2194ed2ece7f62b697fec3b03699383380a588cb268d74f9ed2dfaaaed2d0d73e418763293ed1fc6599b6631ea8c05e6ebbb86a2dc293bd79e524df7164046c7ae6050f5b710d541d276a0c412ff96098afa989dbf8547dec0a0d6844c67a2c682640547b5f6b03a2ff1be0a2645a8c51190594ef374062b1416abf5ac8defb9bffc7323dfb37c2cafca3cfdd22b7ae7c6e3c1aa65ea02e2e46a0deafa657d20dd2651aee8d65fcabb3f7c71278801ca14830b1380919e5c7392cd6d60c4f64e4c7b88eaef155704fc43425403ecd5ed921ee00b21618bfb8474becdaf300f0473e3f29138a74a8f5b345e210a6ec9387968da18c82b054a85ecba752e5125b90d42338b993d2d6c791b5f90f128b3cb14beb046482457d5b2ca9adeddf8765437387b5a4ab12fc294c70fd02991fb6f1ad2f48d34f66055feddd6403a3546ea25042e00fcbb636ec2e111ebc6428c1a640eccc771465a9267b1c242255bc8612e7d044ab1d1a8afad995ca448e877a940af92d0b049b375f3271d1c45d6d62c790c8866ace6fab331beee01fbe011bfd81a3356373d3d06714bd2545580b8f961c0f4e2aed518321d9352c88a7c06b311cdad176ecfc86fdeaefa10a1fc33c421f4fa88fff5f6dc0e43575151ae98f57424305cf3d91404d0378e8f8eb8f6a129da47bdda80dbf9ae7da66025750fb80cca751cb076f73e4c3ff97b58692b1b6b1bfa78cd89952a8a559ce958bad8a14d5aa71a4315e6643098ca8fd04fec649433d1bf52d011a319f888b83d28a48d5ae6f263402569fbc74bf30dc0d973c46c00f19f071afce7d553189f1c5d1d5a25b3cec6bd4026c2d1bfd936cd00ba1984eea7339936a8a96fb3603891099b4f31e629467909dfbe0525b96c60ad540e68d52ae7e2d6677b486a89cdb9244166d0d0fe58ee3c373254df345bc806f942e650ce08daa520ee5c8f021c6090d18a9f2048a171948ba470b8d445fa374ac0b515372d080b716d75fff57bffb55e049f63b367bfdd1decdb6e3ed35d5d917759ffe32a8ab21d53f89ed4d29614c65c8f6b2904b06e2f47e18b65cf7a886713162892485e76ec997750de1801a236fb31fd35510f1ced3d6e53a4d53c6793ef894736e2558f8ebcb2dd2b871c9dcef8b61485505e13e3a7529afeb8065311b27bc063f7880762f30a42b4651e31964100f9713d01e6698926840a35aab5a27d3d8f9681faebd159f0763bae66bfdd0d1d342f07e607bc0def5f5c323d59a75b26f00c62577b9c2bfb37eecb4da3ed01b30db67ee9c25bfece941eea29946f67e05c33b7a212bdf8b03674bb2e40dd71dc5d8e467de79f140dc6e50a4b4eaa8c83956e8ddea5713eebc9f309102f8577597867f71f6e35bd2a0a410ab11bbb097439bbe33dad00a91ddde19d0d261e0ebeb946584841c2c5c1870c9239e8099433b9420aec3cfd4901f10184e7c7cc1b5971b1307109b0e0f57ef521d0443ace3618431d85a25dd3a44e4c80617fe0fb7ce2e650f5ad805c1673a2c756f5a13453394d2aa939edd3b89e814366ae198d4e6fb50f375a4b6a0b5a8b282284f556576853b82d011d9da3ae292a42649dad9b0c4d670b2a26ea1a62a6c229b7b931b2c6e810c317f3a26f85ed8d2730d13506d2c50bce4372a0e6d1be274fefa31a9ab12eaf0a1aa33b633282d0064d2c63a0a9b13c4bd67b84142495ab4924af38cfb90e5ed5da5bb635e16d07139a8107c063fff71d1776a4a28d924824657c87647ec7c59d638b5c01abc550123fd42ecedee7ac1aa2ea9edfe126163aab129d240ccc3af43f17c281b0ce906ab173127ae34812adfc3e5da3a9a8652d6bed2dff5bd28b34cb3b577a46ceff3b46a5434e49e01a5514e390ac03838ac7ba560c513a8a8b44bf28a1988681318206412e5f34c2ad29088c1fc41d7ef85b77d6d6522407d188815762c4321d219e6cd833ceb5052db1939842813cca358533deeb574646a373f2413ac08a3175db6b78fff8e30b34785a9d189bc114a6ccfe213faa3ab43f28f0993f9fbb0f8085dfed5f18638c086ef88af6cb783168a06368bb2dff1b65c718c793d2a4ed6b49c8e57ac43ffba5aadc9d13a2972546c856622c08a7cf37c808f5703f46820237c92858f09e6464c5cc7e7d4ff4fc8dfb8785f2ea44291ff63975478b54292fb9b8ddee5a97f53fccd4f04ad17006219054c3a4ee0f68c59fc0d958190fcd50183874f698989713745684d5de654bcba5c5e9c71d8ebe0af1063b7be02d19768484ae76405c8639c16d679c6985185f4d1a228ccb1d960ac85530b7c8d806fe5e24d4952cd6ec116d717dba8a6400f8338c92a94d1e5a2b2c9056c92dd5808e301570f0463bd4e9c7bedec01803d7d1bae48960cc1ec3989bd81323981a56b74f08f0fc9e11b4a048e8e9118649628216b98401f6ea3715a7390eee87526a3a93873247612a745494353831d1f4b387b2112a757ccf4fe471a3ad2936989a594bea978f3eb337eb814f6f62cc1e47fcb3a416c9af8889c8526e53c284d72961455ba83897ce65437de1792d4f8a38337fcd7f5fdeb96cdf6ea8cf4d6068b1e80329f119c5e16ae39ea349c46a1fec0c3b32e6da1f240d2e93164f544c1f066c23276f1fca90e1a5490f21163e8282a2cbb0571313ea05a4ea483a222d2477d24e62e82de5a8760cdbdc38682ea888581d1d83f5045ae569c4d4f3b2d3e26f0eb89d6aa37bc14c407972bc81c94456d4c39da9315e8fd672195cae3712f9020fbdf39e310e4d1e3be25bd42e728f7ae9abbb31bac24071debf75d899525224953bc3927033a159a6c0475687e3dc348fd9efb59fbf8414e986def3f5af680c39cd195adbc9de074bab887ec47455b1904459a4264cc324dcd93bee1a6174ca7f42ba56b6590a43102c506456aec28b72cb3c4b4de358ed52de73ad6f628ca51546dfe427039c91ff06dd30413ab695886b11e9488fda48f61f4694c80c0e1cd0e4367e7fa193c252b2f1209d21ac8be810ac8fe75ae33a267e3bb9ff1f80830349dddfce057721471eeb0db3bf007c7f7115844118e1469df0a34d55ce885f1c7fcea77b78139ec78f05811d04eb8c35a703b6b0cedf80334c4849197996d5d9bfc05927db5c4407173af40ec73ac9bbf587f9ddbc9426d411d014b2d52737a4cd5c013f1c6dc9d328f5ce0c1b0fbe6db927f6a63ae43506b82cdb01303090f609484d80e83bd8d9dd41c647e48793f496291ce27c8a3cd7ed4e6520f24d2e7d2db303ce78c0d4ffab9c9e3a253a020baecf4ed4179963a1c01c2fb204f1be1a36d971ba855dcd26006aa723972df5a82e3e32cd22898fb73a8edecc421d159579166d0f0f4eaa21cf92b01566645642c376454713da82304150bdb86142ef0db3a11571fc535c748cbf383572d22aee0597edae5e70afb81578751246d379dd22bb50499dc9ed184bae628e21015672668867d84524d696d4ff7b3cb5d3726307a6adadea6d59e6ea200a1371bce3db7c7e23ff87fe630ccd92453c79ec6b3fccc6d81b22adbe30234e38b920fc9df118370ce44f61f6ab238c5402a0765229ba842e08508e335bf619b2b1a60dabaeeded3834cc8a3b00c003090a21dc8c59ed9137da84393dd6cbe8f0c5591df22ddcdab532da86af611ea3c2b2277e2bed2d0fa6729e49680e6978be3d90468baebfba4929bd190082f09b15fe39c9859e9a85760e8175b0906fd097b1ae3f143e0a0047a4d4b3f60be6c8d0247de4387c7a34b9148a70a4ca16642cfaff4d645d175c5c0c5c72b057e5ae8c5d692c39d8fb6396f89465eb166977d1b3b97cf1e8b5b751a723817508a4ca94190477d66ed9853775c3bd409c757a7cb40be69e543eda5f292d0adf844164821ea11ea69663726e8e0fc9778e731cf388b3c911d8e685c1b47fe172b365b01e796e35b55bc55dc65e10838e8b07151f0324c8d880c5c3c6c28008099f10130f1fe39eddd21740fed6ba683af9825b0f4f1e643262317137fb8a817dd1d6517042f0a88689cb42df10d06994b1ff62b065aa624221c42400c51518206f3d0573cc26948b31d1a8890a1107176488781880c5031456100f4731cc29429bab18135269b7a22ae4642731b070014087656d9af13a46d82f18b54ff7200b867d355941ac80639070f1f1302061e341c705f482f1e40e836cc2252b0e579662cdce96d8636fabc7c08c166f1ae1b0779eb299278ecad1777f32fd30536ac09246cdb93b1bcc7246ba4cf86efe6890dcf6646a3981f6377961f782e18b85d25701ef79b074a534beb928758ccb086050ff2147dad1e638b06f5f9b51363252a23dfde56270b58bdd5e87775944eaacbd3a2f70a04969a9fc1baf10bc7c801529672fa8307c121e84b1d132980be1084cd913ff7fc4dc5b3c8d0dead00a0cb0b479b199cbb60f51304c18db48429ab7473ac2af0f74fd96d113e7afff5e03af17b200c69ff1879cb0a335deb6c7bcf3dc62e8c29ed3126d0d6466861e416720a046e2af0563313888b106106a9d3e9213830386a364ab3942ad4e53f18d318be78ec79495783e8ceee612d7d84ac88255d874580003855862186200b30b8e3d9d4812fbe182279ed07980a358968b96df701911860213412a8fd963888a1575189587feac41dc9ad452b8cdc81c1b1256c30c34a31f5d430e77eac77e5c0d4da773428ea692b668cc41e2d7bf0196013a4098a6dc604ec7d020fa854a0fd4734b47fc79652d599327fc7f2c17c3d5c2351971bc09161391278c394ac46c9697a3f9709a26971daf97699cc660ae63e29fa08b65f6328953a849a578d900c60d407b7ff9cd39cfd924326632914d3656b50349eca9aa2d694bc4f64069e8188ed03e288d2eb9a0c5838a83f32c8d969ce39621b2be3d6e1676390e3f62f268df56e07bc26f586d47a08e69fb0b82179f34ca701fd4a6957148de55be15d22e20ad419bc1e50cce5863ef08ecaeeb77ca9bd464dfa2411ff3dae5f13478c528b52bad125e1c0fdf5aa63b61c9fe2a1ec4fc541302e6ba24619222d1625801435210da9aa550ec6be3228d5b6830e7e29a89f115afa32a5d4bd7aa961e9648bf7656c9da38f665debbf6f79b4ee170254382172f6a50b3894b89355b6069ead61ff6e0d7be2d64e4ca9ece166d83b6d124691d77cb1b97551cdb0092524bc02c73cf5a5f04eedc94fb6d216d5cc8b79acbb5de5f20eaae61d232906c3b9aa85564478d2d57d510682e39607c8c3e38c67193ac24db8996ca22f527a3a2743785654836924fc2a5cfcf72ea2b39673fb865e57580ad94607ab6012f02930ddd3ef1918859f6617159630a57e87c275833b62542f4dd2dd886dd780cb02747f6249c4fa220397d9ed041b7f936e48e6f65c592250983c0943c49a92992a970d6ffe54c28502753d2b9b9ce7921f84813033f8a44aa8c93c9e3e46382359b357c88f467d19c19d91f9aa50335cd4d2fd1e8996d622645228ee9cafc989ffdb219aaf4b48d9c2501d9622cd892855db3fc5cfad828bf705ff489e29ba64b2e35c91be51e8ccda35da0b53e63dc36481d3f264717a48e0d762d72b59013648d7e0e2b67735bbba8951fe32b23bd57bf4f960baa162125362153e50c8424395882241baec97c28546d40bad623c1d0ec23022d412e01f78d6644c40ad8106a72a74c4943496323f39229ccb76f8b30eb8ccb40606fabd15dedb5dbe179c3fb9944042e7ac90212efdba3b529cbcaa1b6ce73332925ef99f44b1b686795f771d93af261814b045e091bbc7a29125218037f4369374bdf516cf24c0c9bd391374a82c9ed7856d9f431da20126e7169b0dd38f8dfaf3fb89345a3c0b8f8030c99cee804f395700a3f85bad18abd742092cae567086ece37410d59e204cb492d27884e32faa0ce7b0859a5b6f28927d3d16f9f4f2fa0b119ff6cbd520f307f09c604db810f2b5bb0544dd0523da3f477f4d490b9ed4f85648bf6939572f9eddfcf1e41daf0b4d752b4f5dc92d91112be2a237374c438f7d1f4bf16173e1c6a1cd73d5c31426fce4e652056ce06d2d597b0d6259f2c8c498daf45c2fe4a634b42d0614ad0739812e4dcbee4a9a3e330edc8384c2aa8387cef7272490ede43c0a555741bca6d955aa5f83e8a689f14ce92af023a71225fb4c92e2de75ae270bdbc94d2e334ef682bca7a37f4093de812426f41f17d6b4d56f20eba9dbc83eecf18e2c41dfe58496ec9057b64dc56fb6c105ce24d5b56d590a95f3d4ce2ded1113487834e5bf38ead67a18e99c2a33081f5c00b13c1f36eb29de997fe802b742aa4a9c78a018dfa27dfc49045e50b229a32849f30a664bd4aa7c493356abac1b958847552bb6dd365cdcaa0ca5dcc7f289541edda48e66b4472b9b3798d12c701b52bc7d12ed5e3c4d365d7e580bb0535215dcb4ba5148eccc7d33e6d8b1cae6638f0c17c9adaf29b2229c9c1b73937f0c09a96cdd5bd2b5f80892481072637c84279f9340b559f3a6478a0665c1ce890bddcf61aea09462e77a097d4a83a14cfa9734c334f5989c369cfc5288f6f7171e7dbbd076d46f432a68e594dd1fa40db70de048a349e4d9f18ae8b4bf3ed9d26c753a12c30cae8b9c45f7c4470ec9d4b256e29a0bf9ebd5618ffffc45734194761e0817b199e89bec6c9cca8dd907c822c19281bb085d43574356aa10881596946ce81f9fc68a6727be1a5bf47714b94718f94539536227d29a464153a0d83eff4e35f2d5700cecd5fe7133e53f252f7327fac5586475da3d22a5a8b6688fa434bad3de18fb527c83850011542a06c814edb21c630619310073f87cb05a3d2e94310e715108c002651bd17e0aece742ba8d998540433c3f42c40c7a3c9c201812fe5962f113b58e0b593dc6c692f1ba64b35b17c3e42a850117a3f607d4e306706f5fb20e0f08e6921074447817ad5f1d0359e7ebe7ca5b16c06e755df10f5e7ae89ba35d97041e1a8a72e8f65f69ebc9d6f80218958d43b8dac5903601c9be0980f9ffbcc8e41035bde6521066b36aebf0a0021232bbb36e47024745ae6172464d045794f6077707189243cb19fca23d677edd50030a5f8b20b45f3546072b2c0d267fc6467a497a4f426f59a6fcd245c50f49294f0266de869a625a6e9090e98142139fc70aa4168ae5c194c62577960744346ffeb6d3eb911495c840d5d2b37d8364523ad6f91db6df7ff430fb0873a3872178118794dfd8080084b5bb9f1d197367938cc3454aea89ee0136f51088ec2d3395247d1a28dec713ec25b92c53da2752dce26b989df4833623eb941be9f7c378d2c2bd9da0fd5bc08416a64df22797c2e2c10d7d9c20235d8dab74308be3405cd7219b45652e2846f3442ed236a911a4108299b0e3f129165f85ede0ee2250a6ed8dd81ee3daf6ddafcf97a9e0bbae78e2d024a0c32c9e0787ed6222065d7eb44db778ce07e7a872c879c559dcf900b4128189b075cff8a98d02f7a5aceba7de347367223602982315b8714a10349ec43d34214e4586df595871378d8860ae722e4b934c472163475c24a5b8684a066bb153441a49894d2e28852124a53788a49274d10808c2453aa6edeafe5639fbd7306351f74a939d26b00a21e2e640579d949dbdbdcc85fe4bc510bbbf1da871e65a93bb5fb86b1db2bb0432a24815fbeae3de709c329d14b2ab613e5afa0cbe7d27532bb1e5cea31b22a3a55c60337a6a039880467e7f1ac061462d606d488cd3d88a40e9b6c331c26834408851474c0830e38004a32da920e6f495f9fa992b588d4cbbc54cfda5b5cab9da4dd77efe03eaa7ecc2b64743997bf23edd937684b0fd7549f694b740de5515d12cb67ad457f05144a1e8693a31f2e10110bf1c1645f7883f0fcb8daa3e38008682b5476d20460aa4c798872d44b1bb428ef3cb93fce389202d2b3b664db1c6ef07416a4adbe05115ca33e5467658b40c88e58c4a1b7387d5e1795b69e67eef42a71ed9d06074b037ecf4699ae0d62cfa0d13c4ee0c6894461408405820d7c47264c1022bab951c2d1a8a3e80c7d87b07342e43b8d4b8bd13558d5ef8e0d19eb7e2b497c3b878e7a40b076b68b2168e4e9ea16b4a7a467db3e0e1a0e0fac4daad4bcc2b7a8f65c72f1fa8464e9d963a921669792b104b78ed2150788b0c5d2492df19552a5056078ab78250320db66f1beebed029feb65cbdbbe3369c5acc3f0ecdc58eb296e01c811d7b528d27a078b6489282d5c2d547ab4614d42e4085395bd8c39076b79b3975b731be57fb6fccfaafc1bb124a107d20274892a8dcda72a72031410c7654412c99023322a8d45fe3dc36f86c5f9c62f7119ab526c93087650604650c46b54b438013d8212a79c004e45badd2015e11d211f07859a935a35b543d0231fd00f77081764be0f3a880b1384c05f9dcda2e14e2866e8c2215e41db9f7dd5d51aa674db1178c6c2a9ce51a24baf751897a69213b55bfc1e2a26f0ca3298972ae1a7f2ae7c5ab743f01061c5c9e1c273729d58a95d4fc55a6869e875b371c2ae3fb647d61647e7e86911c488b810ca21f09c4f44999651f584a4d19c3063c85c40b57cf84c825c69b3d92d6fd294972cde3512ed6867e5e6dc8e82cb10f92a54155faf4140eb6a05b17ee96518c469176b8903cfed5cc84c422e177f5cfac2442e0e39dfbf8947da84de837e359ada93beff09fc3f3a38264e6cb9b84794af91e1e4c3340a90059e31fdfce7219d71c36d1e0c58c93d31ec49e9aeacb0b0886485c3fa757e2229921565facb317121c9990f2f44346d6ffb68a1cf56214c582f4c34d422a9783d623adbe7675ad8a6b55615a47b6976e9978ea56cdaaf4aeb50a489f2221c41e0e47f144aa981d4460d541fcbe6acfdef02210d8f3ab4e7b23b52a564a0a74af35baab19d2072213d839b099232536a3f5a84f6adc5134aa8456a255ae470b9bc01bf479396287cb24d2943a5c33d4dcc03d3fb8526de898f59928734c1facd77671346d1f9a6a80c815846d19966e26e89c5e78086d244686d8874101244e9720121d0b304e99622f9081536e6ddf0b3fd25bd2dbb8673c835cc065576972820fd69642c5ffd0ee13135f619945c833f63a822181202bd6f2d4ef04133016f41469caa8f38e41c88e1eb929c0e4adda605493b4d7767ad5001bfbef4e0b5f1daebc12c5a350aca899730bb6866db168d16d44e7250493c10810b681f4767a373f5c17e00419c552f0b1b3210822817e62f3c83fe7fa7812478283ebfc46e1d26a925b145934e022528bbe9427e5020736a172ce921bb36928dc3f69ca4b13bf2dab178190df4f8aa55a2a2841c97b92d41f0e42a4d3f59a658f553d2d0b5d24effc7d2a291ab9fb4654a47545149de739334e229c83b13881744252ec023a2480dd4e76a8cc3db3a92fe4d2a8cc00632751996118826c88d439c96af2b8dde15bd21ce035f84a2c152e55bf228e5fc8adf1fac4345815cf9d4940815de39b466a26557a215b58fa80cb8b2a920b1b24039c63e0b3244d929a6cc16c4ae3a4e9a5324453309242bccab5d2c2c84e4e7a927e869d41b5c6623a0f860a942b822c5fa43aac93892618210f59d5058ac88621279584bd26aa72b36391467f18ce2f6f28cdd0032ddb1f4bb3a5d7cff83cdfe45826b0fa69e6773c82ad158cf1fb529097a9a9fa5e2a75230d8ccab65a9228c478bd82e6f761c658f33f38c712c463c953dd4ef29a53c84b19f062e03e6b385d4739f16cc4c11460c29534ab1b56442a000cb534b47838d2efdb618428ac30c47010bd0aceb729501224cd325904b2560e90304a6552ac28f6645208b3240f3491d544240e1b5123b131b0f32363e1e362e0e3413581c0f086d30405ca7e37955b3e93f497334edf48b9f02f6334fd46a88af64b3606ce272d54dfff8ac23b616c911a5abc60d7d1557c45670f791ce56e8acd672df4ec30c53974fafd41ac48e82ac7d9753af749e1aa351f29bc8fb6561834a3fbb0593fb3b2b2bcf1fb2dc5f27ed92f8f3f63c0a75d8590a26a1a82c954d678fd857901b9fdf7b65e28e9b196548353375cc4e9fd1a34778996396bcbefc8de6ebf95c30879732c60645074729373c9d05ecf9f1af1a5522b791c469167af0aa071de58b23303e1e744288503131a0e2e1814408a843e26176fdd6229ecf110dd14085081d3a1eb6239a458f619dbe8fccb1bd6357656827fd645435403b43c5b3517d84f54401e2d9b847461de0d11cb952fae725dfcd99695bdf48ff61cf11cb141b706388cc4a743c920a20c6cf80ccc6cfe0df54dad15a72fab35380e5dad1fc59c22b199076f0b20b68785883d811db5b4454441e6cd207b3597c62a33243608555fa82f35293c5412b6fc1e8e0c9892608d30b4e48bf3866fda71ff2611339f9d25ba4941f7d811e93abc20c2fddc050651c1de7c13c2db859b6b7d05aae174b7ba352023b30180e9989cbda0d4b7228faa8a260982f78d9458dfa60772ac2c3c6868c5d3e0921a9d833ca68a3b0bc698276897c60f929eb921b37abfbc250fea74b781c7aa5801ac0c6d100e07754c322c0c321c4c6856c62e161030697000f3e470ca043ad8559a12f66f96702e50a2e2813cfa2330695a3a0af16e3555df9a8b0122d0114221515c598d8355c5ce2f9110eedbcd3b696577ea23fe6eaa5659867ca75e1518ed46a9385a3b771f3e08783905a970a1db97d3553f0b5bc4e9b235097a40506758d82ed989e950bd6dfb8bed2b5082bf8ef9b03e09ff590115cfca84e37323be4d4cbd6f3024c5c20d3479b790d76099cac3f6f2cf4ecf1b86ab93e0a4b07ccc413745cce6c34413ceab6da05def99d3015d453ff41ebd620d335faa3e707b6e5d2a604408ad91b8fc63e2da7a81ac5c2b6ac3b9130fbe891326b44669f2aed7f504029a5524aa367cd619970a79468d7ca4a923ce8a517de1f30b0a2faa0a4aa77746cf630d81e3b3d053e45ad1299d533aaa2210efe5d4175c71feb1ab80185ba6228e82b777dcea351cd4c492c1a3a729c4242d4780798a81fb8c55590c6e64020447523b977213b9a906e72436a32e9acae8eea6b292de8685bf68eaa6157e4330f7e6bbdd4aa365e5f9da85bc4d41e89b95f5a8b695f85a7b00dfd742f185138649d07614d2345bdafc9674a02be516ea61382bea0af2a571fc668a5fce39efa32fe2a842aeb8edc552dd60ace861e0fd3dcce64ac7adf831017e0cc21ec51e22bf01d0d7aa2908332844c3a318674265e87d8ceb4d5c189f12ad409b04d771a7022fa8f5d1df710192a2774856348f56ffc64ed91ea48ed5c0d6dfd601556411388f7362043c4c3065452260cf20323abde03d2d3810a6ed0d6a33c282fe6a8c5629ed15dc6f5693691a0e06112e213621226610a1c12326209863e2ecf56df6fa256f519565b7fd1a0b39794e046553a207bf8467273076a5dddc15d90c021e28ea7a0f8dfc9203a00a0212ac9486edc1830b5aa013cd3c06356ccba8450d5a05b4ad4c5b4212c9ad2049b06c976881c5d376ec3986d5c1a6f69ea6800842f90bfc87fe6add0214442a3554de9f8fc9f0f2d978bc0028b4bb4c82426ad796824acb1d11f1181851844b2f31e9d9fead112b8851c7b83ee51929b628bc40a3392c045c60840cc653b2cde6cad152354b97de6300188761ea083067c7db4bfbdea55ac9587c8c13408aada835a513115f697d6e40a64b17cc8b1ab0641c8940435b876057815cae3bb940453a9f3479828086c862b25f867a73f93284684b07a7a124bd9cd6e478470cd5d40fb61a1bfcd78b80370c20adc74e8f9a640893ccc0a4af4dd686487aeca9c60f3388080ca5e1bc843225082c59300fc55b626dbc243424da6859b6cc30abc126ce5e2d47a58801f3170921251fe61866bbbd80a2acc35c23fb693526fcfeb0dfe9793d9b7a57bd3de91645cfe773dbbdf80c9d43177f4ad15f93705f86f73eff1eeb0ea565c945b4a2e9bdd9c82a59c3cdec8686b8e88187c958bce502e04bcd6908f2203afa07f97651d806b937f5bbe80dac45b2cd4c0a2d1098b91cac41293ad4d595742d7e8643639fd5c0e58e55f497750f8dde847fec7dadf131d790ad4d8059279cbd79e6d70aeb2f93ecfb9f4f0a7fe37a95fd4d780de043045c583a9a8829e7ec0c682436d170778a44d3cdb60a737db69b08afb92e02edd2b3450a6a2bd754cd9d340f61669d3306597f2b786a803a7e8242c0b9d1d04f4163906caedc96040f49be2470827df7a6eb13d7b2866d934e82db19b62101669e21e64ed876cc424309914aa7860f5a0418290c1345635bd941c211abba9b47060bde12e574812e64e2b9f48593acdd652b39e864d48560a404a95aab3a8d591d7ae168b5128494eed46c21c68a173d1088331b043170ee31295de788ec50f0bb283140c784841d5c07a3b164f7efe5afec09fae53626d14e1b968b6c52ca00e7a83d0190269d146744f043d1a951181637d6248bb679c4643d58295075d1010f8dee2fc97193793ebd6710b0b7a407d202bd5ebddd7dae2f196f9b1861a40ccc95e64cb4f302a4e3c6f15fb66c74c283c44a600496b9aba912a9ed63ecf4d841d5cc463bf11c9de58c8611a2b729abad0bfd368c15956b174c2baa12da33522be031c7e40f60638d2153f5f2ff01236b3301159e1f04554972ca574632595054c7ee1c61fc39c92857d82b165bd0b7129ea17ae8d1a0eae74b79a6e6ee0e60e1ef5f50a93c6c2e031665b3b4d6cafbde6477695d42cee9aead975db474905a51b7517944d543f8c21fccbe8272e130dbbdfc4a7072daa97685590d0a5b61711b48ab2d594e8e9ebb26abf51aa20b45e1f314887c4dad8842aeb4a6c1b2a9bfd09b64f65af51e22e2364fd12e2675f3f48837e0e285ba02543c52f7421a1a3c90c9e46f0b121b4c0cd0c121e529b509f87a11181b61a5c22ff5acc08c5d52441d6ab31566954e82a6f91e8035f534db290fb50500d13ada2d9d4463f05b3b9bbe56e5067ed6f49b7277daf808b5f182c6c7c53f1bbc191787bf2a083b9443643a6bee1ac5cdb165f28083b46299f219f9d205e30ca90f3222a561014b9fd61e4979646371eecf139ff0e9e90a7ded29b5c9de11737b6ccea2cb44e2422f2c6c217784ff0243598ea19ee118bd94de632f441e852155f23c75202841f7baabc065f572cd245dfed85f09d811dd70636354c73ffa64de67b935a0e8f237a38a5537d0a2a116ca1d0fbb1420e7b361d8861ecc0bff03509fd33c7e647e44f9edc93cbb1fa4fe4e6e776a41575f60fff41298417450f4f68985cb1054ceedacacb6e80c41a1c915e4ce1df8156bb7a8685625ce230d143339a1e1174b4dfaef32845226d1de4ef1cd14101b525f3ceecd0df823d8d25c33e8976c0dcdf0a89f4a6c4547953efcfe944adcf745f7b9a2efd1396a6f67ddfa3a23d230be149dd85cb8bbc4211919c6738e5f5bd05e7a3b9c2ba77ec6e5a7cfbb622b31bd3ee9d497343fe4e418f4532cfdad31018515d4e0906abe61530945a74c832c4a7668d748c98443d73d68988d8a31e7bac8fc10d2adb56ae1ce1981a7126ea88315e6f2669411dc9c72bdf22c9610a804eebe4ce1c5305890fcd9ce9328b26cd300e22b087620048932d3d3eb00a37e097f30b35d37c4734a092aa03f6c238e1e4f2543d2426beb45de3bc133bab28eeaf5b6b88d56b66bb3698b7d13fa9e900e8f6d85492147feea0ac6b3637416e5628edb34baa8ca3308829a8dac66347ed5bed7990954bbdf31c0349e86106e3840552acb6ae6a86f4609a209d678e24740d27d8f65c0374a582a24d196514b2cbbb071be607cae8dcf78769cba8fa952701986967af0e895e1d6283c2b183159e85e482e7c2091ceec0d1c06a1cea1dde14765d41238f4a4764049dbb41f887088c10170a5402ecd8e4b1f0b07101040f3fa2e1413a1b9ff2cfa94163c4ba9e487871ef07ea4136027238a610b43895255f6638b6cc8f834b4afd00b0d101b10837e5d62aeb30dbede9598739b3a615b59c266f8d2281e4c653e0bdd2c0b8c85c48ccb0775a8487458ff5ab0c97f934fe668739f945f1827de7754639103f84df816f7977dee8acfa69972fa8e87e1f56a7f7cb93fd8ae662f9b1770abaff4a368f9103b877446fd198857328df160fbfcae56d10eb91bcd31534ba7a09ab4e56c77a4d1ecd584a0b4083ecf1aa85b92ea754fa6357ae0c26709c28c4e386c420f107658ac744a3a12cf96b5b877d1f91c020e6b2184206f965187038572b7e44b074387b512ee2f53be36eab91b4d91862ef45049921b7a6913059ce95907c33eaa15a6be7e65ba76fb6a2a211d314e263cc197add0c86473507918f8a19f424e4c80fe3a0f802e5aaae5f577533beb5addae54cb6b0790a19396e2708426670a7089e306ca2a47369abb33de567667057b47042023bea35d64a6efa7eab7d79cdd6db4b0370fb99565176773ccd29045ef2835ffee4d7139b83123e7d0b5750ecf7852b60c9888ca8a1fddd9a6f4a301d7609e3c7b2f76ccd2f8a99aed1d3cdf21bed66f657b0be297be16691dbb29134162ab024fc3de5e45e703ee5f30bb3b1e0f61a6f3e2c6dd056a4456a6425e8a18ffc51f6cdeefc5d6933d3cc69719bfc50ce98bf72366ea88c8f194d0a66ad404701134388bd0e45770ea22efdefb6d0d41f4a29916281f0792214bed356e5eeaafc84d127aa0ac5e3cd8b3679d42394d03790ad58a576342e0b3c96e28269714256f6fae86a872febf07dc75b30827f396cb9f3a6997baa43fab0552d517c8d1225023df210a072c16b0cb86bddd169ecde1db85c9c499fb3bda647ec58273b616d0e585164d2cca5a37219dbf7c17fe6fe668dcdd74379cf24ba802af3c32f8d13710192e29e6da4faa1943683b8f78de0f1789b692db73bb99f34af579221747af18d96d45a591eb6191d7c2646bb447d3ea25baeb28eb06ecd97a582d7aa0de08f7b7539af530f974ee52fa78829c3255f789c223c8ea823ea1262981bd00a14eb29217ffdab0e85379f9cc0234344ee3e651f745e4f64042b8ba40f41e27692d2f8cf89825769eff6c85635defad5c566f1b8983c1f82f4a99a2ca4f2a73dbeae3155dafe662f13adcd8ff5597ef525138921b3cada072c4d49f7289df86d546346fac59cd9b1553a076027d382493d93cde7ad73c953961ac5bc5cb5748a761956b652527dcb3f30e671e23aec99393839f4d990d4c689e1a159ec822ec8e6eb26551dfaf238511a191b036835d94a36eb1530d678e803f80c8301ddfe7dfbb929a2124478a629ac5f4a97d7b4c645d8c457d3972e9ec3bc160b8f59f1724ad8b7bf776e7d072d2f63ebd266fabad3423e082d8e4a33dc336dee89f92ce2b8738b12314841dd2431dc16165158edacab8c2a619a4022f7f1b6468207a69f7ca6f338ac9b2d6fcb5045674268abb52417476007a141f2d003034978b71d213006899ff84c7121180effda69d708fdc6b95fc4be298f7c26f46db7477a7f189ba931653f7c3e56a1c36db037c74d9649492c8b48d7a60cf6e318b7ff09a7671eeea8628e82fde4b94b2b3d992b9f93148902ddee97126f68e732808417f410b47e9ec93a83fa97a3fca396cfb1e588950696a36d5ef24f5a74e57f933f5d9709f0c5717fa30e1a86bfc508ecf22176a7a92242247cc10e70285bd026f2177478f267ce21363c0ba539e8e269b049da889805eec0d9080a443f4bf841d808e302a7525239c1f4c7cf856b98388bc2d118990e9c1aa9b8905f75d974ec3bc230ec17f7c60e159023e35bbd75175de35859e88d02d22050651dbca6a14d8772e929106b941c22ba0fe737a2c3e9487b791ca70d28daa7dfad199aacf7d7671c483bde360ce01df5bf6d0ecc0f4dc89e6076f4cc48ec3c0f2314d5f0f3f5ffa2e9e0a116013202b11f32f7129f678c172b541697a3415058ec43f47c484e95996b26f96cb431aa88b7ef9fd0182f228d89a6d0ff74efa1dbad6e4e44ff63aa2cf57ca537fb1921be4a3636b81bbbe3d9457ba1a31ecdfb7f8dd9437b413fd6df7ece6b55ffd0f4915fbdc850efe67e6263530f771935d13506f5b7c7bcaec8fcea7aaa2c7fe90210233a863f53dea86d95ec7c4bb9fb9618459370cec7f5080b4f8a133a8cd598cf4d8bc385435e335adaa92388d70bd2dfec2b6c72c2260ae336db29deda992a87ae104fa24bb0920f6024883fb0afba13cd03f21ed8c9fcf21a9f20a99eeca9a7f4abe8a9386fe45e72a9b02187147401534c719b347555ec98a1071d5073c536a9d23d6d0645cba596ec337936896116729acdb4ded6db01907cc126e7c02d79e7de844f28d97cc85f20abebdffc0fd1ef665f7e838fcdb4333154b48f1b3d417ddf1c27e9f95f117ef666e14f6ac4643c63b9df67343c81070126c4882fbac8ee01ca3c3ee89a5e443a8d2235ea2e94706af5be0d9a532eb86cb37d73d3657fdaac40a2b78fbac63b7f80c670f4072d9d0b9868ab83723bb7872f771751edc3073be4c29d691f1f0ecf6e1f8d9079e00ca94163e228c2c94fa747ab68eda1404a5aae5f02ed28ef0c05a7440169f63200da116c81854841022d29c683cf5bd12d40b2b743026e47db0ae38e258ee58616c5028748f1ac72231c7646680816b0c05bd5382868e407855bb68d084f7878cafa9af5a11c46263f9abcdea463da79e497195c341942cf87e54f35f13e2065157d124cb39411aae531e4ac61bc4a1bf87d476de89f2239ddcec0c9c302ee960c9680099c6eece74efc4441183259606f4aa7ebb4587d34b27b870cb5356281f9bed14ce6f8969c8fe7d40857aabd8f80ec0727e47d74709bb3c758cc2e9d77ec2b4a7917e235dc916d1aefcad566f2ef74e147326e34f16dfa8d5b8563e09430a3b1a53b5ab6f043869e9f83b8b175ea9687d532dac5dff53363ffe0ba810bfac6232989f86c953c7361b53d7419526064601a940867f17c39254a31a71754ed12640ae61a9e08be6ab3351ed5d8f83ed9c2f674db11be874d68e0fed57fa8cde378b265cca65e16e4a22243603d3c6e2c7ee44db0f9904be04b72c193eaadbab4b9241192b3ec65131e7ea3c19f7e7ce91bf96375299cd8bc6523f93a1254d190477c231959088fbd169a480322262918b28fa12ed93a01933c4ab1c95c24763a5bc5c03832b816449a72218f5c237cc1f2cc59b95f1b2f6f7a6c1be0b8bb901fd8f13eaefb35209f2806d322e4683af2459980912b0502d2332453338f359ff72e93a930bc2361a3b9ded2438a015c1b366e80cb3ad291406df6cba79d835d8731344e6c137ad430925ba15419612a3b161f5081e7990d81424dabe9a64c9bab7908acbb7d3e539250ad95f31a112fdc75034c23c24183bc742a86ba9822b367fd83bc0d06832ee8a0d4aa685b0cf749a9b635685a0e7792518714f24ee143b00afa032d7c1e859084840e7cd3c32e24a7d960fd3110a3e7cb83bfe5705b40d69ca033b287369649cce73848518d3a2a72daa2e84616615a195989de6972c2f18b2638606c5fdd6243b755baae28a9d6c1438e6ac3fc926a0d1c8a2a35b27443af815507a0f0fcc7ba26548e171f7d03fbcbac552558f87fc604511754f6ed5c05b10e524aac9b65fc036ede9f5beaff002e9693db7fd743088c90d0375d644c2eda8e38004f2e3aed40ca9e611e8e3f20e9fd14b2c988f52daaa4d140849e8f317eb90ac58fbcb2cb48ce4eae2ee82cc6f9acf4e5211a5dc18c284b943174dce7308c17145b0d8f87588b7f0e45873fd4055821ef0108ac10feb60f0fc4d3cc03fcce95f02765dee47e8522b44c11ea4210c1f9ecd0eb800dec680156a84784064b63a0d32044e01e302ed802d8eafc5c4e0484a982d5d811b808243302f6386004740ba908c821015f752a6d3319280f31f502771118b8b084e54d4ab9278b8b6274ac208ef183282aa040b530ac86292e90d303702f1463371317c8e8005542943e81e18e57b7ccada7f2d8be3662eb718703cd7babf0c3d0c4bf08ffa5fd79b983f1713b87ec96509e1038026c1c6132abc1563573e27e67a48d1ed4f7742eaeddfe85fa6e51379ec0091bee6e3e4cf2949a037c8ede3fde98125e62879ae50f89f7a70bbf643d8308c83e79e6772191ad5039a01ac1b3dec71ca878e19f257efd7712c0c77d5c1d8780035ebf73b5d4d1e4528b6d71d63f4b0cc915f1548bf86364c1c194fdf2e294c8c7b979b1bf0fbc794ef410f56b9af7b4ef67f03ae5f017542ecac5fbf6ceb9e86b4dbd1bc2ada4aefabf1c46d75b094c6d8356a352f96f7f546dbe8e30087081c7c3dfab26cf4056b0bd7df659b11a959f945d72cccab339d176159da1d0afebbba0244d70a8f5c98cc3e580bfac4fa5bd94d25689a945135576324b94ff475fe6fd0512b97c4f657c00a76e6de2e293c5ef23a5c5ebe6c38bcecdcefbc988ca21559ce11d9b3ccf99d644a86d67fc507d96292fdfaeae27c54a71b8939d7de1ff705e35a5473a69bbb40f648569faaa4a998dd88d1e0da03501bd81636640894ff682667eb4056ffd5b34fe87cd1dfcb266c1be2764f3218c44f2a621e9a66f7227377f0208c9b99b10b5877fe8afbd40eb0c8f096492d68daded6cdeb2d11b66b844099785ca459177e9647f2c1fe7dfd87f88ef0b5cdee7dfc18051dc0a5ae699bd3ed2a762dc625250589e55a4f05f76d214eb7075bd2c49c76b24a060a373d9e390647ca0dcfb1bc88ead21d18eee7a6bd7f68f358919aece5018e68d41149e74bfb7dafdcaedb47b7b81604da5e7b5e981eaae8239f8bcf1c9b0f7d14ece293c193cc9c52bf84c5d5d391a16af851e8037ba80a7a0aa730b691f617b77f589a57173756e214fad0f4d37e2dad7c96409cac90ac3caaf46bacf943516b841ad2db484e93633a39b0e1972b93d93271fad5de51e1ccc232543281a31c4b84c64849c8672c5f7252d0e3401b2eca0b3580aeaeef51e55385be2c0c70296216b87269149782a23a04434f63b530996d80b6c520f0bb6b4ead009000ce22eede0e240c122c081890705224c68d0a143c6c1c502508878f8b858b8d07048c45c37c925bb427806096c4921becb023ce1f2f7f1bd2c050db96248c6cd9d816eb41b136c2fee233667e89c2226214d6c2ab9697356f65d65cc9dec61c713644153deeaf007f3bfd9db503624ea6befd86e19f0695de4b5812a983340f2b82c2f1cf4153439f9bc636a5fb6b3a968ac73549dd1e1e21f3aa1f57d46ce58ba2f96a65e62539fa3aa7bd28df02f79e9d580aa9ab7ebeb3960043099c9433df1bfca4135fa89b7b47e98e3f2c2ca8999f1ce24e712ad5d19cd2d435e07ca6dabad92f079c656e33622940277e88b5785882852423c6c2c3d301b3e6c213cd377a4462e0a254d943934f6be6ebe3fcc1d2f7b2f70c1dcf89358878ffd48100df53a404157daead6f57eb53dac559cc6d94a784c46d6df7408dd29b53cdb3d0ac061a72340874d3453b62d2267dd83bfd7a0b36e7e21b8b71a13a139e5f7fe3faaf761f6c296e09488caa6327a224f3d87593494b57fa1cdd1147dae5a5e18a36a39909d49f64f8d513f543036b72242149a8001c080bf921019ab3498c1926cdea2f10c798cea1991c8c090eb5d90370b041e13f6b891fda2ce1263067b8bbec40121c45d6d2b382e66157bb29d11b27ba8849b94cf01b56630a5d1752b4ccbecd9057b0c56951e181cd57b372759720a6ab9e55f2449fa3e63ca00ce077c0442c65f39833c636633acabbd79a80b5b3f39722c3f1dbc29ce0a089f2337ee8297a073542b4f2b20721d36b75f107631464f22b28c523d8aa8056d68bed513b8cd421531048074a43bb6d537072b0dc27cbd60a0e7aa3cbc49e7d1e8285f0dab3468f37913981da627b3d54ad7983450e7980d739082521deebe0783e07fe4ec7c6bd682b0853f0e1a3a93e02638d2555b212912355b9d2b0bb5689e14bf06ee57e278c1863da9bd8ae6fa84ba2fcea4790dc99b755adb689bef395f4378ba10e2039e957693d1c00afdd299bb0954c19c59f77f4849259720bcb7668f70d4c6ed4df04e9daa85e5d543719d45b0a75267845b69fc0e6fcfb9931bfc9cea74b1132714d74a8d8e79a64da742961e49e5d5288b9fb5083c77b41662758f1e912de746b2ea5100d0d0d65bab41340aee572b3f87478b18243b8c175c66639cfed84590b199435d6056a4eb744295877a7cb73e5653651f52e4eebafc16a02b4bd799071eef6032ab11114f6aa5de8653ee40e5de136c648cb57e534f09b0ba714bdf48325713f96f89e799f24499db4fa0bf87187f59cf32b112151538421c60925a830c8a8df53fb178c16bbb4991a490605ecdfd18f6ab351c6616cc2f6f6dbe28105fe062c11155e580ff85e343fad17418045804c02313091dd918c79f5431e90a97cde1ca34b375716ecf36d22f067d4fbaa7a673869e617935653075947347b55f51af193f3da2ececb82fa35276bfa0f2337187791e8522eeb58797192d61eb97f3bac5e07ac76d559615e5beeb2eed50cc99f8eed8fd9305a7723dd10f96b17df3a8de294ef6f91d8b8629ed99eeb573cc77f62b2851bc3914584eb7ef756bcc6346000795cf95876f41c3d72350c64bb0941016d19bdf0600e3f4492268c661a9c13a48b27489e9170ed83c20c1826bc60fc4dc4a8ef2207738379f2470d330fc701fd99bbcb8520662bdffa43570a20bde37f3ee255b314e6fef18ff04bc381fc38d2515fa7d3e5e59c762197f2b38d9f1880c2e5391c5921394614bce25031d9f2f0652af56c7868c83838b0382b091a9042ccdbc19fd1df3e27247659d3e5958e44917410233815b412e5774d174ebe34339212af4888aac0e007f82e055ed844556075ef87585cb473fc03e3cacbe75fbb422ea0864529a8e8042bf2a7cc8776c738a5399f676111587cdf3535b896cf2ddb8a0e4acc13e72de29afeb4329120dd58477e9148b0b5fc65d3f2bce170f95b113d85cb91d2192335c1c18d052d633dfa9af7f39bb664803234bdd3a62bd10090dc20d6c2d852a4f4cec9dc0e6b5b595e3b7af7bd6a412faba0ac38a85ab931a14cdc087a4795d6fffbcb924039288a6d20f9930da843eb61bf93c4d4cbbda369b5a7b88adddd36ea14d7c2d31222b99bfb34ade5fe1649ba4e9674d07396b6deb394d6b127e1026c82a35daa70b26f7e11dee1bf32309e26d8add2b46693228853e1f01ebd21556eca97beca59f6c6e44e52c47a372e93dba3c6e2f213c152c420fb68b9b92db029311271d8881db631b08fe9d93bc23d1f7df6af3f48f8ecddeeed9cd1869dac3613d8de58ec77cbcb837c9ae10925f21daa58d07dc782124f5ef93fb90717f2e9745532346d9819c95ee6fc9eadf2839f7b59c9eb253b5dc28859be315249e2169bde6d00ad91e4d3efccf0f459fd835d3f9fbdb54db5f9d1ecaaf4cee4d0cd73db6469062290c747b763724d66f3b69a3d41d39f02e5d4a0fbd6b993997929aaa7e7ee70fae2f0e250c54ad7da5873607aae77d4d1f568d94d1f7ffa9b1e1f665bc7af1e4923ad6d4fb86cd88eef41505d57e52a491be7dd2f2d47a2032225bda650a14794c65d17a8fa92cce706f97b47b984e0e35c449e74c07ea99c50057309997601d4ed7c74273009a3fba6921bfdeba133e1bf2e779a0b921d91d78ac7d2e79097890a1e21360e1b556f01a0a6ca9fa7a359310d1394e0a2317fde35f9282875f42d33967303a883bd7c157bf11bdd96ad8a329024c1f991f80baeef3cc1196c26257b49153b912c36a8d11d566d0688ce9b5d10fd2666ac77f3902bf06801310e35d6ecb0809f061fdf4e9b1b473f1a06275d8c82e1053e87cde6b6cc5af4a5f04f191a5e78a585d4ada0daa58855b8cfd32ca55b95354da364c8e988d06dc0bbf81e79ef98ce0355cfc4b9b1ff54785aec35027752e695cd53c1cf3c27835717f17ec87b8f3bfafb2ac31ff18bdb1b26b4141ac2664d34767d4723e09a6e4f357abd0a025da8937b972ba2bcbcf0357081e86b85cd6f8fb0a8827948ef0a632c3f150b85eeb5b241cfe90f048653aa64b7226fd495629f7dada3158d036fd0038ecb8d878d0a101aa745c1d004cc31d19dd14e7dc8728d3f740e9adc81b68a06284fe8c212a5ff4ba578b27bab2b24456a5adcbd0b2287fb62037c17b069eda65e63092323a7e3d55d131ced0caa7575fdadb449533a20953a132e6c71601f971fe4d28ea5c0cda1537e8b10a8d48f941e349cfb93b3ce5f36d80ebfcd6ac1bed060d8683feb64c4690ec60f3802c321ce463abdb805b2c168120745133b895fbcffb8c8ac952391179ff5c5baa5484f475cfb9dffa8d4b7a1032f33bf4c5cd91631de67ce9f3e1630c95f52ca30424efa1441fdd29aff6c2e7026472f980338c931df6602e66fe55e8435690aa02ece1ce22e9d6f096ac2480283647526206ab1fa70d14d9d999335494ef87f0e592f6e5f69ee081fd55ef4fe8ffe3ba023e5765b5c7ef062563ced9a46c4f41cc07946cb0ffe538a1d03570aa4295a15aae1b4e26b96c4be5602401ede700691969e65d1bf85bbc528c35de83580e66f675e250c961a874990632c8204b4ef0da7d1094464127184c4610f4d09314c2a0fe56004eabb9d5c99f7f2d356c5b7c7fbf4a69fb86217ce3eb2ca6c25ef7813e6fa1292ae3160a183e8c1991109ffcc77c139c7f6ae105deb1853276c38c949a90f2d22b725c794f5118879569bd250a9a344dac516905f362d0f66d3c1e733e7a7e4972d922cf643a2fe71517a97995bc91e20cc747183c97dca6d87e0e64be16f2d6715e574d40d917e1a42a613ef90688084d41ddc940131afe58277d3a63854f56ad2cd9882e2ca5fd7e9356ff6232e2daf86aa0c4050e14bf312128e0514d498a248e74282afad7c34f23cd96143beaeaaf0edcdfecf0f1a47ac548b6da21422460b3f35e4cf2abcffb4d3376674acfb9798ef2cbdd6cc591949a88c35fcf84e2f5b9012b6258bb008c9e6c0d7ec663324a3bd0207bf5afa76c6894c4605f255c9a54766f6a8b9f950829ab5d1fa1d8372a4ba66264ac0073c4a7f6c2f0d28fea3e5def456b5c7c226fa104a2277910832ae327cb96ebecf10983ac23e3e97777ea1ef37ef3e673c046bb3453dbc6e11f2027547ebeae35a0b11fd46ddd803503f650f44f791e55d6c74ff3b833a422a9082800c3ab587e614397cb05908a6d19be9e3814186b88db22bb4b0fb07776ca822348aaf1f524dfae55b88ff93ad22839d23a225ed3d72d7ed3e044d3bc4d5bf4805a35b3d28cd22af3d4d918306dad468143a347701bc38275942a42e8575b71c5152f23b39ed4ffdf305149506caf65ae10c696f88cca371307beb9474acd9144008977ec0c312efb8a64e4b6e0875eba1d6d270e26898ab40053c33b1c20ebfc8ed8a24f69a7ce1548e0d0e4dcaec55a636ed964da4d31d308428a9b39a1a002b5364b24f6720031d6ffbdb164b3ed7fe9227610aa89019a224918fa9720e821b8e74025f8f4760f778149edc660a91f9984739f7b687fc3fbfefda935b4fff2d3c0869db875441d0f58fec4c065adf7d27bf37df60c5cf65cb9399238b8b9eaa48cf1a7a4b2b4ab8009aaa3cb3ba64ae5d064b8c13a4b3e282e557fa35c87e0b944108d2b5b54da2cbdf8d4b685ab8a144262ae9b06fc51b476a0448bc6dcfac5b3535bdded4bd9eb37d42b067cb1aa56c57a51370b13440c663ef5a19111a8feca27adfdc48bc7a0d15190598aa60a8fd03d842e155e14f1f89cde437b55e2a57fbf59a4b15c86dda26f7c9d1db25813012cb8e081fe892911c6d5c5abb89e53f78df6306c91b1b653298d818d8600a4a5238ff7988080d74a07604d4a87652c233045f1033aa89ee6630698a7b101485dedf092719ec7ed6a45ac1406772454aafa082d6524067a4639837ea9b826f9d30914cbb2b56bcfb9ab07253df743db1aa54c281cd202599307081929a46415536c7fb3b37507821350606bbb4fa04d98805e9f058f756d5c27384e1c57060bdac143df3ff70532042eddfb23cca96eef8d4fdadeca95b7807d984b68b9150725d9ff11d7fff0db3835e450677964102e0c182b08f82b0ce31093b96a3a82aab2035e4c3fda1700ab05d50ed32898ffe6bc82dfd757a238aa8a21f8354c85f13e06aa8c07b657cd60be0fe36712bb1698fc17a10e5ad2e5c450b9775e75acf451c6cda50b7674f484d0214c2b2d15b05dbac1ca5dad1dc5be8c5c08d8f837640fcde1514707ae0bb44265d00a0656baa1dbfdcd88ddefd283fb7e484560336993e0ae672d3cdac1006d6eeec2d0c46f93d37f50f76344a4e46e8c90bafc7410f0e0840c3c657e6a194360151dfd8316b4702c3efc64d653fc396bf1ee63778f7f3b583a3580c7c08074d0775f318b633787985cb002171edfc694aa6fc772a43397eb9d1c6e833c80f0dfee1d361ec86d201206228daf18a00cf8890197f16cb200f76e1bee6197b26045e1c0439a70c4614996e51d5ebc6fda5124628b397510615b7d2f312699f4897cad95c35a9488af842d5015a99549745814418b545c8a493f7b33e4842eb4b5fe95d0e3fc2c3f8443b618a2202cea6f14d955305e1efe3762e722474aaeaa88aee38cb223b27c0b4fc4fa40acf4f6db3105fa07cbedb8860a1ce87582b03177b3a6116382dc6c7cdfa053a1e150991df32826ed7bf8d4002123400bd99bdf270f4731aa496e1f958284fcf62a05d12e4d37a2428c368b71b7d758b115ab498bc8ef766831d925e0c1d3c9a2064ed71377625d1fd6cd79781785f360a5e7066d7069258d7aab6fac5322f1759b9e398eb1de2f362a1bbc620586e31b85e16b506b04ee4eb4edb1fda773a29e01d5ee2edbf934a581771cb221b6af6e7d9f3b0eda09cd6dff74f47d6fa7d9eb60475462df1a3937d15b1dac3f51043770daa3a1d0fed3714f2fc3843e2f5b3094720123f3cb6c1cec7c0b58c74d50e94a2c82e4cce50a95f6227f7fcdbb55f2b868681ae37fd1d56b3a4df87c0c2c4bc2975ce8e10ffbb9ec58d8536ac4700b9c97017281c4e38ec0d57c44024122d8c17af39abb3b4afb41b4f5271e76f6e68804f7175031dc1b3c49f55890ad79f847a6d4a508bfafe8ff93e43d216fbb1a5595b5f17e9c91a95fe7dd2b80f7b4387b552ff120c247d0f77e3864f5babbcfc03a8fb9f7ecfc33fda4b7f4d7d265d73991be1e280fb21abb67da43554ab6e3d3ce59ade36d4461ff505cfb8123c92f8ac2608a98375467d9416aaa6e73ba65335bc24b4a0609e9de53e538e95cbeee48c891dadb77d9cc2fee67afe534b68faf3ec8605e76259f2bbce7d64623ef524ffe887e87b43506d0dfd7d7afcd0975676a6caf4c5c611dc85753544972902827a0a9aa468b6469487eb13a2888ed41fee01b5bc3a4a2afd7f9086d650aa00373e39521cb6f58bcdf97dbce287c632780818587ad7ba79f86a2fbbacac822a6eda68d4cc5dc2312adeeeddfe6f379f63e5f606cca2f98706d4727bb013863f4265c1f0963f408b4459f8581771e60020703377ddc90ba5ebf196d6933503a6c1d021533324500de7c09b2ebfcba6e0f8f42238627dc06f0d48167d8e9af46bcc517001152c46d6e2c0bd5ec161adaacf985e47bea7fdc6f219bb1f339b56f7fe2e43e3847281f1b5b67f1e00c6d7fe27c716e6ce35ef4cbd96ee99cb1f577cd76aae61ec049e8aa93c3d60309ce20de6da527030fc7f411e8fa661d90437533a1f72e6d8ee7c747f7df5f634948939dbfbc6855e334a41a78a9dc857d42aa9badde3ab6095ee50d93d7a8de6ebaddb1c32ead077675c3a02b4cc4d61e275f2e3dd6b30e918547293d86f511a8f030988537974b51e800aeae3394cb127f56b84cfe0078d765c623210c7f20b153564c0dfc566a64626bc3a90ea666d26efecbbd6facc66249cde4de73fba9dc62dcf45f05b990a88ca630d8651fbf4c43ee69ade94d3a8f99ae651bba30884e3caa575b5d96ce7548cc885d2903dd2446be8b0ce6d73493f9fcf9408a2a5871f6e617e94aba6c5f3e2bb81e818d811483b5e07e1366f68ac52a71696a80e8321c61aaf02c82f6b6971409b22a72938f20990118bfd2eb36b1c24ade4375cc872f91d65ccbeba9a53d0c7624eb4c8db9237b1785a9e6ee16f16a745ab7d0b0e2beab2f88eccc0db2614d7c3f7722936ab7451062bc11a4bac45d5724eeb80bf357a1085c3f2d69ed14dcb66b7d50e23dee195c7011ce01467cc309acb7a5191601793cfbb73e4f7fd0483cfcd794e3befcf3cd7f85b0b84edff87feb8ddb21046300665e074a5a0f58acdc0e13b858825941fb4a1975951880e2dc27c98908202e544029c280500112f24dd684d63201eb7ea5e7e38de627e90cb873b8ec045b698738bc87e77afa472403068676689f5e4298c3e620f40605484a958e784b0432485d51b8990faa39980ec78619c2ed2e5c6344f30f5a74478a12eacffa2b41746dc3a8edb0312354c4a01680c5bc86941b8fb7a0e5b83281a9331a1f2b75f44fdb46b62927b2010817ae848a3a5ea4ac4e5a5907dc2dae205d45a409710110b16ae97838f83a1498783804d8b8d0742878d880c28589a74327c02100010f3a1e0e968ed828395c62203f00114e603a60a04341603e4ce2437876a1042afa89616f79320a8303811e71d9496c01156ce2c146071c4adbd3e1afd9659d80c502f40ec8e1320019bb45575d5748df8c246aa8a52e3db0e01ac1f0d4532e9734d5853a8b96a75b63f3dea4cd9f08d0d694f0d926e632368544e382d7667862fa997eeaad05eb55fdf18e282f5f5f937c11638e88f0af5f6508e7c8b1b96eaeae0fe843396070141a01f5cbc8a8fc33fda93420fb88e9baeec30d90ad705627e1cbfe65e8e16423376303661eac1b6a2e6d2bd7f3adf0292fa33a65729a8774ba77a287ba9bdc8da0df6018cc35883b97114c94e6d4b73ae74523efacb47c355ab327400174ac40756ee44ee2c2173cbd80536fd1f4a2deeec72cd39ffa7eb1d9001a6696e21d64b10dad7631c603d3d8ed2de0b0cff8eb2411775270685183eb21f8e466de4fb0d23fcdf206fbc39560be8b276c4be403111824e27ad96e85cba8099813708b84a6ecdc294ab00b5fe64403a80161390320d0e82ab8af1cbd1066a413f8c808636badbd12b977be0e7c270111f671ad045427cb9425f29a423d2a5faf408f40c798cc97fe14ef556e901394c9de8048f04e1abfb415a5bf14bdbca8faa3c5cb849635c9a8dc25948c6b4b57656dbc6ba41a46e79de4588748decd94a7f91657751b3c6eb6c9c0daf9ed3cfe92f84c931a0550b546b059ee29755285175a4f8161f6469e7312ace6a0a1488401ed17dc7d45c929dfdc00f889eaf2333d77109ddb983b2932486651e98aef5ae0f48b1e5a3ce8c6e9d7c54faab94f771a8398bb80ca396be6d76b0ade7ad388475f6367c40d18b66f5f2aa3b62f66d38940fea6657e6390c4c07a0bf91cf5de2a59f12833d06a8f30061ddcf32d1502ffb9743a5cf849cfcd0d9a0ff78ffa02d7fc5869ebac03707207ac300424442cdfad9fcd0b6584b43079dfd70fad94e0ccdfaeeae5eb7048c2eb2bdcc173033e36360bf8604511d3436b9d6442966e726ecb3c2f9d13cccc22f03acd42c8b088c383ca962c6bb4bf30ae00276f5a05683d5729b0dcb09acafc112b5d18a92e5416155d65089f0e0092599afe84a5131e69dbf19294af46b933984f54f5416983bf9ebe555028edd0d3ad233004bea77b32faaa1e371f29feb85bc8949b09f26b8920c55365c030653cc657c94e74ebe1288cda4270db0e5c18a61eded8a230716de210d00884803fe41ca846180359117300f85c8bd91f 0000003c C:\SoftwareAG\Apama\monitors\query_support\QueryServices.cdp
TIME 0000000e 1484234969.8,1
MONF 000029e9 // 
// Bridges between the MemoryStore and ScenarioService event APIs. 
//
// Requires: ScenarioService.mon. 
//
// $Copyright(c) 2009-2012 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013-2015 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG

package com.apama.memorystore;

using com.apama.scenario.Update;
using com.apama.scenario.Create;
using com.apama.scenario.Delete;
using com.apama.scenario.Edit;
using com.apama.scenario.Created;
using com.apama.scenario.Deleted;
using com.apama.scenario.Edited;
using com.apama.scenario.InstanceDied;
using com.apama.scenario.Instance;
using com.apama.scenario.RequestInstancesDone;
using com.apama.scenario.RequestInstancesInternal;
using com.apama.scenario.Scenario;
using com.apama.scenario.ScenarioServiceUpdaterMultipleInstances;
using com.apama.scenario.ScenarioServiceLibrary;
using com.apama.scenario.StartScenarioRecovery;
using com.apama.scenario.ConfigureUpdates;
using com.apama.scenario.GetAllConfiguration;
using com.apama.scenario.AllConfiguration;

/**
	Requests Scenario Service updates for an exposed MemoryStore to be 
	forwarded to the specified Correlator context. 
	
	Note that this is inefficient and does not implement proper flow
	control. Only use for testing or debugging. 
	
	@see Schema#exposeMemoryView Only tables that are configured to expose 
		their contents will be affected by this event. 
*/
event ForwardMemoryStoreUpdatesTo {
	/** The context to which events should be forwarded. */
	context ctx;
}

/** Makes data in MemoryStore available for viewing by 
	any dashboard client that uses the Scenario Service, or as a 
	DataView. 
	
	@private
*/
monitor MemoryStoreScenarioImpl
{
	import "MemoryStorePlugin" as plugin;

	string MEMORYSTORE_SCENARIO_PREFIX := "DV_MEMST_";
	string PREFIX_UPPER := "DV_MEMST`";
	Scenario recoveryResponse;
	Storage storage;
	boolean doingRecovery;
	// a private context that sends events out.  Should never block on something 
	// that may be blocking on the memory store plugin. That means no 
	// calling into the plugin and no direct send-to to any other 
	// context that may call the plugin.
	// Deadlocks can be avoided using the asyncEnqueuTo method on the
	// plugin, but must only do so if there can only be a bounded 
	// number of such events queued; we use it for scenario discovery only.
	context emitterContext := context("MemoryStore_emitter");
	context asyncForwarding := context("MemoryStore_forwarder");
	context mainContext := context.current();

	action onload()
	{
		spawn asyncForwarder() to asyncForwarding;
		integer id:=integer.getUnique();
		route GetAllConfiguration(id);
		AllConfiguration allConfig;
		on AllConfiguration(requestId = id):allConfig {
			startup(allConfig.defaultConfig, allConfig.configurations);
		}
	}

	event RequestInstancesHandler {
		import "MemoryStorePlugin" as plugin;
		RequestInstancesInternal scenRequestInstances;
		ScenarioServiceUpdaterMultipleInstances updater;
		action<string, RequestInstancesInternal, ScenarioServiceUpdaterMultipleInstances> handleRequestInstances;
		context emitterContext;

		action onConfig() {
			sequence<string> names := ["", ""];
			plugin.decodeScenarioName(scenRequestInstances.scenarioId, names);
			string storeName := names[0], tableName := names[1];

			Storage storage:=new Storage;
			if storage.hasStore(storeName) then
			{
				Store store := storage.open(storeName);
				if store.hasTable(tableName) then
				{
					if updater.base.sendAny then
					{
						if plugin.exposingViews(tableName,storeName,isMemory(scenRequestInstances.scenarioId)) then {
							spawn spawnTarget() to emitterContext;
							plugin.sendScenarioInstancesFor(tableName,storeName,isMemory(scenRequestInstances.scenarioId),scenRequestInstances.messageId);
						} else {
							route com.apama.scenario.RequestInstancesDone(scenRequestInstances.scenarioId, scenRequestInstances.messageId);
						}
					} else {
						route com.apama.scenario.RequestInstancesDone(scenRequestInstances.scenarioId, scenRequestInstances.messageId);
					}
				}
			}
			updater.destroy();
		}
		action spawnTarget() {
			handleRequestInstances(scenRequestInstances.scenarioId, scenRequestInstances, updater);
		}

		action isMemory(string name) returns boolean
		{
			string MEMORYSTORE_SCENARIO_MEMORY_SUFFIX := "_memory";
			integer index := name.find(MEMORYSTORE_SCENARIO_MEMORY_SUFFIX);
			return index > 0;
		}
	}

	event InvalidRequestHandler {
		ScenarioServiceUpdaterMultipleInstances updater;
		integer messageId;
		integer scenarioInstanceId;

		action handle(string scenarioId, integer messageId, integer scenarioInstanceId) {
			self.messageId := messageId;
			self.scenarioInstanceId := scenarioInstanceId;
			updater.init_cb(scenarioId, context.current(), onConfig);
		}

		action onConfig() {
			updater.emitNack(messageId, scenarioInstanceId);
			updater.destroy();
		}
	}
	
	action startup(dictionary<string, string> defaultConfig, dictionary<string, dictionary<string, string> > configurations) {
		spawn handleNewScenarios(defaultConfig, configurations) to emitterContext;

		//setup listener to listen for discovery
		on all StartScenarioRecovery()
		{
			doingRecovery := true;
			chunk c := plugin.prepareScenariosSnapshot2();
			integer count := plugin.ScenarioChunk_count(c);
			integer i := 0;		
			while i < count
			{
				recoveryResponse.scenarioId := plugin.ScenarioChunk_getId(c,i);
				recoveryResponse.displayName := plugin.ScenarioChunk_getName(c,i);
				recoveryResponse.description := plugin.ScenarioChunk_getDescription(c,i);
				recoveryResponse.outputNames := [];
				integer numFields := plugin.ScenarioChunk_getFieldsLength(c,i);
				integer j := 0;
				while j < numFields
				{
					recoveryResponse.outputNames.append(plugin.ScenarioChunk_getField(c,i,j));
					j := j + 1;
				}
				recoveryResponse.outputTypes := [];
				integer numTypes := plugin.ScenarioChunk_getTypesLength(c,i);
				j := 0;
				while j < numTypes
				{
					recoveryResponse.outputTypes.append(plugin.ScenarioChunk_getType(c,i,j));
					j := j + 1;
				}
				i := i + 1;
				recoveryResponse.extraParams := {"isReadOnly":"true", "type":"dataview"};
				route recoveryResponse;
			}

		}
		on all completed StartScenarioRecovery() {
			doingRecovery := false;
		}

		// initialisation - send all scenarios to the emitter context, spawn for each scenario

		plugin.setEmitContext(emitterContext.getId());

		{
			chunk c := plugin.prepareScenariosSnapshot2();
			integer count := plugin.ScenarioChunk_count(c);
			integer i := 0;		

			while i < count
			{
				spawn handleScenario(plugin.ScenarioChunk_getId(c,i)) to emitterContext;
				i := i + 1;
			}
		}

		// forward scenario service requests:
		ConfigureUpdates configUpdate;
		on all ConfigureUpdates():configUpdate {
			send configUpdate to emitterContext;
		}
		RequestInstancesInternal scenRequestInstances;
		on all RequestInstancesInternal(scenarioId in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):scenRequestInstances
		{
			ScenarioServiceUpdaterMultipleInstances updater := new ScenarioServiceUpdaterMultipleInstances;
			RequestInstancesHandler handler := RequestInstancesHandler(scenRequestInstances, updater, handleRequestInstances, emitterContext);
			updater.init_cb(scenRequestInstances.scenarioId, context.current(), handler.onConfig);
		}
		Create scenCreate;
		on all Create(scenarioId in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):scenCreate
		{
			InvalidRequestHandler handler:=new InvalidRequestHandler;
			handler.handle(scenCreate.scenarioId, scenCreate.messageId, -1);
		}

		Delete scenDel;
		on all Delete(scenarioId  in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):scenDel
		{
			InvalidRequestHandler handler:=new InvalidRequestHandler;
			handler.handle(scenDel.scenarioId, scenDel.messageId, scenDel.scenarioInstanceId);
		}

		Edit scenEdit;
		on all Edit(scenarioId in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):scenEdit
		{
			InvalidRequestHandler handler:=new InvalidRequestHandler;
			handler.handle(scenEdit.scenarioId, scenEdit.messageId, scenEdit.scenarioInstanceId);
		}
		ForwardMemoryStoreUpdatesTo f;
		on all ForwardMemoryStoreUpdatesTo():f {
			spawn forwardUpdatesTo(f.ctx) to emitterContext;
		}
	}

	action handleNewScenarios(dictionary <string,string> defaultConfig, dictionary <string, dictionary<string,string> > configurations) {

		Scenario scenario;
		on all unmatched Scenario(scenarioId in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):scenario
		{
			send scenario to "com.apama.scenario";
			spawn handleScenario(scenario.scenarioId);
		}
		ScenarioServiceLibrary lib:= new ScenarioServiceLibrary;
		lib.configurationManager(defaultConfig, configurations);
	}
	


	action handleScenario(string scenarioId) {
		on all Scenario(scenarioId = scenarioId) {}

		ScenarioServiceUpdaterMultipleInstances updater := new ScenarioServiceUpdaterMultipleInstances;
		updater.init(scenarioId, asyncForwarding);
		updater.emitReceivedEvents();
	}

	action handleRequestInstances(string scenarioId, RequestInstancesInternal scenRequestInstances, ScenarioServiceUpdaterMultipleInstances updater) {
		Instance scenInstance;
		on all Instance(scenarioId = scenarioId, messageId = scenRequestInstances.messageId):scenInstance and 
			not RequestInstancesDone(scenarioId = scenarioId, messageId = scenRequestInstances.messageId) {
			updater.emitReceivedInstance(scenRequestInstances, scenInstance);
		}
		RequestInstancesDone rid;
		on all RequestInstancesDone(scenarioId = scenarioId, messageId = scenRequestInstances.messageId):rid {
			integer _ := plugin.asyncEnqueueTo(rid.toString(), mainContext.getId()); // doesn't matter when it completes
			die;
		}
	}

	action asyncForwarder() {
		Instance i;
		on all Instance():i {
			integer _:=plugin.asyncEnqueueTo(i.toString(), mainContext.getId());
		}
		RequestInstancesDone rid;
		on all RequestInstancesDone():rid {
			integer _:=plugin.asyncEnqueueTo(rid.toString(), mainContext.getId());
		}
	}

	action forwardUpdatesTo(context ctx) {
		Update u;
		on all Update(scenarioId in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):u {
			integer _:=plugin.asyncEnqueueTo(u.toString(), ctx.getId());
		}
	}
}

 00000045 C:\SoftwareAG\Apama\monitors\data_storage\MemoryStoreScenarioImpl.mon
MONF 00000286 //*****************************************************************************
// Title:         SensorEvent
// Description:   An event type for the sensor data and the timestamp in seconds.
// Author:        Software AG
//
//*****************************************************************************

package com.softwareag.saep;

event SensorEvent {
	integer sensorId;
	integer timeStamp;
	integer x;
	integer y;
	integer z;
	integer velocity;
	integer acceleration;
	integer velocityX;
	integer velocityY;
	integer velocityZ;
	integer accelerationX;
	integer accelerationY;
	integer accelerationZ;
	float seconds;
} 00000046 C:\Users\istmapara\workspace910\task1\eventdefinitions\SensorEvent.mon
MONF 00000231 //*****************************************************************************
// Title:         VelocityEvent
// Description:   VelocityEvent description
// Dependencies:  None
// Author:        istmapara
//
//*****************************************************************************

package com.softwareag.saep;


//event PlayerVelocity {
//	integer playerId;
//	string playerName;
//	float timestamp;
//	string intensity;
//	float speed;
//	float distance;
//	
//}

event PlayerVelocity {
integer playerId;
integer velocity;

} 00000048 C:\Users\istmapara\workspace910\task1\eventdefinitions\VelocityEvent.mon
MONF 000008b1 //*****************************************************************************
// Title:         VelocityMonitor
// Description:   VelocityMonitor description
// Dependencies:  None
// Author:        istmapara
//
//*****************************************************************************
package com.softwareag.saep;
using com.apama.aggregates.mean;

monitor VelocityMonitor {
	dictionary<integer, integer> sensorPlayer := {4:0,8:0,10:0,12:0,
		13:1,14:1,97:1,98:1, 47:2,16:2, 49:3,88:3, 19:4,52:4, 
		53:5,54:5, 23:6,24:6, 57:7,58:7, 59:8,28:8, 61:9,62:9,99:9,100:9,
		63:10,64:10,65:11,66:11, 67:12,68:12, 69:13,38:13, 71:14,40:14,
		73:15,74:15,75:16,44:16,105:17,106:17
	}; 
	dictionary<integer, string> playerNameDict := {0:"Ball",
		1:"Nick Gertje", 2:"Dennis Dotterweich", 3:"Niklas Walzlein",
		4:"Wili Sommer",5:"Philipp Harlass", 6:"Roman Hartleb", 
		7:"Erik Engelhardt", 8:"Sandro Schneider", 9:"Leon Krapf",
		10:"Kevin Baer",11:"Luca Ziegler", 12:"Ben Mueller", 13:"Vale Reitstetter",
		14:"Christopher Lee",15:"Leon Heinze",16:"Leo Langhans",17:"Referee"
	}; 
	action onload() {
		SensorEvent s1;
		on all SensorEvent(): s1{
			integer sensorId := s1.sensorId;
			integer playerId := sensorPlayer[sensorId];
			string playerName := playerNameDict[playerId];
			send PlayerVelocity(playerId, s1.velocity) to "";
		}
		
		PlayerVelocity playerV;
		on all PlayerVelocity() : playerV {
			log playerV.toString() at INFO;
		}
			
			float avg;
			from v in all PlayerVelocity(playerId = 0)
			  within 5.0
			  select mean(v.velocity.toFloat()) : avg {
				log "Avg for player 0" + " : " + avg.toString() at INFO;
			}
			
			from v in all PlayerVelocity(playerId = 5)
			  within 5.0
			  select mean(v.velocity.toFloat()) : avg {
				log "Avg for player 5" + " : " + avg.toString() at INFO;
			}
			
		//Mauro: 	Die Funktion muss fr jede SpielerId fr jedes Zeitfenster aufgerufen werden.
		//			within 5.0 every 5.0 funktioniert leider nich nicht. Ich denke das liegt 
		//			daran das wir zu wenige Daten haben.
		//			Ich denke der rest (die einordnung in die verschiedenen Klassen stehen, ..., rennen
		//			erfolgt direkt im dashboard.

	}
} 00000042 C:\Users\istmapara\workspace910\task1\monitors\VelocityMonitor.mon
MONF 0000036f //*****************************************************************************
// Title:         RawEvent
// Description:   An event type for the raw sensor data.
// Author:        Software AG
//
//*****************************************************************************

package com.softwareag.saep;

event RawEvent {
	integer sensorId;
	integer timeStamp;
	integer x;
	integer y;
	integer z;
	integer velocity;
	integer acceleration;
	integer velocityX;
	integer velocityY;
	integer velocityZ;
	integer accelerationX;
	integer accelerationY;
	integer accelerationZ;
	
	action getSourceTime() returns float {
		string sec := "0.0";
		integer length := timeStamp.toString().length();
		if (length > 4) then {
			sec := timeStamp.toString().substring(0, 5) + "." + timeStamp.toString().substring(5, length);
		}
		return sec.toFloat();
	}

} 00000043 C:\Users\istmapara\workspace910\task1\eventdefinitions\RawEvent.mon
MONF 000001cf //*****************************************************************************
// Title:         Counter
// Description:   Counts sensor events
// Author:        Software AG
//
//*****************************************************************************

package com.softwareag.saep;

event Counter {
	integer count;
}

event SensorCounter {
	integer sensorId;
	integer count;
}

event PlayerCounter {
	integer playerId;
	integer count;
} 00000047 C:\Users\istmapara\workspace910\task1\eventdefinitions\CounterEvent.mon
MONF 000002e0 //*****************************************************************************
// Title:         RawMonitor
// Description:   Creates a SensorEvent from each RawEvent.
// Dependencies:  Event type definitions
// Author:        Software AG
//
//*****************************************************************************

package com.softwareag.saep;

monitor RawMonitor {
	action onload() {
		RawEvent raw;
		on all RawEvent() : raw {
			route SensorEvent(raw.sensorId, raw.timeStamp, raw.x, raw.y, raw.z, 
			                  raw.velocity, raw.acceleration, raw.velocityX, raw.velocityY, raw.velocityZ, 
			                  raw.accelerationX, raw.accelerationY, raw.accelerationZ, raw.getSourceTime());
		}
	}
} 0000003d C:\Users\istmapara\workspace910\task1\monitors\RawMonitor.mon
MONF 00000379 //*****************************************************************************
// Title:         SensorMonitor
// Description:   Loga all SensorEvents. This is the starting point for the application logic.
// Dependencies:  Event type definitions and RawMonitor.mon
// Author:        Software AG
//
//*****************************************************************************

package com.softwareag.saep;
using com.apama.correlator.timeformat.TimeFormat;

monitor SensorMonitor {
	TimeFormat timeFormat;
	action onload() {
		SensorEvent sensor;
		on all SensorEvent() : sensor {
			log sensor.toString() + 
				", seconds: " + timeFormat.format(sensor.seconds, "HH:mm:ss,SSS") + 
				", event time: " + sensor.getTime().toString() + 
				", micro time: " + timeFormat.getMicroTime().toString()
			at INFO;
			//com.apama.queries
			send sensor to "";
		}
	}
} 00000040 C:\Users\istmapara\workspace910\task1\monitors\SensorMonitor.mon
MONI 0001426a /* Package as specified by the .qry */
package com.softwareag.saep; 
/* Private using declarations required by framework */
using com.apama.queries.__Index;
using com.apama.queries.__LatestEvent;
using com.apama.queries.__Respawn;
using com.apama.queries.__RestartQueryTimer;
using com.apama.queries.__Trigger;
using com.apama.queries.__TS;

/* Private using declarations required by framework to interact with QueryServices.mon */
using com.apama.queries.__ContextMgr;
using com.apama.queries.__DistributionMgr;
using com.apama.queries.__FailedQueryInstance;
using com.apama.queries.__HubContextRequest;
using com.apama.queries.__HubContextRemove;
using com.apama.queries.__PendingTimersMgr;
using com.apama.queries.__PrepareStore;
using com.apama.queries.__QueryLoaded;
using com.apama.queries.__QueryLogger;
using com.apama.queries.__QueryReady;
using com.apama.queries.__QueryScenarioService;
using com.apama.queries.__RemoveInstance;
using com.apama.queries.__StoredEventWindow;
using com.apama.queries.__StorePrepared;
using com.apama.queries.__StoredSnapshot;
using com.apama.queries.__TerminationMgr;
using com.apama.queries.__WorkerContextSet;
using com.apama.queries.__WindowLength;
using com.apama.queries.__WindowManager;
using com.apama.queries.__WindowManagerTableUsageChanged;

/* Using declarations explicitly specified in the .qry */
using com.apama.aggregates.count; 

/**
 * Monitor controlling query Groups.
 */
monitor Groups { 

	/** General internal events */
	event __NullType {
	}

	/** The set of worker contexts */
	__WorkerContextSet workers;
	
	/** The index of the current worker context */
	integer index;

	/* Flag for whether or not (and how) to respawn after ondie is triggered */
	boolean shouldRespawn := false;
	boolean shouldTerminateWorkers := false;
	boolean deleted := false; // has been deleted

	/* Number of instances of the query. Used to limit non-parameterized queries to a single instance */
	integer instanceCount := 0;
	
	/* TerminationManager used to shutdown workers */
	__TerminationMgr terminationMgr;

	/** Set of pending input window preparations
	 */	
	dictionary<integer, integer> pendingPreparations;

	/** The MemoryStore Store used to hold each event window */
	com.apama.memorystore.Store store;

	/** A __DistributionMgr for each input type */
	__DistributionMgr dist_com$softwareag$saep$SensorEvent;
	__DistributionMgr dist___RestartQueryTimer;
	/** Manager for processPending timers */
	__PendingTimersMgr timerMgr;

	/** Flag to inidicate where any input source times are used */
	boolean anyHaveSourceTimestamps;

	/** Used to interact with the Scenario Service monitor which is stuck in the past i.e. the main context */
	context scenarioServiceCtx;
	context mainCtx;
	// @see HubContextManager
	context hubCtx;
	context statsGatherer;
	boolean isMasterMonitor;
	boolean isInstanceProxy;
	boolean initialised;
	boolean createdAtStartup; // see initCommon
	integer qryId;
	string parameterizationOwner;

	/** Query scenario service event */
	__QueryScenarioService queryScenarioService;
	__QueryLogger qLogger;

	string queryDefinitionName := queryScenarioService.QUERY_PREFIX + "com.softwareag.saep.Groups";


	/**
	 * A per-matchset event. 
	 *
	 * Contains a potential matching set of events and any other state
	 * needed to evaluate the pattern.
	 * MatchSets are owned by a parent (either another MatchSet or the
	 * EvaluationState
	 */
	event __MatchSet {	
		///// state corresponding to the pattern:

		// coassigned (positive) events:
		wildcard SensorEvent csnmt_s1 ;

		// flags to record which coassignments we have:
		wildcard boolean has_s1;
		// flags to record which coassignments we have previously triggered:
		wildcard integer triggered_s1;
		
		// timestamps of the events
		wildcard float timestamp_s1;

		// per-followedby node - which way is it looking?


		// per-without sets of the event - only holds those where we
		// don't yet know whether the 'where' condition holds.
		
		///// state corresponding to the evaluation state:
		integer id;
		action init() {
			id := integer.getUnique();
		}

		// The effective timestamp for when this match occurred
		action mostRecentTime() returns float {
			float t := -float.INFINITY;

			if (timestamp_s1 > t) then {
				t := timestamp_s1;
			}

			return t;
		}

		// we maintain an ordered linked list of matchsets, the most recent first
		// this is managed by EvaluationState.addNewMatchsetAfter and 
		// EvaluationState.discard
		integer next;
		integer prev;

		// count of how many instances of the 'current' event this matchset contains:
		integer containsCurrent;
	}


	event __SelectOutput {
		wildcard integer sensorCount;
		/**
		 * Simulates the 'having' clause from a query. The having expression is fed into __having in the select clause, and then
		 * interrogated before the find action is triggered. We do this in preference to using an actual 'having' clause to avoid obscure
		 * error message bugs.
		 */
		boolean __having;
	}
	event __DelayedOutOfOrderTime {
		float maxInputEventTimestamp;
		float correlatorTimeBecomesDefinitive;
	}

    	/** Utility event containing all user-defined parameters, expressions and query actions*/
	event __ElasticQueryUserCode {

		/* Only copy of query parameters */


		wildcard integer sensorId; 


		/** Return the user-specified duration; the evaluation of either an EPL float expression or a time literal */
		action __getWithin_com$softwareag$saep$SensorEvent() returns float {
			return  5.0;   
		}


		/* User code that gets invoked when the pattern is matched 
		 * Takes coassignments into its scope as arguments, and parameters/keys as members on self.
		 */
		action __findAction(integer sensorCount ) {

			/**
			 * Brackets for extra scoping goodness; we want the user to be able to declare
			 * variables that mask arguments to this action i.e. coassignments
			 */
			{
{
			send SensorCounter(sensorId, sensorCount) to "";
		}				 
			}
		}

		action __processAggregates(sequence<__MatchSet> __matchSets) {
			integer __toRetain := __matchSets.size();
			integer __id := integer.getUnique();
			stream<__MatchSet> __mstr := from idx in all __Index(id=__id) retain __toRetain select __matchSets[idx.idx];
			// while these are not used (and should not be used), they are
			// here to help the completion proposals.  Actual use of them in
			// the projection is via the __ms prefix.

			SensorEvent s1;

			__SelectOutput __output;
			listener  __sstr := from __ms in __mstr retain __toRetain from __t in all __Trigger(__id)
				/** Force this to be an aggregate query so that a query with a non-aggregate-ey select clause gets flagged as an error */
				having true
				select __SelectOutput(count() 
		, 			true
				)
				:__output
			{
				__mstr.quit();
				__sstr.quit();
				if(__output.__having) then {
					try{
						__findAction(__output.sensorCount);
					} catch(com.apama.exceptions.Exception __e) {
						 
						__qLogger.instanceLog("Pattern action threw exception"
							+ ": " + __e.getType() + " - " + __e.getMessage(), "WARN", false); 

					}
				}
			}
			integer __i:=0;
			while(__i < __matchSets.size()) {
				route __Index(__id, __i);
				__i := __i+1;
			}
			route __Trigger(__id);
		} 





		/* Parameterized query logger */
		__QueryLogger __qLogger;

		/* Pattern event listener(s) */

		action<action<string, boolean, float>, integer, com.softwareag.saep.SensorEvent> __handle_com$softwareag$saep$SensorEvent;


		/** __WindowManager._listenFor_cb */
		action __listenFor_com$softwareag$saep$SensorEvent(action<string, boolean, float> __onEvent, action<string, string, boolean, float> __onHeartbeat) returns sequence<listener> {
			sequence<listener> listeners := [];
			com.softwareag.saep.SensorEvent  __latest;
			listener l := on all com.softwareag.saep.SensorEvent(): __latest { 
				__handle_com$softwareag$saep$SensorEvent(__onEvent, 10, __latest);
			}
			listeners.append(l);
			return listeners;

		}
		/* Template listener - not kept live, just used to serialise the templateArgs.  */
		action __startListener_com$softwareag$saep$SensorEvent() returns listener {
			com.softwareag.saep.SensorEvent  __latest;
			listener __l := on com.softwareag.saep.SensorEvent(): __latest { 
			}
			return __l;
		}


		/* Get time in seconds*/
		action __calculateTime(string day, string hour, string min, string sec, string msec) returns float {
			float value := __parseToFloat(day)*86400000.000 + 
			               __parseToFloat(hour)*3600000.000 + 
			               __parseToFloat(min)*60000.000 + 
			               __parseToFloat(sec)*1000.000 + 
			               __parseToFloat(msec);
			// round time to nearest millisecond
			return value.round().toFloat()/1000.0;
		}
	
		action __parseToFloat(string num) returns float {
			if (num = "") then {
				return 0.0;
			}
			// if hexadecimal integer then first parse into int
			if (num.length() > 2 and (num.substring(0, 2) = "0x" or num.substring(0, 2) = "0X")) then {
				return integer.parse(num).toFloat();
			} else {
				return float.parse(num);
			}
		}


	} // end of event __ElasticQueryUserCode

	__ElasticQueryUserCode __user;

	action __calculateTime(string day, string hour, string min, string sec, string msec) returns float {
		return __user.__calculateTime(day, hour, min, sec, msec);
	}

	/** Actually just proxies an onload_ call into the query hub context */
	//  @see HubContextManager
	action onload() {
		scenarioServiceCtx := context.current();
		mainCtx := context.current();
		(new __HubContextRequest).process(true, queryDefinitionName, hubCallback);
	}
	
	action hubCallback(context _hubCtx, context _statsGatherer) {
		hubCtx := _hubCtx;
		statsGatherer := _statsGatherer;
		route __QueryLoaded("com.softwareag.saep.Groups");
		// Spawn into the query hub context
		spawn onload_() to hubCtx;
	}

	/** 
	* Called when monitor is loaded.
	*/
	action onload_() {
		// Is main (parent) monitor causes termination then query scenario service is made aware
		isMasterMonitor := true;
		sequence<string> eventTypes := ["com.softwareag.saep.SensorEvent"];
		anyHaveSourceTimestamps := false;

		// Set necessary query scenario service support event query information
		queryScenarioService.init(
			"com.softwareag.saep.Groups",
			queryDefinitionName,
			false,
			false,
			createParameterizedQueryInstance,
			updateUserParameters,
			prepareParameterizedQueryInstanceFinish,
			scenarioServiceCtx,
			hubCtx,
			statsGatherer,
			eventTypes,
			getMetadataMap()
		);

		qLogger := queryScenarioService.getLogger();

		// Create a __TerminationMgr for the master, - in case an unparameterized query fails
		(new __TerminationMgr).init(terminateWorker, queryDefinitionName, -1);

		// Start point of query creation
		prepareStores();
	}

	// Block handle store preparation, where certain store need to be prepared
	// before the instance is prepared - uses callback (called only once successfully
	// prepared to ensure they are triggered in the intended order.
	// Order is pending timer manager -> scenario service
	action prepareStores() {
		timerMgr.init(hubCtx, queryScenarioService.masterId, qLogger, prepareStoresCompleted);
	}

	boolean allTablePrepareSucceeded;

	action prepareStoresCompleted(boolean success, com.apama.memorystore.Table timersTable) {
		allTablePrepareSucceeded := success; // used by initWindowTable, see below
		// Store preparation listener
		integer reqId := integer.getUnique();
		__StorePrepared prepared;
		on __StorePrepared(requestId = reqId):prepared {
			/** Name of the store */
			queryScenarioService.storeName := prepared.storeName;
			if(prepared.success) then {
				timerMgr.timersTable := timersTable;
				timerMgr.startClusterMemberChangeMonitor();
				scenarioServiceStorePrepared();
			} else {
				qLogger.queryLog("Could not prepare store " + queryScenarioService.storeName + ": " + prepared.reason, "FATAL", false);
				shouldRespawn := false;
				die;
			}
		}

		// Prepare the store
		route __PrepareStore(queryScenarioService.name, reqId);
	}

	action scenarioServiceStarted() {
		// start the failed query handler
		spawn failedQueryHandler();

		// the following instances are created at startup:
		createdAtStartup := true;
		// Check to see if this unparameterized query was previously created and if so recreate with the same instance ID.
		// There should only be a single instance in the table for a non-parameterized query
		try {
			com.apama.memorystore.Iterator it:=queryScenarioService.paramTable.begin();
			if (not it.done()) then {
				// ReCreate the existing instance
				qLogger.queryLog("Recreating non-parameterized query instance", "DEBUG", false);
				queryScenarioService.routeCreate(0, "*", new sequence<string>, it.getKey().toInteger());
			} else {
				// Create a new instance
				queryScenarioService.routeCreate(0, "*", new sequence<string>, 0);
			}
		} catch(com.apama.exceptions.Exception e) {
			// fallback, possibly if no table of parameterizations:
			queryScenarioService.routeCreate(0, "*", new sequence<string>, 0);
		}
		// either way, we create a single instance; mark this as loading until the instance has started (i.e. not start JMS until it has started)
		send __QueryLoaded(queryScenarioService.name) to scenarioServiceCtx;
		send __QueryReady(queryScenarioService.name) to scenarioServiceCtx;
		integer id:=integer.getUnique();
		route __Trigger(id);
		on __Trigger(id) {
			// after we have processed Create events, any further creates are not at startup.
			createdAtStartup := false;
		}
	}

	/** Store is ready to be opened */
	action scenarioServiceStorePrepared() {
		store := (new com.apama.memorystore.Storage).open(queryScenarioService.storeName);

		// Open or create the parameterised store here.
		// Needs to be ready before ScenarioService is (ie before we have create listeners etc)
		// FIXME - Use a single table to store the parameterizations?
		__NullType n := new __NullType;
		string queryName := n.getName().substring(0,-11);
		// Table to store parameter values
		string tableName := "parameterizations_"+queryName+"_"+queryScenarioService.name;
		com.apama.memorystore.Schema schema := new com.apama.memorystore.Schema;
		schema.fields.append("scenarioId");
		schema.types.append("string");
		schema.fields.append("owner");
		schema.types.append("string");
		schema.fields.append("parameters");
		schema.types.append("string");

		// Table to store instance ID
		string eqConfigTableName := "eqConfig"; // elastic queries config table
		com.apama.memorystore.Schema eqConfigSchema := new com.apama.memorystore.Schema;
		eqConfigSchema.fields.append("integerConfig");
		eqConfigSchema.types.append("integer");
		eqConfigSchema.fields.append("stringConfig");
		eqConfigSchema.types.append("string");
		
		// Prepare the table to hold the event window
		qLogger.queryLog("Preparing table to store parameter values: " + tableName, "DEBUG", false);
		integer id2 := store.prepare(tableName, schema);
		qLogger.queryLog("Preparing table to store parameter IDs: " + eqConfigTableName, "DEBUG", false);
		integer id3 := store.prepare(eqConfigTableName, eqConfigSchema);

		com.apama.memorystore.Finished f2;
		com.apama.memorystore.Finished f3;
		on com.apama.memorystore.Finished(id=id2):f2 and
		   com.apama.memorystore.Finished(id=id3):f3 {
			if f2.success then { 
				// Open the parameterizations table
				queryScenarioService.paramTable := store.open(tableName);
				qLogger.queryLog("Successfully prepared table to store parameter values: " + tableName, "DEBUG", false);
			} else {
				qLogger.queryLog("Asynchronous MemoryStore operation (Prepare Parameterizations) failed: " + f2.toString(), "FATAL", false);
			}

			if f3.success then { 
				queryScenarioService.eqConfigTable := store.open(eqConfigTableName);
				qLogger.queryLog("Successfully prepared table to store parameter IDs: " + eqConfigTableName, "DEBUG", false);
			} else {
				qLogger.queryLog("Asynchronous MemoryStore operation (Prepare eqConfig table) failed: " + f3.toString(), "FATAL", false);
			}
			allTablePrepareSucceeded := allTablePrepareSucceeded and f2.success and f3.success;

			try {
				// Subscribe to the table notifications
				integer notificationId := queryScenarioService.paramTable.subscribeRowChanged();
				queryScenarioService.supportsRowNotifications := true;
			} catch (com.apama.exceptions.Exception e) {
				qLogger.queryLog("MemoryStore driver doesn't support RowChanged notifications.", "INFO", false);
				queryScenarioService.supportsRowNotifications := false;
			}
			
			if (queryScenarioService.supportsRowNotifications) then {
				com.apama.memorystore.RowChanged rc;
				on all com.apama.memorystore.RowChanged(storeName  = queryScenarioService.storeName,
				                                        tableName  = tableName,
				                                        changeType = com.apama.memorystore.RowChanged.INSERT):rc {
					qLogger.queryLog("Received RowChanged::" + rc.getChangeTypeString() + " event: key=" + rc.key 
						+ ": " + rc.oldFieldValues.toString() + " -> " + rc.newFieldValues.toString(), "DEBUG", false);

					com.apama.memorystore.Row r := queryScenarioService.paramTable.get(rc.key);
					string sid := r.getString("scenarioId");
					string s1 := r.getString("parameters");
					sequence<string> seq := sequence<string>.parse(s1);
					
					// (Re)Create the instance - this correlator might have created this instance in which case we 
					// shouldn't do anything here.
					queryScenarioService.routeCreate(0, "*", seq, rc.key.toInteger());
				}
			}

			// start query scenario service
			queryScenarioService.start(setupScenario(), scenarioServiceStarted);
			spawn talkToScenarioService() to scenarioServiceCtx; // Ensure correct communication with scenario service
		}

	}

	string sharedId;

	action initWindowTable(action<> callbackComplete) {
		
		string oldSharedId := sharedId;
		dictionary<string, boolean> allSharedIds_and_hasSourceTime := {sharedId_com$softwareag$saep$SensorEvent:false};
		sequence<string> allSharedIds_and_hasSourceTime_keys := allSharedIds_and_hasSourceTime.keys();
		allSharedIds_and_hasSourceTime_keys.sort();
		sequence<string> allSharedIds := new sequence<string>;
		sequence<boolean> hasSourceTime := new sequence<boolean>;
		dictionary<string,string> sharedIdToHeartbeatType := {
			sharedId_com$softwareag$saep$SensorEvent : ""
			};
		string sharedId_key;
		for sharedId_key in allSharedIds_and_hasSourceTime_keys {
			allSharedIds.append(sharedId_key);
			hasSourceTime.append(allSharedIds_and_hasSourceTime[sharedId_key]);
		}

		sharedId := allSharedIds.toString();
		if oldSharedId = sharedId then {
			return;
		}
		string tableName := windowManager_com$softwareag$saep$SensorEvent.getTableName(allSharedIds);
		com.apama.memorystore.Schema schema := new com.apama.memorystore.Schema;
		string s;
		integer i:=0;
		dictionary<string, string> heartbeatsAdded := {};
		for s in allSharedIds {
			schema.fields.append("contents_"+s);
			schema.types.append("string");
			schema.fields.append("timestamps_"+s);
			schema.types.append("string");
			if(hasSourceTime[i]) then {
				schema.fields.append("srctimes_"+s);
				schema.types.append("string");
			}
			string heartbeat := sharedIdToHeartbeatType[s];
			if(heartbeat != "" and not heartbeatsAdded.hasKey(heartbeat)) then {
				schema.fields.append("heartbeatTime_"+heartbeat);
				schema.types.append("string");
				heartbeatsAdded[heartbeat] := heartbeat;
			}
			i:=i+1;
		}
		if(anyHaveSourceTimestamps) then {
			schema.fields.append("evalTime");
			schema.types.append("float");
		}
		// Prepare the table to hold the event window
		qLogger.instanceLog("Preparing table to store window contents: " + tableName, "DEBUG", false);
		integer id := store.prepare(tableName, schema);
		pendingPreparations.add(id,id);
		com.apama.memorystore.Finished f;
		on com.apama.memorystore.Finished(id=id):f {
			allTablePrepareSucceeded := allTablePrepareSucceeded and f.success;
			if f.success then {
				qLogger.instanceLog("Successfully prepared table to store window contents: " + tableName, "DEBUG", false);
			} else {
				qLogger.instanceLog("Asynchronous MemoryStore operation (Prepare window table data) failed: " + f.toString(), "FATAL", false);
			}
			if not allTablePrepareSucceeded then {
				if haveCreateParameterizedCompletedCallback then {
					try {
						// has to go into created state before we can move it into the failed state:
						createParameterizedCompletedCallback();
					} catch(com.apama.exceptions.Exception e) {
						// wil fail to update param table if it is not open, that's fine..
					}
				}
				shouldRespawn := false;
				die;
			}
			prepareFinished(true, id, callbackComplete);
		}
	}




	/** 
	 * Spawned to create a monitor that handles routing scenario service events.
	 */
	action talkToScenarioService() {
		isMasterMonitor := false; // the talkToScenarioService monitor is neither master nor an instance proxy:
		queryScenarioService.talkToScenarioService();
	}	

	/** 
	 * Spawned to create a monitor that handles instance proxies that enter the failed state.
	 */
	action failedQueryHandler() {
		isMasterMonitor := false; // the failedQueryHandler monitor is neither master nor an instance proxy:
		queryScenarioService.failedQueryHandler();
	}	

	/* Supplementary query scenario service actions block */


	/* Callback used to setup query scenario service. */
	action setupScenario() returns dictionary<string, sequence<string> > {
		dictionary<string, sequence<string> > s := new dictionary<string, sequence<string> >;
		// Handle request for Scenario data
		s["inputNames"] := [
		];
		s["inputTypes"] := [
		];
		s["inputDefaults"] := [
		];
		
		return s;
	}

	//End of supplementary query scenario service actions block

	boolean haveCreateParameterizedCompletedCallback;
	action<> createParameterizedCompletedCallback;

	/**
	* Run in the instance proxy on receipt of a request to create a new parameterized query instance. 
	* Sets specified parameter values and instance ID before creating tables for this parameterization,
	* spawning a worker to each context, and initializing a distributor.
	* Note we only request distributors if any parameterizations exist. (though of course at most one of
	* them will be 'live' at any one time -see __DistributionMgr)
	* Exception may be thrown from updateUserParameters and initCommon (to be caught by queryScenarioService) if value 
	* field sizes do not match, is parsing fails or if values used to evaluate expressions result in exceptions.
	*/
	action createParameterizedQueryInstance(sequence<string> parameterValues, string owner, action<> completedCallback) {
		//Set this to false so that any failures after spawning will not interpreted as being from the main monitor
		isMasterMonitor := false;
		isInstanceProxy := true;
		parameterizationOwner := owner;
		qLogger := queryScenarioService.getLogger(); // ensures the instance logger is using the correct Id
		updateUserParameters(parameterValues, true, true, initCommon);

		// Create an action and listener list for the chain of initialisation actions
		// Create a __TerminationMgr for the instance proxy, - in case the instance should terminate
		(new __TerminationMgr).init(terminateWorker, queryDefinitionName, queryScenarioService.instancePxyId);
		createParameterizedCompletedCallback := completedCallback;
		haveCreateParameterizedCompletedCallback := true;

		// Set necessary __PendingTimersMgr information
		timerMgr.setInstance(queryScenarioService.instancePxyId);
	}


	/**
	* Callback used to log the a request has been made to delete this parameterized instance.
	* Also ensure that this does not trigger a respawn upon termination.
	*/
	action prepareParameterizedQueryInstanceFinish(boolean logDeath) {	
		if logDeath then {
			if isInstanceProxy then {
				qLogger.instanceLog("Deleting instance", "INFO", false);
			} 
		}
		shouldRespawn := false;
		if isInstanceProxy and (not deleted) and initialised then {
			route __WindowManagerTableUsageChanged(-1, [sharedId_com$softwareag$saep$SensorEvent]);
		}
		deleted := true;
	}

	/**
	* Called immediately upon receiving query scenario service create or edit event. 
	* Exception will be thrown (to be caught by queryScenarioService) if value field sizes do not 
	* match, is parsing fails or if any of the within/retains expressions, within filters or waits
	* are invalid (syntacically or <= 0) - no try-catch blocks are used as queryScenarioService
	* caller will log error/stacktrace as appropriate.
	*/
	action updateUserParameters(sequence<string> parameterValues, boolean validate, boolean calledByCreate, action<> completeCallback) {
		if validate then {
			queryScenarioService.checkSizeOfParameters(parameterValues, calledByCreate);
		}
		sequence<string> old_sharedIds := [sharedId_com$softwareag$saep$SensorEvent];

		/** Sets "const" parameters used to reset locally mutable parameter variables, by 
		* parsing each parameter into __user (needed prior to (eg) _within_ initialisation).
		* Henceforth use the canonical form of the parameters (having been parsed).
		* Also handles update of query services' sequence of parameter values.
		*/
		sequence <string> paramValues := [];
		queryScenarioService.updateParameterValues(paramValues);

		if validate then {
			/* Expressions are validated here - exception can be thrown out of each catch-block, which will be caught by queryScenarioService */
			{
				queryScenarioService.validatingExpr("within clause \"5.0\" for input com$softwareag$saep$SensorEvent");
				float v := __user.__getWithin_com$softwareag$saep$SensorEvent();
				if v  <=  0.0 then {
					qLogger.requestFailed(calledByCreate, "Invalid within clause \"5.0\" (duration = " + v.toString() + ") for input com$softwareag$saep$SensorEvent. Cannot be less than or equal to zero.", getParametersString());
					queryScenarioService.failValidation(); 
				}
			} 

			initWindow_com$softwareag$saep$SensorEvent();

			initWindowTable(completeCallback);

			prepareFinished(false, 0, completeCallback); // may well not have any tables to prepare
		} else {
			if not isInstanceProxy then {
				if not calledByCreate then {
					 
					within_com$softwareag$saep$SensorEvent := __user.__getWithin_com$softwareag$saep$SensorEvent();  
					initWaits();
					initWithinFilters();
				}

				generateSharedId_com$softwareag$saep$SensorEvent();

				completeCallback();

				if not calledByCreate then {
					// must terminate the window managers before re-spawning
					windowManager_com$softwareag$saep$SensorEvent.terminate();
					// for the window manager's benefit, we handle Edit re-spawning and dieing - but we re-spawn from this mThread, and not via the respawn interface
					spawn workerMain(); // skip re-spawning the respawnListener, the old one should still be active.
					shouldRespawn := false;
					die;
				}
			} else {
				completeCallback();
			}

		}
		if isInstanceProxy then {
			route __WindowManagerTableUsageChanged(+1, [sharedId_com$softwareag$saep$SensorEvent]);
			if initialised then {
				route __WindowManagerTableUsageChanged(-1, old_sharedIds);
			}
		}
	}

	action getParametersString() returns string {
		return queryScenarioService.getParametersString(queryScenarioService.parameterValues, false);
	}


	/** 
	 * Called when any preparation has finished - will call initCommon if all preparations complete
	 */
	action prepareFinished(boolean removeId, integer id, action<> callbackComplete) {
		if removeId then {
			pendingPreparations.remove(id);
		}
		if pendingPreparations.size() = 0 then {
			callbackComplete();
		}
	}


 	/** 
	 * Called from the factory instance, when any tables have been prepared.  Only runs if no preparations left.
	 * Sets up the framework for handling multiple contexts. 
	 */
	action initCommon() {
		initWaits();
		initWithinFilters();
		initialised := true;
		if createdAtStartup then {
			// if this was created during startup, this is
			// either a non-parameterized instance or a
			// parameterized instance on a cluster, we are
			// only ready now:
			send __QueryReady(queryScenarioService.name) to scenarioServiceCtx;
		}

		// Handle changes to the set of worker-contexts  - causes workers to be spawned
		(new __ContextMgr).init( onNewContexts );

		// Initialise each __DistributionMgr  
		dist_com$softwareag$saep$SensorEvent.init(com.softwareag.saep.SensorEvent.getName(), distribute_com$softwareag$saep$SensorEvent);
		dist___RestartQueryTimer.init(__RestartQueryTimer.getName(), distribute___RestartQueryTimer);
		if haveCreateParameterizedCompletedCallback then {
			createParameterizedCompletedCallback();
		}

	}

	/** Executed before this instance dies. */
  	action ondie() {
  		// Clean-up!
		// If other queries share these event inputs, and if this query is currently
		// in charge of distribution, then a new distributor needs electing
		dist_com$softwareag$saep$SensorEvent.terminate();
		dist___RestartQueryTimer.terminate();		
		windowManager_com$softwareag$saep$SensorEvent.terminate();
		if isInstanceProxy and not deleted then {
			route __FailedQueryInstance(queryScenarioService.name, queryScenarioService.instancePxyId, queryScenarioService.parameterValues, parameterizationOwner);
			send __RemoveInstance(queryDefinitionName, queryScenarioService.instancePxyId) to workers.ctxs;
			if initialised then {
				route __WindowManagerTableUsageChanged(-1, [sharedId_com$softwareag$saep$SensorEvent]);
			}
		}

		if shouldTerminateWorkers then {
			log "Query log: Exception thrown when processing query, terminating all workers" at FATAL;
			send __RemoveInstance(queryDefinitionName, queryScenarioService.instancePxyId) to hubCtx;
		} else if shouldRespawn then { 
			// respawn in case aggregate function threw exception

			route __Respawn(queryScenarioService.instancePxyId); 
		}

		if not shouldTerminateWorkers then {
			// we should not lose any timer state we have, so send all 
			// state about timers to the hub context, which will
			// re-distribute it to the workers (possibly back to us, 
			// but possibly not; whatever it will do the right thing).
			timerMgr.broadcastTimers();
		}

		if isMasterMonitor then {
			// Ref-counting remove to HubContextManager
			(new __HubContextRemove).process(queryDefinitionName , mainCtx);
			// Alert query scenario service that the entire definition is gone - called once per definition.
			// Intentionally called here instead of in onunload to as to have access to the master monitor member values.
			queryScenarioService.unload();
		} else if isInstanceProxy then {
			timerMgr.removeAll();
		}
	}


	action distribute_com$softwareag$saep$SensorEvent() {
		com.softwareag.saep.SensorEvent e;
		on all com.softwareag.saep.SensorEvent(): e { 			 
			forward_com$softwareag$saep$SensorEvent(e, nextContext());
		}
	}

	action forward_com$softwareag$saep$SensorEvent(com.softwareag.saep.SensorEvent e, context ctx) {
		
	  	enqueue e to ctx;
	}

	action distribute___RestartQueryTimer() {
		__RestartQueryTimer e;
		on all __RestartQueryTimer(): e { 			 
			forward___RestartQueryTimer(e, nextContext());
		}
	}

	action forward___RestartQueryTimer(__RestartQueryTimer e, context ctx) {
		
	  	enqueue e to ctx;
	}


	 
	/** Spawned on each new worker instance */
	action newWorker() {
		isMasterMonitor := false;
		isInstanceProxy := false;


		// set up respawn listener for new worker in case of exception thrown by aggregate function
		spawn respawnListener();
		workerMain();
	}

	action workerMain() {
		qryId := integer.getUnique();

		// starts the query scenario service listeners as these are not active afer being spawned - only if we have parameters
		queryScenarioService.startWorkerListeners(context.current().getId() = workers.gc_ctx.getId());




		dictionary<string,string> sharedIdToHeartbeatType := {
			sharedId_com$softwareag$saep$SensorEvent : ""
		};

		// Set-up a listener for each event inputs
		initWindowListener_com$softwareag$saep$SensorEvent(sharedIdToHeartbeatType);
	
		// Create a __TerminationMgr for the worker instance, so that the context can be discarded 
		terminationMgr := new __TerminationMgr;
		terminationMgr.init(terminateWorker, queryDefinitionName, queryScenarioService.instancePxyId);
		
		// and restart any timers we get notified of:
		__RestartQueryTimer restartTimer;
		on all __RestartQueryTimer(queryName=queryScenarioService.name, instanceId=queryScenarioService.instancePxyId):restartTimer {
			reEvaluateInputs(restartTimer);
		}
	}


	/** respawn listener set up for every instance */
	action respawnListener() {
		on __Respawn(instanceId = queryScenarioService.instancePxyId) {
			qLogger.instanceLog("Exception thrown from aggregate function(s), respawning worker to current context", "WARN", false);

			shouldRespawn := false;
			spawn newWorker();
			die;
		}

		// Create a __TerminationMgr for the worker instance, so that the context can be discarded 
		terminationMgr := new __TerminationMgr;
		terminationMgr.init(terminateWorker, queryDefinitionName, queryScenarioService.instancePxyId);
	}


	/* All input definition and maintenance code */
	/* ========================================== */	

	/* Initialise individual event input inputs */

	/** Size of the 'within' window of com.softwareag.saep.SensorEvent */
	float within_com$softwareag$saep$SensorEvent;

	string sharedId_com$softwareag$saep$SensorEvent;
	__WindowManager windowManager_com$softwareag$saep$SensorEvent;

	action generateSharedId_com$softwareag$saep$SensorEvent() {
		// set up a listener as a template:
		listener l:=__user.__startListener_com$softwareag$saep$SensorEvent();
		sharedId_com$softwareag$saep$SensorEvent := l.serialise() + "-" + 
			"sensorId";
		l.quit();
	}

	/*
	 * Initialise the window 'com.softwareag.saep.SensorEvent' for events of type com.softwareag.saep.SensorEvent
	 */
	action initWindow_com$softwareag$saep$SensorEvent() {
		generateSharedId_com$softwareag$saep$SensorEvent();
	}

	/* Code to extract the key from the input event **/
	action __getRowKey_com$softwareag$saep$SensorEvent(com.softwareag.saep.SensorEvent e) returns string {
		sequence<string> keyFields := [];
		keyFields.append(e.sensorId.toString()); 

		/**
		 * This beautiful bit of unreachable code is designed to
		 * provoke typechecking errors for incompatibilities between
		 * the types of key elements. (and also with unique). It does
		 * this by going through all the key elements of this input's
		 * event type and trying to assign them to a dummy event of
		 * the first input, and vice versa (both directions in order
		 * to find any constant fields being used as keys) 
		 */
		if(false) then {
			com.softwareag.saep.SensorEvent specimen_e := new com.softwareag.saep.SensorEvent;
			com.softwareag.saep.SensorEvent specimen := new com.softwareag.saep.SensorEvent;
			// Split up so that we only map errors to do with the assignment itself, rather than getting the field out of the specimen
			specimen.sensorId

				:= specimen_e.sensorId; 

			// Split up so that we only map errors to do with the assignment itself, rather than getting the field out of the specimen
			specimen_e.sensorId

				:= specimen.sensorId; 


		}
		return keyFields.toString();
	}





	action handle_com$softwareag$saep$SensorEvent(action<string, boolean, float> __onEvent, integer retryCount, com.softwareag.saep.SensorEvent latest) {
		try {
			latest_com$softwareag$saep$SensorEvent := latest;
			float srcTime := currentTime;
			__onEvent( __getRowKey_com$softwareag$saep$SensorEvent( latest), false, srcTime);

		} catch (com.apama.exceptions.Exception __e) {
			if (retryCount > 0) then {
				qLogger.instanceLog("Caught exception (retries="+retryCount.toString()+") "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString()+" - "+__e.getStackTrace().toString(), "ERROR", false);
				terminationMgr.incrOutstandingRetries();
				on wait(1.0) {
					handle_com$softwareag$saep$SensorEvent(__onEvent, retryCount-1, latest);
					terminationMgr.decrOutstandingRetries();
				}
				return;
			} else {
				qLogger.instanceLog("Terminating query instance. Exception "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString(), "FATAL", false);
				shouldTerminateWorkers := true;
				die;
			}
		}
	}

	com.softwareag.saep.SensorEvent latest_com$softwareag$saep$SensorEvent;

	action initWindowListener_com$softwareag$saep$SensorEvent(dictionary<string, string> sharedIdToHeartbeatType) {
		__WindowLength length := __WindowLength(-1.0, -1, 0.0, 0.0);
		calculateWithin_com$softwareag$saep$SensorEvent();
		length.withinDuration := within_com$softwareag$saep$SensorEvent;

		__user.__handle_com$softwareag$saep$SensorEvent := handle_com$softwareag$saep$SensorEvent;
		dictionary<string, boolean> allSharedIds_and_hasSourceTime := {sharedId_com$softwareag$saep$SensorEvent:false};
		sequence<string> allSharedIds_and_hasSourceTime_keys := allSharedIds_and_hasSourceTime.keys();
		allSharedIds_and_hasSourceTime_keys.sort();
		sequence<string> allSharedIds := new sequence<string>;
		sequence<boolean> hasSourceTime := new sequence<boolean>;
		string sharedId_key;
		for sharedId_key in allSharedIds_and_hasSourceTime_keys {
			allSharedIds.append(sharedId_key);
			hasSourceTime.append(allSharedIds_and_hasSourceTime[sharedId_key]);
		}

		windowManager_com$softwareag$saep$SensorEvent.init(
			sharedId_com$softwareag$saep$SensorEvent,
			qryId,
			allSharedIds,
			length,
			__user.__listenFor_com$softwareag$saep$SensorEvent,
			calculateInputDefinitiveTime_com$softwareag$saep$SensorEvent,
			maintainWindow_com$softwareag$saep$SensorEvent,
			store,
			hubCtx,
			context.current().getId() = workers.gc_ctx.getId(),
			hasSourceTime,
			sharedIdToHeartbeatType
		);

		__StoredSnapshot ss;
		on all __StoredSnapshot(sharedId = sharedId_com$softwareag$saep$SensorEvent, managerId = windowManager_com$softwareag$saep$SensorEvent.managerId):ss {
			gotSnapshot(ss);
		}		
	}

	/** __WindowManager._calculateInputDefinitiveTime_cb */
	action calculateInputDefinitiveTime_com$softwareag$saep$SensorEvent(__StoredEventWindow sew, float maxTime, float maxWait) returns float {
		return calculateInputDefinitiveTime(sew.timestamps, sew.timestamps, getCurrentTime(maxTime, false), maxWait, 
				sew.heartbeatTime, new dictionary<string, __DelayedOutOfOrderTime>, "", false);
	}

	action maintainWindow_parse_com$softwareag$saep$SensorEvent(string str) returns sequence<com.softwareag.saep.SensorEvent> {
		return sequence<com.softwareag.saep.SensorEvent>.parse(str);
	}


	/** __WindowManager._maintainWindow_cb 
	* definitiveTime is the minimum of the definitive times of the other
	*  query inputs; this input needs to add its latest event (if addLatest
	*  is set), then calculate this input's definitive time, to obtain the
	*  new query definitive time.
	*  Returns the details of latest event to be received by the correlator
	*  (the event being processed here, i.e. latest_com$softwareag$saep$SensorEvent)
	*/

	action maintainWindow_com$softwareag$saep$SensorEvent(__StoredEventWindow sew, __WindowLength length, float minWaitTime, float maxTime, float definitiveTime, boolean addLatest, float srcTime, dictionary<string, __StoredEventWindow> windows) returns __LatestEvent {
		sequence<com.softwareag.saep.SensorEvent> seq;
		if(sew.seq_of_evts = "") then {
			seq := new sequence<com.softwareag.saep.SensorEvent>;
		} else {
			seq := maintainWindow_parse_com$softwareag$saep$SensorEvent(sew.seq_of_evts);
		}

		float srcTimeUsed := float.NAN;
		float now := getCurrentTime(maxTime, true);

		float prevDefinitiveTime := float.min(definitiveTime, calculateInputDefinitiveTime_com$softwareag$saep$SensorEvent(sew, now, length.waitTime));

		if(addLatest) then {
			seq.append(latest_com$softwareag$saep$SensorEvent);
			sew.timestamps.append(now);
			srcTimeUsed := now;		definitiveTime := float.min(definitiveTime, calculateInputDefinitiveTime_com$softwareag$saep$SensorEvent(sew, now, length.waitTime));

		} else {
			definitiveTime := prevDefinitiveTime;
		}


		// At least one, possibly both, of length.retainDuration and
		// withinDuration are non-negative (i.e. set).  We ignore those
		// that are not set, and if both are set, then we take the union
		// - which is the minimum of the 'oversize' count.
		integer oversize := seq.size();

		// apply retain restriction if set
		if (length.retainDuration >= 0) then {
			oversize := seq.size() - length.retainDuration;	}

		// apply within restriction if set:
		if( length.withinDuration >= 0.0 ) then {
			integer binSearchIndex := -1;
			float windowEnd := (definitiveTime / __TS.GRANULARITY).floor().toFloat() * __TS.GRANULARITY;		windowEnd := windowEnd - length.withinDuration;
			// And exclude things that are right on the edge, even if they've been bumped over by __TS.TIEBREAKER
			windowEnd := windowEnd + (__TS.GRANULARITY - __TS.TIEBREAKER);
			sequence<float> evtTimestamps := sew.timestamps;
			{
				integer oldest := 0;
				integer youngest := evtTimestamps.size();

				while oldest < youngest {
							
					integer midpoint := oldest + ((youngest - oldest) / 2);
					if evtTimestamps[midpoint] <= windowEnd then {
						oldest := midpoint + 1;
					} else {
						youngest := midpoint;	
					}	
				}
				if oldest = youngest and (oldest >= evtTimestamps.size() or  evtTimestamps[oldest] > windowEnd) then {
					binSearchIndex := oldest;
				}
			}
			if binSearchIndex < oversize then {
				oversize := binSearchIndex;
			}
		}

		// this can be negative, but the while loop will only remove
		// anything if it is > 0:
		while(oversize > 0) {
			seq.remove(0);
			sew.timestamps.remove(0);
			oversize := oversize - 1;
		}

		sew.seq_of_evts := seq.toString();
		return __LatestEvent(now, srcTimeUsed);
	}

	/*
	 * Populate the entry in definitiveTimes with the definitive time for this input.
	 * Only count events with (correlator-realm) timestamps up to uptoCorrelatorTime.
	 */
	action populateInputDefinitiveTime_com$softwareag$saep$SensorEvent(__StoredSnapshot ss, dictionary<string, float> definitiveTimes, boolean isPrevEval, dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders) {
		try {
			float uptoCorrelatorTime := ss.previousEvalTimestamp;
			float correlatorEvalTime := ss.previousEvalTimestamp;
			if not isPrevEval then {
				uptoCorrelatorTime := float.INFINITY;
				correlatorEvalTime := getCurrentTime(ss.latestEvent.processedTimestamp, false);
			}

			__StoredEventWindow sew := ss.allEvts[sharedId_com$softwareag$saep$SensorEvent];
			sequence<float> timestamps := [];
			sequence<float> correlatorTimestamps := [];
			integer i:=0;

			timestamps := sew.timestamps;
			correlatorTimestamps := sew.timestamps;

			// Calculate input definitive time based non-discarded events in window
			float heartbeat;
			if isPrevEval then {
				heartbeat := sew.previousHeartbeatTime;
			} else {
				heartbeat := sew.heartbeatTime;
			}
			definitiveTimes["com$softwareag$saep$SensorEvent"] := calculateInputDefinitiveTime(timestamps, correlatorTimestamps, correlatorEvalTime, 
	0.0, heartbeat, delayedOutOfOrders,
					"com$softwareag$saep$SensorEvent", false);
		} catch(com.apama.exceptions.Exception exc) {
			// Probably due to the entry not being there - treat as empty:
			return;
		}
	}

	/** Returns window relevant to this query instance, taking into considerations any retain clauses */
	action getWindow_com$softwareag$saep$SensorEvent(__StoredSnapshot ss) returns sequence<com.softwareag.saep.SensorEvent> {
		try {
			__StoredEventWindow sew := ss.allEvts[sharedId_com$softwareag$saep$SensorEvent];
			sequence<float> evtTimestamps := sew.timestamps;
			sequence<com.softwareag.saep.SensorEvent> contents;
			if sew.seq_of_evts = "" then {
				contents := new sequence<com.softwareag.saep.SensorEvent>;
			} else {
				contents := sequence<com.softwareag.saep.SensorEvent>.parse(sew.seq_of_evts);
			}

			integer i:=0;
			com.softwareag.saep.SensorEvent elem;
			while i < contents.size() {
				elem := contents[i];
				elem.setTimeDeep(evtTimestamps[i]);
				i := i+1;		}

			return contents;
		} catch(com.apama.exceptions.Exception exc) {
			// Probably due to the entry not being there - treat as empty:
			return new sequence<com.softwareag.saep.SensorEvent>;
		}
	}

	/** 
	 * Trims the window (sequence of events) so those later than the definitive time are not considered yet 
	 * and take into considerations retain/within clauses.
	 * This MUST be called after getWindow_com$softwareag$saep$SensorEvent and calculateQueryDefinitiveTime.
	 */
	action scopeWindowToDefinitiveTime_com$softwareag$saep$SensorEvent(sequence<com.softwareag.saep.SensorEvent> contents, float definitiveTime, __StoredSnapshot ss, boolean isSpeculating, float maxDefinitiveTime) {
		if contents.size() = 0 then {
			return;
		}

		// Determines the index BELOW which the window is accurate up to the definitive time (hence numEvtsBeforeDefinitiveTime
		// corresponds to the total number of events that can be used).
		integer numEvtsBeforeDefinitiveTime := binSearch_com$softwareag$saep$SensorEvent(definitiveTime, contents);
		if numEvtsBeforeDefinitiveTime = 0 then {
			contents.clear();
		} else if numEvtsBeforeDefinitiveTime > 0 then {
			contents.setSize(numEvtsBeforeDefinitiveTime); // truncate any events that are too recent (> dt)
		}

		// if we are speculating, we need to reach as far back as within the current max definitive time (DT will be infinity)
		if isSpeculating then {
			definitiveTime := maxDefinitiveTime;
		}
		// Trim window based on within expression
		// The end of the window has to be aligned across actual timestamps (__TS.GRANULARITY), ignoring __TS.TIEBREAKER
		definitiveTime := (definitiveTime / __TS.GRANULARITY).floor().toFloat() * __TS.GRANULARITY;
		float within_windowEnd := definitiveTime - (within_com$softwareag$saep$SensorEvent);
		// And exclude things that are right on the edge, even if they've been bumped over by __TS.TIEBREAKER
		within_windowEnd := within_windowEnd + (__TS.GRANULARITY - __TS.TIEBREAKER);
		integer oldestInWindow := binSearch_com$softwareag$saep$SensorEvent(within_windowEnd, contents);
		if oldestInWindow < 0 then {
			contents.clear();
		} else if oldestInWindow > 0 then {
			integer oversize := oldestInWindow; 
			//TODO Story 30128 - Think about how best to optimize this. 
			while(oversize > 0)  {
				contents.remove(0);
				oversize := oversize - 1;
			}
		}

		if contents.size() > 0 then {
			// Updates statistics
			if ss.sharedId = sharedId_com$softwareag$saep$SensorEvent then {
				queryScenarioService.reportWindowUpdate("com.softwareag.saep.SensorEvent", contents.size(), ss.key);
			}
		}
	}

	/* Calculate, validate and save 'within' duration */
	action calculateWithin_com$softwareag$saep$SensorEvent() {
		 
		within_com$softwareag$saep$SensorEvent := __user.__getWithin_com$softwareag$saep$SensorEvent();  

	}
	/* 
	 * Get index of oldest element whose timestamp is more recent than windowEnd, or -1 if contents is 
	 * empty or all elements are older than or equal to windowEnd. Assumes contents is sorted by timestamp from oldest 
	 * to most recent. 
	 */
	action binSearch_com$softwareag$saep$SensorEvent(float windowEnd, sequence<com.softwareag.saep.SensorEvent> contents) returns integer {
		if contents.size() <=0 or contents[contents.size() - 1].getTime() < windowEnd then {
			return -1; 
		}

		integer binSearchIndex := -1;
		{
			integer oldest := 0;
			integer youngest := contents.size();

			while oldest < youngest {
						
				integer midpoint := oldest + ((youngest - oldest) / 2);
				if contents[midpoint].getTime() <= windowEnd then {
					oldest := midpoint + 1;
				} else {
					youngest := midpoint;	
				}	
			}
			if oldest = youngest and (oldest >= contents.size() or  contents[oldest].getTime() > windowEnd) then {
				binSearchIndex := oldest;
			}
		}

		return binSearchIndex;
	}

	/**
	 * This is the form that an element within the window of com.softwareag.saep.SensorEvent takes in the memory store. It contains the event and its
	 * timestamp, as stringifying and parsing events ignores the event's getTime(), so it has to be kept in a separate field alongside.
	 */
	event __Stored_com$softwareag$saep$SensorEvent {
		com.softwareag.saep.SensorEvent value;
		float timestamp;
	}

	/**
	 * An indexable used to identify uniqueness of input as per with-unique clause
	 */


	 

	/* All pattern definition and evaluation code */
	/* ========================================== */


	/** An index into each of the types.
	 * 
	 * Iterates the window contents across all types on demand.
	 */
	event __WindowsIterator {

		// current iteration state:
		string currentType;	
		integer currentIndex;
		float currentTimestamp;
		/** Contents of each window */
		wildcard sequence<com.softwareag.saep.SensorEvent> window_com$softwareag$saep$SensorEvent;
		/** Index into window contents where this iterator is currently pointing */
		wildcard integer idx_com$softwareag$saep$SensorEvent; 

		sequence<string> types;
		
		/* Determine if we are evaluating against time or event. If true then return the 
		   current event type as empty but time of event will be available*/
		boolean timeMode;
		
		/* Source timestamp (which is known to be unique) of the latest event received by correlator*/
		float timestampOfLatestReceived;

		/* Window index into at which the current event is located. Only valid if isDone() returns 
			false. Use getType() to determine the type of the element to which the index applies.  */ 
		action getIndex() returns integer {
			return currentIndex;
		}

		action getType() returns string {
			if timeMode then {
				return "";
			}
			return currentType;
		}

		/* Get the stringified form of the event at the current index for the current type */
		action getStringified() returns string {
			 
			/* Switch based on type of input */
			return window_com$softwareag$saep$SensorEvent[idx_com$softwareag$saep$SensorEvent].toString();
		}

		action getCurrentTimestamp() returns float {
			return currentTimestamp;
		}

		/* Initialize the iterator. On completion the most recent event in the combined window
			can be retrieved using getIndex() and getType().
			@param endTime - an optional (ignored if NaN) timestamp to append to the end of the windows
		 */
		action init(float endTime) {
			types := ["com$softwareag$saep$SensorEvent"];
			types.reverse();
			idx_com$softwareag$saep$SensorEvent := window_com$softwareag$saep$SensorEvent.size() - 1;
			currentType := types[0];
			currentTimestamp := float.INFINITY;
			idx_com$softwareag$saep$SensorEvent := idx_com$softwareag$saep$SensorEvent + 1;
			if(not endTime.isNaN()) then {
				currentTimestamp := endTime;
				currentType := "";
				currentIndex := getIndexForType(types[0]);
			} else {
				next();
			}
		}

		/* Increment the iterator to point to the next event in the combined window. If there are no
			more events then isDone() will return true. Otherwise, use getIndex() and getType() to
			access the event. */
		action next() {
			if(currentType = "") then {
				currentType := types[0];
			}
			 
			/* Switch based on type of input */
			idx_com$softwareag$saep$SensorEvent := idx_com$softwareag$saep$SensorEvent - 1;
			string nextPrevType:="";
			float nextPrevTime:=-float.INFINITY;
			integer nextIndex:= -1;

			string type;
			for type in types {
				float evtTime:=getTimestamp(type);

				// assert (t >= currentTimestamp);
				if evtTime > nextPrevTime then {
					nextPrevTime := evtTime;
					nextPrevType := type;
					nextIndex:=getIndexForType(type);
				}
			}
			currentTimestamp := nextPrevTime;
			currentType := nextPrevType;
			currentIndex := nextIndex;
		}

		action isLatestReceived() returns boolean {
			return timestampOfLatestReceived = currentTimestamp;
		}

		action isDone() returns boolean {
			return currentIndex = -1;
		}

		action getTimestamp(string type) returns float {
			 
			/* Switch based on type of input */
			if idx_com$softwareag$saep$SensorEvent < 0 then {
				return -float.INFINITY;
			} else {
				return window_com$softwareag$saep$SensorEvent[idx_com$softwareag$saep$SensorEvent].getTime();
			}
		}

		action getIndexForType(string type) returns integer {
			 
			/* Switch based on type of input */
			return idx_com$softwareag$saep$SensorEvent;
		}
		
		action setTimeMode(boolean isTimeMode) {
			timeMode := isTimeMode;
		}
	}


	/** Internal event for holding evaluation state for a single find block */
	event __EvaluationState {

		// the user object (contains all user defined expressions/actions)
		__ElasticQueryUserCode __user;

		// Query scenario service event
		__QueryScenarioService queryScenarioService;

		// current index into the merged ordered window:
		__WindowsIterator inputs;

		// the current potential matchsets:
		dictionary<integer, __MatchSet> matchSets;
		
		// Matchsets spawned from the current matchset:
		sequence<integer> addedMatchsets;

		// whether we are matching the 'current' or latest event:
		boolean matchingCurrentEvent;
		
		// how many times we have consumed (coassigned) any events:
		integer haveConsumed;
		
		// the most recent matchset id
		integer mostRecentMatchSet;

		// whether to trigger even if the latest event is not in a matchset
		boolean findAllMatches;


		// duration for within filters (if any)

		//wait durations (if any)

		// The maximum time we really have (not just this evaluation)
		float maxDefinitiveTime;	

		// The timestamp of previously evaluated event
		float previousEventTimestamp;
		/* Effective timestamp of current event. Currently used by within filter. Initially 
		 * equal to the time of current event. Later it is set to the startTime of wait 
		 * interval when wait gets consumed. This ensures that within node evaluates 
		 * properly for event outside of wait interval as wait pattern causes whole 
		 * pattern to be evaluated for event outside wait interval.
		 * */
		float effectiveEventTimestamp;
		// value of the partition key for which evaluation is being done
		string key;
		// denote that pattern is being evaluated on expiry of some future wait
		boolean evalOnWaitExpiry;
		// If a wait evaluate while evalFutureTimer is true then wait is future wait
		boolean evalFutureTimer;
		// start time of the expired future wait
		float expiredWaitStartTime;
		// action to re-evaluate pattern on expirey of future wait
		action<__RestartQueryTimer> reEvaluateInputsAction;

		/** Evaluate a find pattern, calling __ElasticQueryUserCode.__findAction on a match
		  *
		  * Walks the window contents, evaluating the pattern using
		  * each of a set of MatchSets.
		  * Calls the __ElasticQueryUserCode.__findAction if a top level MatchSet exists
		  * which meets all of the where clauses and constraints
		  */
		action patternTrigger(float timeAtEndOfWindow, dictionary<string, float> inputDefinitiveTimes, dictionary<string, float> inputWaitTimes, boolean isSpeculating, dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders) {
			///// Initialise state
			inputs.init(timeAtEndOfWindow);
			addInitialMatchSet();

			previousEventTimestamp := float.INFINITY;
			// ids of MatchSets that are final
			dictionary<integer, integer> finalMatchSetIds := new dictionary<integer, integer>;
			// in case of evalOnWaitExpiry, matchingCurrentEvent will get set to true
			// once future wait gets consumed.
			// when speculating matchingCurrentEvent only gets set to true if processing
			// the most recently received event.
			if not evalOnWaitExpiry then {
				matchingCurrentEvent := true;
			}
				
			boolean inputsDone := false;
			// first time pattern will be evaluated against no event to find future waits
			evalFutureTimer := true; 
			///// walk the window
			// for each event (until we have a final matchset, or no matchsets left)
			// we also evaluate pattern for window with no event and time -float.INFINITY
			while (not inputsDone) and (matchSets.size() > 0) {
				if isSpeculating then {
					matchingCurrentEvent := inputs.isLatestReceived();
				}
				__MatchSet matchSet;
				// for each matchset (present at the beginning
				// of processing this event - doesn't evaluate
				// matchsets added during this loop):
				for matchSet in matchSets.values() {
					///// evaluate the pattern twice:
					// once against time only then against event
					processPattern(matchSet, finalMatchSetIds, true);
					processPattern(matchSet, finalMatchSetIds, false);
				}

				evalFutureTimer := false;
				if (inputs.isDone()) then {
					inputsDone := true;
				}

				previousEventTimestamp := inputs.getCurrentTimestamp();
				inputs.next();
				// for the current/ latest event only: if it
				// is not coassigned, we abort the pattern
				// evaluation:
				if matchingCurrentEvent and haveConsumed = 0 and not findAllMatches then {
					return;
				}
				matchingCurrentEvent := false;
			}

			if finalMatchSetIds.size() > 0 then {
				if isSpeculating then {
					// determine when any matches triggered by the event most recently received by the correlator
					// will be less-than or equal to definitive time then re-evaluate at this time if it is currently
					// greater-than definitive time i.e. determine how long to wait for if necessary
					// (although explained using definitive time the actual calculation is in terms of real time)
					__MatchSet ms;
					integer fmsId;
					// The time at which this match occurred/will occur
					float ct := currentTime;
					for fmsId in finalMatchSetIds.keys() {
						ms := matchSets[fmsId];
						if ms.containsCurrent <= 0 then {
							continue;
						}

						float maxTS := ms.mostRecentTime();
						float speculativeWaitExpiryTime := ct;
						string eType;
						for eType in inputDefinitiveTimes.keys() {
							if inputDefinitiveTimes[eType] < maxTS then {
								__DelayedOutOfOrderTime delayed := delayedOutOfOrders.getOrDefault(eType);
								if delayed.maxInputEventTimestamp >= maxTS then {
									speculativeWaitExpiryTime := float.max(speculativeWaitExpiryTime, float.min(maxTS + inputWaitTimes.getOr(eType, 0.0), delayed.correlatorTimeBecomesDefinitive));
								} else {
									speculativeWaitExpiryTime := float.max(speculativeWaitExpiryTime, maxTS + inputWaitTimes.getOr(eType, 0.0));
								}
							}
						}

						if speculativeWaitExpiryTime > ct then {
							// wait for time+epsilon to avoid floating-point rounding errors, specifically the wait being slightly less than it should be
							speculativeWaitExpiryTime := speculativeWaitExpiryTime.nextafter(float.INFINITY);
							reEvaluateInputsAction(__RestartQueryTimer(queryScenarioService.name, queryScenarioService.instancePxyId, key, ct, speculativeWaitExpiryTime, false));
						}
					}

					return;
				}

				integer id:= mostRecentMatchSet;
				sequence<__MatchSet> allMatches := new sequence<__MatchSet>;
				boolean anyHaveCurrent := false;
				boolean anyFireNow := false;
				while(id != -1) {
					__MatchSet matchSet := matchSets[id];
					// check that there are no pending timers
					if finalMatchSetIds.hasKey(id) then {
						if matchSet.containsCurrent > 0 then {
							anyFireNow := processPendingWaitTimers(matchSet, inputWaitTimes) or anyFireNow;
							anyHaveCurrent := true;
						}

						allMatches.append(matchSet);
					}
					id := matchSet.next;
				}

				// if no new matchsets (i.e. with the current event), then suppress generating output:
				if not findAllMatches and ((not anyHaveCurrent) or (not anyFireNow)) then {
					return;
				}

				allMatches.reverse();
				__user.__processAggregates(allMatches);
				return; 

			}
		}

		/** Process pattern against time only or against event*/
		action processPattern(__MatchSet matchSet, dictionary<integer, integer> finalMatchSetIds, boolean withTime) {
			inputs.setTimeMode(withTime);
			
			effectiveEventTimestamp := inputs.getCurrentTimestamp();
			if matchSets.hasKey(matchSet.id) and not finalMatchSetIds.hasKey(matchSet.id) and evaluatePattern(matchSet) then {
				// we have a complete potential matchset.  If it matches the where clause, ...
				if pattern_node0_where(matchSet) then {
					// .. then we have a final matchset
					finalMatchSetIds.add(matchSet.id, matchSet.id);
				} else {
					discard(matchSet);
				}
			}
		}
		
		/** Process pending wait timers. If there are atleast one pending timer
		* which need to be evaluated in future then it returns false. */
		action processPendingWaitTimers(__MatchSet matchSet, dictionary<string,float> inputWaitTimes) returns boolean {
			// there will not be any pending timers when evaluating against
			// wait expiry because we are evaluating after all required waits are expired
			if evalOnWaitExpiry then {
				return true;
			}
			boolean noPendingTimer := true;
			float waitExpiryTime := -float.INFINITY;
			float waitStartTime := -float.INFINITY;
			string actionName := "";
			if not noPendingTimer then {
				// the waitStartTime is supplied so that wait
				// expression will evaluate to true when
				// evaluation reaches to that event
				reEvaluateInputsAction(__RestartQueryTimer(queryScenarioService.name, queryScenarioService.instancePxyId, key, waitStartTime, waitExpiryTime, true));
			}

			return noPendingTimer;
		}

		/** read current window content and corresponding event timestamps */
		action currentWindowContents(boolean forLogging) returns sequence<string> {
			inputs.init(float.NAN);
			sequence<string> contentsAndTimestamps := new sequence<string>;
			sequence<string> windowDump:=new sequence<string>;
			sequence<string> timestamps:=new sequence<string>;
			while(not inputs.isDone()) {
				windowDump.insert(inputs.getStringified(),0);
				decimal actualTimestamp := (inputs.getCurrentTimestamp().toDecimal() / __TS.GRANULARITY.toDecimal()).round().toDecimal() * __TS.GRANULARITY.toDecimal();
				timestamps.insert(actualTimestamp.toFloat().toString(), 0);
				inputs.next();
			}
			if forLogging then {
				contentsAndTimestamps.append("Groups window contents: ["+(",".join(windowDump))+"]");
				contentsAndTimestamps.append("Groups window timestamps: ["+(",".join(timestamps))+"]");
			} else {
				contentsAndTimestamps.append("["+(",".join(windowDump))+"]");
				contentsAndTimestamps.append("["+(",".join(timestamps))+"]");
			}

			return contentsAndTimestamps;
		}

		constant integer EVAL_MATCHEVENTS := 1;
		constant integer EVAL_EVAL := 2;
		constant integer EVAL_CONDITIONS := 3;

		/** Evaluate the entire pattern (including withouts, withins, etc) */
		action evaluatePattern(__MatchSet matchSet) returns boolean {
			addedMatchsets:= new sequence<integer>;
			boolean prev_has_s1 := matchSet.has_s1;
			boolean p := pattern_node_0(matchSet, EVAL_MATCHEVENTS);
			p := pattern_node_0(matchSet, EVAL_EVAL);
			boolean p2 := pattern_node_0(matchSet, EVAL_CONDITIONS);
			p := p and p2;
			integer msId;
			while addedMatchsets.size() > 0 {
				sequence<integer> prevAdded := addedMatchsets;
				addedMatchsets := new sequence<integer>;
				for msId in prevAdded {
					if matchSets.hasKey(msId) then {
						matchSet := matchSets[msId];
						boolean q := pattern_node_0(matchSet, EVAL_EVAL);
						boolean q2 := pattern_node_0(matchSet, EVAL_CONDITIONS);
						if q or q2 then {
							__user.__qLogger.instanceLog("Unexpectedly evaluated a spawned matchset to true", "ERROR", false);
						}
					}
				}
			}
			return p;
		}

		/* Start of evaluation actions for each node in the pattern */
		action pattern_node0_where(__MatchSet matchSet) returns boolean {

			// what positive where clauses can we now evaluate?
			// what without where clauses can we now evaluate?

			// do any withouts invalidate this matchset?

			return true;
		}

		// utility methods for managing MatchSets:
		/** Add the initial matchset. */
		action addInitialMatchSet() {
			__MatchSet initial := new __MatchSet;
			initial.init();
			initial.next := -1;
			initial.prev := -1;
			mostRecentMatchSet := initial.id;
			matchSets.add(initial.id, initial);
		}

		/** Find the most recent matchset that is in the supplied set */
		action findMostRecentIn(dictionary<integer, integer> set) returns integer {
			integer id:= mostRecentMatchSet;
			while (id != -1 and not set.hasKey(id)) {
				id := matchSets[id].next;
			}
			return id;
		}

		/** Add a match set */
		action addMatchSetAfter(__MatchSet prior) returns __MatchSet {
			if(not matchSets.hasKey(prior.id)) then {
				return prior;
			}
			__MatchSet newms := prior.clone();
			newms.init();
			newms.prev := prior.id;
			newms.next := prior.next;
			prior.next := newms.id;
			if(newms.next != -1) then {
				matchSets[newms.next].prev := newms.id;
			}
			matchSets.add(newms.id, newms);
			addedMatchsets.append(newms.id);
			return newms;
		}

		/** discard a match set */
		action discard(__MatchSet matchSet) {
			if matchSets.hasKey(matchSet.id) then {
				// maintain linked list:
				if(matchSet.prev != -1) then {
					if matchSets.hasKey(matchSet.prev) then {
						matchSets[matchSet.prev].next :=  matchSet.next;
					} else {
						__user.__qLogger.instanceLog("Unexpected matchset (prev) " + matchSet.prev.toString() + " in " + self.toString(), "ERROR", false);
					}
				}
				if(matchSet.next != -1) then {
					if matchSets.hasKey(matchSet.next) then {
						matchSets[matchSet.next].prev :=  matchSet.prev;
					} else {
						__user.__qLogger.instanceLog("Unexpected matchset (next) " + matchSet.next.toString() + " in " + self.toString(), "ERROR", false);
					}
				}
				if mostRecentMatchSet = matchSet.id then {
					mostRecentMatchSet := matchSet.next;
				}
				matchSets.remove(matchSet.id);
			} // else may have already been discarded - ignore
		}


		action evalConditions_node_0(__MatchSet matchSet) returns boolean {

			// what positive where clauses can we now evaluate?
			// what without where clauses can we now evaluate?

			// do any withouts invalidate this matchset?

			return true;
		}

		/* Pattern node for a coassignment from com$softwareag$saep$SensorEvent to s1 */
		action pattern_node_0(__MatchSet matchSet, integer evalState) returns boolean {
			// if we already have this coassignmnet, we evaluate to true, and don't copy or do anything:
			if matchSet.triggered_s1 > 0 then {
				if (evalState = EVAL_CONDITIONS) and (matchSet.triggered_s1  = EVAL_EVAL) then {
					matchSet.triggered_s1 := EVAL_CONDITIONS;
					boolean matchedWhere := evalConditions_node_0(matchSet);
					if not matchedWhere then {
						discard(matchSet);
					}
					return matchedWhere;
				}
				return true;
			}

			if "com$softwareag$saep$SensorEvent" = inputs.getType() then {
				if evalState = EVAL_MATCHEVENTS then {
					// coassign the event
					matchSet.csnmt_s1 := inputs.window_com$softwareag$saep$SensorEvent[inputs.getIndex()];
					matchSet.has_s1 := true;
					matchSet.timestamp_s1 := inputs.getCurrentTimestamp();

					haveConsumed := haveConsumed + 1;
					if matchingCurrentEvent then {
						matchSet.containsCurrent := matchSet.containsCurrent + 1;
					}

					return true;
				}
			}

			if evalState = EVAL_EVAL and matchSet.has_s1 then {
				boolean doCopy := true;
					__MatchSet copy := addMatchSetAfter(matchSet);
					copy.has_s1 := false;
					copy.triggered_s1 := 0;
					if matchingCurrentEvent then {
						copy.containsCurrent := copy.containsCurrent - 1;
					}
				matchSet.triggered_s1 := EVAL_EVAL;
				return true;
			} else {
				return false;
			}
		}

	}

	/* End of evaluation actions for each node in the pattern */

	action initWithinFilters() {
	}

	//wait duration
	action initWaits() {
	}
	
	/* Common code */
	/* =========== */
	
	/** Gets the next context for round-robin distribution of input events. */
	action nextContext() returns context {
		if workers.ctxs.size() <= 1 then {
			qLogger.instanceLog("Invalid state: No worker contexts.", "ERROR", false);
			shouldRespawn := false;
			die;
		}
		
		index := (index + 1) % workers.ctxs.size();
		if workers.ctxs[index].getId() = workers.gc_ctx.getId() then  {
			index := (index + 1) % workers.ctxs.size();
		}
		return workers.ctxs[index];
	}
	
	/** 
	* Called if the system is reconfigured.
	* Updates the set of contexts over which to distribute events.
	*/
	action onNewContexts( __WorkerContextSet workers_ ) {
		workers := workers_;
		context ctx;
		for ctx in workers.ctxs {
			spawn newWorker() to ctx;
		}

		queryScenarioService.updateWorkerContexts(workers);
	}
	
	/** Terminates a worker instance */
	action terminateWorker() {
		// Check if we've got any waits outstanding before shutting down.
		shouldRespawn := false;
		die;
	}
	
	/** Re-evaluate patterns
	* timer - details of the time we should re-evaluate at.
	*/
	action reEvaluateInputs(__RestartQueryTimer timer) {
		if not timerMgr.hasTimer(timer) then {
			timerMgr.add(timer);
			if(timer.waitExpiryTime > currentTime) then {
				on wait(timer.waitExpiryTime - currentTime) {
					fireTimer(timer, 10);
				}
			} else {
				fireTimer(timer, 10);
			}
		}
	}

	/** Find new definitive times since our last evaluation.
	* populates definitiveTimes with any source-realm definitive timestamps which were not definitive as of the last evaluation.
	*/
	action findValidNewDefinitiveTimes(sequence<float> definitiveTimes, float previousDefinitiveTime, float definitiveTime, float waitTime, sequence<float> sourceTimes, sequence<float> times) {
		integer i:=0;
		while(i < times.size() and i < sourceTimes.size()) {
			// must be (previous, current] definitive time, and not invalid (discarded due to delay > waitTime)
			if sourceTimes[i] > previousDefinitiveTime and sourceTimes[i] <= definitiveTime and times[i] - sourceTimes[i] <= waitTime then {
				definitiveTimes.append(sourceTimes[i]);
			}
			i := i + 1;
		}
	}


	/** 
	 * Process a stored snapshot for one of the inputs of this query
	 */
	action gotSnapshot(__StoredSnapshot ss) {
		boolean isEvalOnWaitExpiry:= ss.isEvalOnWaitExpiry;
		float expiredWaitStartTime:= ss.expiredWaitStartTime;
		float expiredWaitEndTime := ss.expiredWaitEndTime;

		// Set up input __EvaluationState variables
		__EvaluationState evalState := newEvaluationState(ss);
		dictionary<string, float> inputWaitTimes := new dictionary<string, float>;
		dictionary<string, float> dict := new dictionary<string, float>;

		// no source timestamps => single evaluation always
		if not anyHaveSourceTimestamps then {
			evalWindowOnce(evalState, ss, ss.latestEvent.processedTimestamp, currentTime, isEvalOnWaitExpiry, expiredWaitStartTime, expiredWaitEndTime, false, dict, dict, new dictionary<string, __DelayedOutOfOrderTime>);
		} else {
			inputWaitTimes := {};
			// Calculate previous definitive time, based on previousEvalTimestamp
			dictionary<string, float> previousDefinitiveTimes := new dictionary<string, float>;
			dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders := {};
			populateInputDefinitiveTime_com$softwareag$saep$SensorEvent(ss, previousDefinitiveTimes, true, delayedOutOfOrders);

			// Calculate current defintive time:
			dictionary<string, float> definitiveTimesDict := new dictionary<string, float>;
			populateInputDefinitiveTime_com$softwareag$saep$SensorEvent(ss, definitiveTimesDict, false, delayedOutOfOrders);
			float previousDefinitiveTime := calculateQueryDefinitiveTime(previousDefinitiveTimes, "previous");
			float definitiveTime := calculateQueryDefinitiveTime(definitiveTimesDict, "current");

			float beginDefinitiveSearchRange := previousDefinitiveTime;
			float endDefinitiveSearchRange := definitiveTime;
			// determine what new definitive times we have:
			sequence<float> definitiveTimes := []; // populated by calls to findValidNewDefinitiveTimes
			{
				sequence<float> sourceTimes := ss.allEvts[sharedId_com$softwareag$saep$SensorEvent].timestamps;
				float waitTime:=0.0;
				findValidNewDefinitiveTimes(definitiveTimes, beginDefinitiveSearchRange, endDefinitiveSearchRange, waitTime, sourceTimes, ss.allEvts[sharedId_com$softwareag$saep$SensorEvent].timestamps);
			}
			definitiveTimes.sort();

			float evalDefinitiveTime;
			for evalDefinitiveTime in definitiveTimes {
				evalWindowOnce(evalState.clone(), ss.clone(), evalDefinitiveTime, definitiveTime, false, float.NAN, float.NAN, false, dict, inputWaitTimes, delayedOutOfOrders);
			}

			if anyHaveSourceTimestamps and not isEvalOnWaitExpiry then {
				// now perform speculative search through window to determine if any timers should be set up
				evalWindowOnce(evalState, ss, float.INFINITY, definitiveTime, false, float.NAN, float.NAN, true, definitiveTimesDict, inputWaitTimes, delayedOutOfOrders);
			}
		}
	}

	/** 
	 * Evaluate the window, up to the point indicated in source time by definitive time
	 */
	action evalWindowOnce(__EvaluationState evalState, __StoredSnapshot ss, float definitiveTime, float maxDefinitiveTime, boolean isEvalOnWaitExpiry, float expiredWaitStartTime, float expiredWaitEndTime, boolean isSpeculating, dictionary<string, float> definitiveTimes, dictionary<string, float> inputWaitTimes, dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders) {
		// Set up the rest of input __EvaluationState variables
		evalState.maxDefinitiveTime := maxDefinitiveTime;
		evalState.evalOnWaitExpiry := isEvalOnWaitExpiry;
		evalState.expiredWaitStartTime := expiredWaitStartTime;
		evalState.findAllMatches := ss.findAllMatches;

		// Trim relevant windows based on the queries definitive time
		scopeWindowToDefinitiveTime_com$softwareag$saep$SensorEvent(evalState.inputs.window_com$softwareag$saep$SensorEvent, definitiveTime, ss, isSpeculating, maxDefinitiveTime);
		// set evalState.inputs.timestampOfLatestReceived to the timestamp available to
		// __WindowsIterator which is sew.sourceTimestamp if available, otherwise sew.timestamp
		evalState.inputs.timestampOfLatestReceived := ss.latestEvent.sourceTimestamp;

		// Execute patternTrigger
		// If isSpeculating = true we scan through once to determine any future matchSets and get the max wait value
		evalState.patternTrigger(expiredWaitEndTime, definitiveTimes, inputWaitTimes, isSpeculating, delayedOutOfOrders);
	}


	/**
	 * Actually re-evaluate an expired timer
	 */
	action fireTimer(__RestartQueryTimer timer, integer retryCount) {
		string key := timer.windowKey;
		__StoredSnapshot ss;
		try {
			ss := windowManager_com$softwareag$saep$SensorEvent.getSnapshot(key, false);
			// correlator timestamp of events can go
			// slightly ahead of correlator time, so
			// processedTimestamp is the max of
			// ss.latestEvent and the timer expiry time:
			ss.latestEvent.processedTimestamp := float.max(ss.latestEvent.processedTimestamp, timer.waitExpiryTime);
			ss.isEvalOnWaitExpiry := true;
			ss.expiredWaitStartTime := timer.waitStartTime;
			ss.expiredWaitEndTime := timer.waitExpiryTime;
		} catch (com.apama.exceptions.Exception __e) {
			if (retryCount > 0) then {
				qLogger.instanceLog("Caught exception (retries="+retryCount.toString()+") "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString()+" - "+__e.getStackTrace().toString(), "ERROR", false);
				terminationMgr.incrOutstandingRetries();
				on wait(1.0) {
					fireTimer(timer, retryCount - 1);
					terminationMgr.decrOutstandingRetries();
				}
				return;
			} else {
				qLogger.instanceLog("Terminating query instance. Exception "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString(), "FATAL", false);
				shouldTerminateWorkers := true;
				die;
			}
		}
		// We have timers per query instance; just eval locally.
		gotSnapshot(ss);
		timerMgr.remove(timer);
	}

	// Set up variables required when instantiating __EvalutationState
	action newEvaluationState(__StoredSnapshot ss) returns __EvaluationState {
		__EvaluationState evalState := new __EvaluationState;
		evalState.key := ss.key;
		evalState.reEvaluateInputsAction := reEvaluateInputs;
	
		evalState.queryScenarioService := queryScenarioService;
		__user.__qLogger := qLogger;
		evalState.__user := __user.clone();
		
		// set the key values:
		sequence<string> keyValues := sequence<string>.parse(ss.key);
		integer i:=0;
		evalState.__user.sensorId := integer.parse(keyValues[i]);
		i := i+1;

		evalState.inputs.window_com$softwareag$saep$SensorEvent := getWindow_com$softwareag$saep$SensorEvent(ss);

		shouldRespawn := true;
		return evalState;
	}

	action getCurrentTime(float maxTimestamp, boolean breakTie) returns float {
		 if(currentTime > maxTimestamp) then { 	 
			return currentTime;
		} else if breakTie then {
			return maxTimestamp + __TS.TIEBREAKER;
		} else {
			return maxTimestamp;
		}
	}

	/* 
	 * Calculates the definitive time of the input window corresponding to the 
	 * sourceTimestamps passed in. Calculated as the maximum of:
	 * 	Most recent timestamp or source timestamp
	 * 	Correlator's current time - input wait time
	 */
	action calculateInputDefinitiveTime(sequence<float> definitiveTimestamps, 
			sequence<float> correlatorTimestamps, 
			float evalCurrentTime, float inputWait, 
			float heartbeatTime, 
			dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders, 
			string thisInput, 
			boolean outOfOrder) returns float {

		if outOfOrder then {
			return float.max(evalCurrentTime - inputWait, heartbeatTime);
		}

		float dt := -float.INFINITY;
		float maxTimeOutOfOrder := -float.INFINITY;
		float timeWillBecomeDefinitive := -float.INFINITY;
		integer i:=0;
		while(i < definitiveTimestamps.size()) {
			float evtDelayTime := correlatorTimestamps[i] - definitiveTimestamps[i];
			float evtAge := evalCurrentTime - correlatorTimestamps[i];
			if( evtDelayTime <= queryScenarioService.delayLeeway.delayLeeway or 
			     evtAge >= queryScenarioService.delayLeeway.reorderBuffer) then {
				if maxTimeOutOfOrder = -float.INFINITY then {
					dt := float.max(dt, definitiveTimestamps[i]);
				}
			} else {
				maxTimeOutOfOrder := float.max(maxTimeOutOfOrder, definitiveTimestamps[i]);
				timeWillBecomeDefinitive := float.max(timeWillBecomeDefinitive, correlatorTimestamps[i] + queryScenarioService.delayLeeway.reorderBuffer);
			}
			i := i + 1;
		}
		if(maxTimeOutOfOrder != -float.INFINITY and thisInput != "") then {
			delayedOutOfOrders[thisInput] := __DelayedOutOfOrderTime(maxTimeOutOfOrder, timeWillBecomeDefinitive);
		}

		return float.max(float.max(dt, evalCurrentTime - inputWait), heartbeatTime);
	}

	/* 
	 * Calculates the definitive time of the query. Calculated as the minimum of
	 * all the input definitive times.
	 * Definitive time defines the time the query is accurate up to, across all
	 * inputs, taking into account any source times the inputs may have. It is the point
	 * in time for which the query runtime knows it has received all the events it is 
	 * going to receive. Only from this time onwards will patterns match.
	 * This is definied for queries with and without any getSourceTime actions 
	 * implemented but only has special method when at least one is present;
	 */
	action calculateQueryDefinitiveTime(dictionary<string, float> dts, string type) returns float {
		float dt := float.INFINITY;
		string dt_key;
		for dt_key in dts.keys() {
			dt := float.min(dt, dts[dt_key]);
		}

		return dt;
	}
	
	action getMetadataMap() returns dictionary<string, string> {
		return {
"Author":"Software AG"
				};
	}
}

// QUERY SOURCE:
// This is a base64-encoded copy of the query source (generated by rel/9.10.0.x@275046) that generated this .mon file
// Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
// KioqKioqKioqKioqKioqKioqKioqKg0KLy8gVGl0bGU6ICAgICAgICAgR3JvdXBzDQovLyBEZXNj
// cmlwdGlvbjogICBHcm91cCB0aGUgc2Vuc29yIGV2ZW50cyBieSBzb25zb3JJZCBhbmQgY291bnQu
// DQovLyBEZXBlbmRlbmNpZXM6ICBFdmVudCB0eXBlIGRlZmluaXRpb24NCi8vIEF1dGhvcjogICAg
// ICAgIFNvZnR3YXJlIEFHDQovLw0KLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
// KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KDQpwYWNrYWdlIGNv
// bS5zb2Z0d2FyZWFnLnNhZXA7DQp1c2luZyBjb20uYXBhbWEuYWdncmVnYXRlcy5jb3VudDsNCg0K
// cXVlcnkgR3JvdXBzIHsJDQoJDQoJbWV0YWRhdGEgew0KCQkiQXV0aG9yIjoiU29mdHdhcmUgQUci
// DQoJfQ0KCQ0KCWlucHV0cyAgew0KCQkvL2tleiBzZW5zb3JJZDogZ3J1cHBpZXJ0IGRpZSBTZW5z
// b3Jlbg0KCQljb20uc29mdHdhcmVhZy5zYWVwLlNlbnNvckV2ZW50KCkga2V5IHNlbnNvcklkIHdp
// dGhpbiA1LjA7DQoJfQ0KCQ0KCWZpbmQgZXZlcnkgU2Vuc29yRXZlbnQgOiBzMQ0KCXNlbGVjdCBj
// b3VudCgpIDogc2Vuc29yQ291bnQgew0KDQoJCSVjdXN0b20oInRpdGxlIjoiQ3VzdG9tIEVQTCBB
// Y3Rpb24gMSIpIHsNCgkJCXNlbmQgU2Vuc29yQ291bnRlcihzZW5zb3JJZCwgc2Vuc29yQ291bnQp
// IHRvICIiOw0KCQl9DQoJfQ0KfQ0K

TIME 0000000f 1484234969.9,31
TIME 0000000e 1484234969.9,1
TIME 0000000f 1484234969.9,32
TIME 0000000f 1484234969.9,30
TIME 0000000e 1484234969.9,3
TIME 0000000e 1484234969.9,4
MONI 00013d31 /* Package as specified by the .qry */
package com.softwareag.saep; 
/* Private using declarations required by framework */
using com.apama.queries.__Index;
using com.apama.queries.__LatestEvent;
using com.apama.queries.__Respawn;
using com.apama.queries.__RestartQueryTimer;
using com.apama.queries.__Trigger;
using com.apama.queries.__TS;

/* Private using declarations required by framework to interact with QueryServices.mon */
using com.apama.queries.__ContextMgr;
using com.apama.queries.__DistributionMgr;
using com.apama.queries.__FailedQueryInstance;
using com.apama.queries.__HubContextRequest;
using com.apama.queries.__HubContextRemove;
using com.apama.queries.__PendingTimersMgr;
using com.apama.queries.__PrepareStore;
using com.apama.queries.__QueryLoaded;
using com.apama.queries.__QueryLogger;
using com.apama.queries.__QueryReady;
using com.apama.queries.__QueryScenarioService;
using com.apama.queries.__RemoveInstance;
using com.apama.queries.__StoredEventWindow;
using com.apama.queries.__StorePrepared;
using com.apama.queries.__StoredSnapshot;
using com.apama.queries.__TerminationMgr;
using com.apama.queries.__WorkerContextSet;
using com.apama.queries.__WindowLength;
using com.apama.queries.__WindowManager;
using com.apama.queries.__WindowManagerTableUsageChanged;

/* Using declarations explicitly specified in the .qry */

/**
 * Monitor controlling query Sensors.
 */
monitor Sensors { 

	/** General internal events */
	event __NullType {
	}

	/** The set of worker contexts */
	__WorkerContextSet workers;
	
	/** The index of the current worker context */
	integer index;

	/* Flag for whether or not (and how) to respawn after ondie is triggered */
	boolean shouldRespawn := false;
	boolean shouldTerminateWorkers := false;
	boolean deleted := false; // has been deleted

	/* Number of instances of the query. Used to limit non-parameterized queries to a single instance */
	integer instanceCount := 0;
	
	/* TerminationManager used to shutdown workers */
	__TerminationMgr terminationMgr;

	/** Set of pending input window preparations
	 */	
	dictionary<integer, integer> pendingPreparations;

	/** The MemoryStore Store used to hold each event window */
	com.apama.memorystore.Store store;

	/** A __DistributionMgr for each input type */
	__DistributionMgr dist_com$softwareag$saep$SensorEvent;
	__DistributionMgr dist___RestartQueryTimer;
	/** Manager for processPending timers */
	__PendingTimersMgr timerMgr;

	/** Flag to inidicate where any input source times are used */
	boolean anyHaveSourceTimestamps;

	/** Used to interact with the Scenario Service monitor which is stuck in the past i.e. the main context */
	context scenarioServiceCtx;
	context mainCtx;
	// @see HubContextManager
	context hubCtx;
	context statsGatherer;
	boolean isMasterMonitor;
	boolean isInstanceProxy;
	boolean initialised;
	boolean createdAtStartup; // see initCommon
	integer qryId;
	string parameterizationOwner;

	/** Query scenario service event */
	__QueryScenarioService queryScenarioService;
	__QueryLogger qLogger;

	string queryDefinitionName := queryScenarioService.QUERY_PREFIX + "com.softwareag.saep.Sensors";


	/**
	 * A per-matchset event. 
	 *
	 * Contains a potential matching set of events and any other state
	 * needed to evaluate the pattern.
	 * MatchSets are owned by a parent (either another MatchSet or the
	 * EvaluationState
	 */
	event __MatchSet {	
		///// state corresponding to the pattern:

		// coassigned (positive) events:
		wildcard SensorEvent csnmt_s1 ;

		// flags to record which coassignments we have:
		wildcard boolean has_s1;
		// flags to record which coassignments we have previously triggered:
		wildcard integer triggered_s1;
		
		// timestamps of the events
		wildcard float timestamp_s1;

		// per-followedby node - which way is it looking?


		// per-without sets of the event - only holds those where we
		// don't yet know whether the 'where' condition holds.
		
		///// state corresponding to the evaluation state:
		integer id;
		action init() {
			id := integer.getUnique();
		}

		// The effective timestamp for when this match occurred
		action mostRecentTime() returns float {
			float t := -float.INFINITY;

			if (timestamp_s1 > t) then {
				t := timestamp_s1;
			}

			return t;
		}

		// we maintain an ordered linked list of matchsets, the most recent first
		// this is managed by EvaluationState.addNewMatchsetAfter and 
		// EvaluationState.discard
		integer next;
		integer prev;

		// count of how many instances of the 'current' event this matchset contains:
		integer containsCurrent;
	}


	event __SelectOutput {
		wildcard integer e1;
		/**
		 * Simulates the 'having' clause from a query. The having expression is fed into __having in the select clause, and then
		 * interrogated before the find action is triggered. We do this in preference to using an actual 'having' clause to avoid obscure
		 * error message bugs.
		 */
		boolean __having;
	}
	event __DelayedOutOfOrderTime {
		float maxInputEventTimestamp;
		float correlatorTimeBecomesDefinitive;
	}

    	/** Utility event containing all user-defined parameters, expressions and query actions*/
	event __ElasticQueryUserCode {

		/* Only copy of query parameters */




		/** Return the user-specified duration; the evaluation of either an EPL float expression or a time literal */
		action __getWithin_com$softwareag$saep$SensorEvent() returns float {
			return  __calculateTime("", "", "", "5", "");   
		}


		/* User code that gets invoked when the pattern is matched 
		 * Takes coassignments into its scope as arguments, and parameters/keys as members on self.
		 */
		action __findAction(integer e1 ) {

			/**
			 * Brackets for extra scoping goodness; we want the user to be able to declare
			 * variables that mask arguments to this action i.e. coassignments
			 */
			{
{
			send Counter(e1) to "";
		}				 
			}
		}

		action __processAggregates(sequence<__MatchSet> __matchSets) {
			integer __toRetain := __matchSets.size();
			integer __id := integer.getUnique();
			stream<__MatchSet> __mstr := from idx in all __Index(id=__id) retain __toRetain select __matchSets[idx.idx];
			// while these are not used (and should not be used), they are
			// here to help the completion proposals.  Actual use of them in
			// the projection is via the __ms prefix.

			SensorEvent s1;

			__SelectOutput __output;
			listener  __sstr := from __ms in __mstr retain __toRetain from __t in all __Trigger(__id)
				/** Force this to be an aggregate query so that a query with a non-aggregate-ey select clause gets flagged as an error */
				having true
				select __SelectOutput(com.apama.aggregates.count() 
		, 			true
				)
				:__output
			{
				__mstr.quit();
				__sstr.quit();
				if(__output.__having) then {
					try{
						__findAction(__output.e1);
					} catch(com.apama.exceptions.Exception __e) {
						 
						__qLogger.instanceLog("Pattern action threw exception"
							+ ": " + __e.getType() + " - " + __e.getMessage(), "WARN", false); 

					}
				}
			}
			integer __i:=0;
			while(__i < __matchSets.size()) {
				route __Index(__id, __i);
				__i := __i+1;
			}
			route __Trigger(__id);
		} 





		/* Parameterized query logger */
		__QueryLogger __qLogger;

		/* Pattern event listener(s) */

		action<action<string, boolean, float>, integer, SensorEvent> __handle_com$softwareag$saep$SensorEvent;


		/** __WindowManager._listenFor_cb */
		action __listenFor_com$softwareag$saep$SensorEvent(action<string, boolean, float> __onEvent, action<string, string, boolean, float> __onHeartbeat) returns sequence<listener> {
			sequence<listener> listeners := [];
			SensorEvent  __latest;
			listener l := on all SensorEvent(): __latest { 
				__handle_com$softwareag$saep$SensorEvent(__onEvent, 10, __latest);
			}
			listeners.append(l);
			return listeners;

		}
		/* Template listener - not kept live, just used to serialise the templateArgs.  */
		action __startListener_com$softwareag$saep$SensorEvent() returns listener {
			SensorEvent  __latest;
			listener __l := on SensorEvent(): __latest { 
			}
			return __l;
		}


		/* Get time in seconds*/
		action __calculateTime(string day, string hour, string min, string sec, string msec) returns float {
			float value := __parseToFloat(day)*86400000.000 + 
			               __parseToFloat(hour)*3600000.000 + 
			               __parseToFloat(min)*60000.000 + 
			               __parseToFloat(sec)*1000.000 + 
			               __parseToFloat(msec);
			// round time to nearest millisecond
			return value.round().toFloat()/1000.0;
		}
	
		action __parseToFloat(string num) returns float {
			if (num = "") then {
				return 0.0;
			}
			// if hexadecimal integer then first parse into int
			if (num.length() > 2 and (num.substring(0, 2) = "0x" or num.substring(0, 2) = "0X")) then {
				return integer.parse(num).toFloat();
			} else {
				return float.parse(num);
			}
		}


	} // end of event __ElasticQueryUserCode

	__ElasticQueryUserCode __user;

	action __calculateTime(string day, string hour, string min, string sec, string msec) returns float {
		return __user.__calculateTime(day, hour, min, sec, msec);
	}

	/** Actually just proxies an onload_ call into the query hub context */
	//  @see HubContextManager
	action onload() {
		scenarioServiceCtx := context.current();
		mainCtx := context.current();
		(new __HubContextRequest).process(true, queryDefinitionName, hubCallback);
	}
	
	action hubCallback(context _hubCtx, context _statsGatherer) {
		hubCtx := _hubCtx;
		statsGatherer := _statsGatherer;
		route __QueryLoaded("com.softwareag.saep.Sensors");
		// Spawn into the query hub context
		spawn onload_() to hubCtx;
	}

	/** 
	* Called when monitor is loaded.
	*/
	action onload_() {
		// Is main (parent) monitor causes termination then query scenario service is made aware
		isMasterMonitor := true;
		sequence<string> eventTypes := ["com.softwareag.saep.SensorEvent"];
		anyHaveSourceTimestamps := false;

		// Set necessary query scenario service support event query information
		queryScenarioService.init(
			"com.softwareag.saep.Sensors",
			queryDefinitionName,
			false,
			false,
			createParameterizedQueryInstance,
			updateUserParameters,
			prepareParameterizedQueryInstanceFinish,
			scenarioServiceCtx,
			hubCtx,
			statsGatherer,
			eventTypes,
			getMetadataMap()
		);

		qLogger := queryScenarioService.getLogger();

		// Create a __TerminationMgr for the master, - in case an unparameterized query fails
		(new __TerminationMgr).init(terminateWorker, queryDefinitionName, -1);

		// Start point of query creation
		prepareStores();
	}

	// Block handle store preparation, where certain store need to be prepared
	// before the instance is prepared - uses callback (called only once successfully
	// prepared to ensure they are triggered in the intended order.
	// Order is pending timer manager -> scenario service
	action prepareStores() {
		timerMgr.init(hubCtx, queryScenarioService.masterId, qLogger, prepareStoresCompleted);
	}

	boolean allTablePrepareSucceeded;

	action prepareStoresCompleted(boolean success, com.apama.memorystore.Table timersTable) {
		allTablePrepareSucceeded := success; // used by initWindowTable, see below
		// Store preparation listener
		integer reqId := integer.getUnique();
		__StorePrepared prepared;
		on __StorePrepared(requestId = reqId):prepared {
			/** Name of the store */
			queryScenarioService.storeName := prepared.storeName;
			if(prepared.success) then {
				timerMgr.timersTable := timersTable;
				timerMgr.startClusterMemberChangeMonitor();
				scenarioServiceStorePrepared();
			} else {
				qLogger.queryLog("Could not prepare store " + queryScenarioService.storeName + ": " + prepared.reason, "FATAL", false);
				shouldRespawn := false;
				die;
			}
		}

		// Prepare the store
		route __PrepareStore(queryScenarioService.name, reqId);
	}

	action scenarioServiceStarted() {
		// start the failed query handler
		spawn failedQueryHandler();

		// the following instances are created at startup:
		createdAtStartup := true;
		// Check to see if this unparameterized query was previously created and if so recreate with the same instance ID.
		// There should only be a single instance in the table for a non-parameterized query
		try {
			com.apama.memorystore.Iterator it:=queryScenarioService.paramTable.begin();
			if (not it.done()) then {
				// ReCreate the existing instance
				qLogger.queryLog("Recreating non-parameterized query instance", "DEBUG", false);
				queryScenarioService.routeCreate(0, "*", new sequence<string>, it.getKey().toInteger());
			} else {
				// Create a new instance
				queryScenarioService.routeCreate(0, "*", new sequence<string>, 0);
			}
		} catch(com.apama.exceptions.Exception e) {
			// fallback, possibly if no table of parameterizations:
			queryScenarioService.routeCreate(0, "*", new sequence<string>, 0);
		}
		// either way, we create a single instance; mark this as loading until the instance has started (i.e. not start JMS until it has started)
		send __QueryLoaded(queryScenarioService.name) to scenarioServiceCtx;
		send __QueryReady(queryScenarioService.name) to scenarioServiceCtx;
		integer id:=integer.getUnique();
		route __Trigger(id);
		on __Trigger(id) {
			// after we have processed Create events, any further creates are not at startup.
			createdAtStartup := false;
		}
	}

	/** Store is ready to be opened */
	action scenarioServiceStorePrepared() {
		store := (new com.apama.memorystore.Storage).open(queryScenarioService.storeName);

		// Open or create the parameterised store here.
		// Needs to be ready before ScenarioService is (ie before we have create listeners etc)
		// FIXME - Use a single table to store the parameterizations?
		__NullType n := new __NullType;
		string queryName := n.getName().substring(0,-11);
		// Table to store parameter values
		string tableName := "parameterizations_"+queryName+"_"+queryScenarioService.name;
		com.apama.memorystore.Schema schema := new com.apama.memorystore.Schema;
		schema.fields.append("scenarioId");
		schema.types.append("string");
		schema.fields.append("owner");
		schema.types.append("string");
		schema.fields.append("parameters");
		schema.types.append("string");

		// Table to store instance ID
		string eqConfigTableName := "eqConfig"; // elastic queries config table
		com.apama.memorystore.Schema eqConfigSchema := new com.apama.memorystore.Schema;
		eqConfigSchema.fields.append("integerConfig");
		eqConfigSchema.types.append("integer");
		eqConfigSchema.fields.append("stringConfig");
		eqConfigSchema.types.append("string");
		
		// Prepare the table to hold the event window
		qLogger.queryLog("Preparing table to store parameter values: " + tableName, "DEBUG", false);
		integer id2 := store.prepare(tableName, schema);
		qLogger.queryLog("Preparing table to store parameter IDs: " + eqConfigTableName, "DEBUG", false);
		integer id3 := store.prepare(eqConfigTableName, eqConfigSchema);

		com.apama.memorystore.Finished f2;
		com.apama.memorystore.Finished f3;
		on com.apama.memorystore.Finished(id=id2):f2 and
		   com.apama.memorystore.Finished(id=id3):f3 {
			if f2.success then { 
				// Open the parameterizations table
				queryScenarioService.paramTable := store.open(tableName);
				qLogger.queryLog("Successfully prepared table to store parameter values: " + tableName, "DEBUG", false);
			} else {
				qLogger.queryLog("Asynchronous MemoryStore operation (Prepare Parameterizations) failed: " + f2.toString(), "FATAL", false);
			}

			if f3.success then { 
				queryScenarioService.eqConfigTable := store.open(eqConfigTableName);
				qLogger.queryLog("Successfully prepared table to store parameter IDs: " + eqConfigTableName, "DEBUG", false);
			} else {
				qLogger.queryLog("Asynchronous MemoryStore operation (Prepare eqConfig table) failed: " + f3.toString(), "FATAL", false);
			}
			allTablePrepareSucceeded := allTablePrepareSucceeded and f2.success and f3.success;

			try {
				// Subscribe to the table notifications
				integer notificationId := queryScenarioService.paramTable.subscribeRowChanged();
				queryScenarioService.supportsRowNotifications := true;
			} catch (com.apama.exceptions.Exception e) {
				qLogger.queryLog("MemoryStore driver doesn't support RowChanged notifications.", "INFO", false);
				queryScenarioService.supportsRowNotifications := false;
			}
			
			if (queryScenarioService.supportsRowNotifications) then {
				com.apama.memorystore.RowChanged rc;
				on all com.apama.memorystore.RowChanged(storeName  = queryScenarioService.storeName,
				                                        tableName  = tableName,
				                                        changeType = com.apama.memorystore.RowChanged.INSERT):rc {
					qLogger.queryLog("Received RowChanged::" + rc.getChangeTypeString() + " event: key=" + rc.key 
						+ ": " + rc.oldFieldValues.toString() + " -> " + rc.newFieldValues.toString(), "DEBUG", false);

					com.apama.memorystore.Row r := queryScenarioService.paramTable.get(rc.key);
					string sid := r.getString("scenarioId");
					string s1 := r.getString("parameters");
					sequence<string> seq := sequence<string>.parse(s1);
					
					// (Re)Create the instance - this correlator might have created this instance in which case we 
					// shouldn't do anything here.
					queryScenarioService.routeCreate(0, "*", seq, rc.key.toInteger());
				}
			}

			// start query scenario service
			queryScenarioService.start(setupScenario(), scenarioServiceStarted);
			spawn talkToScenarioService() to scenarioServiceCtx; // Ensure correct communication with scenario service
		}

	}

	string sharedId;

	action initWindowTable(action<> callbackComplete) {
		
		string oldSharedId := sharedId;
		dictionary<string, boolean> allSharedIds_and_hasSourceTime := {sharedId_com$softwareag$saep$SensorEvent:false};
		sequence<string> allSharedIds_and_hasSourceTime_keys := allSharedIds_and_hasSourceTime.keys();
		allSharedIds_and_hasSourceTime_keys.sort();
		sequence<string> allSharedIds := new sequence<string>;
		sequence<boolean> hasSourceTime := new sequence<boolean>;
		dictionary<string,string> sharedIdToHeartbeatType := {
			sharedId_com$softwareag$saep$SensorEvent : ""
			};
		string sharedId_key;
		for sharedId_key in allSharedIds_and_hasSourceTime_keys {
			allSharedIds.append(sharedId_key);
			hasSourceTime.append(allSharedIds_and_hasSourceTime[sharedId_key]);
		}

		sharedId := allSharedIds.toString();
		if oldSharedId = sharedId then {
			return;
		}
		string tableName := windowManager_com$softwareag$saep$SensorEvent.getTableName(allSharedIds);
		com.apama.memorystore.Schema schema := new com.apama.memorystore.Schema;
		string s;
		integer i:=0;
		dictionary<string, string> heartbeatsAdded := {};
		for s in allSharedIds {
			schema.fields.append("contents_"+s);
			schema.types.append("string");
			schema.fields.append("timestamps_"+s);
			schema.types.append("string");
			if(hasSourceTime[i]) then {
				schema.fields.append("srctimes_"+s);
				schema.types.append("string");
			}
			string heartbeat := sharedIdToHeartbeatType[s];
			if(heartbeat != "" and not heartbeatsAdded.hasKey(heartbeat)) then {
				schema.fields.append("heartbeatTime_"+heartbeat);
				schema.types.append("string");
				heartbeatsAdded[heartbeat] := heartbeat;
			}
			i:=i+1;
		}
		if(anyHaveSourceTimestamps) then {
			schema.fields.append("evalTime");
			schema.types.append("float");
		}
		// Prepare the table to hold the event window
		qLogger.instanceLog("Preparing table to store window contents: " + tableName, "DEBUG", false);
		integer id := store.prepare(tableName, schema);
		pendingPreparations.add(id,id);
		com.apama.memorystore.Finished f;
		on com.apama.memorystore.Finished(id=id):f {
			allTablePrepareSucceeded := allTablePrepareSucceeded and f.success;
			if f.success then {
				qLogger.instanceLog("Successfully prepared table to store window contents: " + tableName, "DEBUG", false);
			} else {
				qLogger.instanceLog("Asynchronous MemoryStore operation (Prepare window table data) failed: " + f.toString(), "FATAL", false);
			}
			if not allTablePrepareSucceeded then {
				if haveCreateParameterizedCompletedCallback then {
					try {
						// has to go into created state before we can move it into the failed state:
						createParameterizedCompletedCallback();
					} catch(com.apama.exceptions.Exception e) {
						// wil fail to update param table if it is not open, that's fine..
					}
				}
				shouldRespawn := false;
				die;
			}
			prepareFinished(true, id, callbackComplete);
		}
	}




	/** 
	 * Spawned to create a monitor that handles routing scenario service events.
	 */
	action talkToScenarioService() {
		isMasterMonitor := false; // the talkToScenarioService monitor is neither master nor an instance proxy:
		queryScenarioService.talkToScenarioService();
	}	

	/** 
	 * Spawned to create a monitor that handles instance proxies that enter the failed state.
	 */
	action failedQueryHandler() {
		isMasterMonitor := false; // the failedQueryHandler monitor is neither master nor an instance proxy:
		queryScenarioService.failedQueryHandler();
	}	

	/* Supplementary query scenario service actions block */


	/* Callback used to setup query scenario service. */
	action setupScenario() returns dictionary<string, sequence<string> > {
		dictionary<string, sequence<string> > s := new dictionary<string, sequence<string> >;
		// Handle request for Scenario data
		s["inputNames"] := [
		];
		s["inputTypes"] := [
		];
		s["inputDefaults"] := [
		];
		
		return s;
	}

	//End of supplementary query scenario service actions block

	boolean haveCreateParameterizedCompletedCallback;
	action<> createParameterizedCompletedCallback;

	/**
	* Run in the instance proxy on receipt of a request to create a new parameterized query instance. 
	* Sets specified parameter values and instance ID before creating tables for this parameterization,
	* spawning a worker to each context, and initializing a distributor.
	* Note we only request distributors if any parameterizations exist. (though of course at most one of
	* them will be 'live' at any one time -see __DistributionMgr)
	* Exception may be thrown from updateUserParameters and initCommon (to be caught by queryScenarioService) if value 
	* field sizes do not match, is parsing fails or if values used to evaluate expressions result in exceptions.
	*/
	action createParameterizedQueryInstance(sequence<string> parameterValues, string owner, action<> completedCallback) {
		//Set this to false so that any failures after spawning will not interpreted as being from the main monitor
		isMasterMonitor := false;
		isInstanceProxy := true;
		parameterizationOwner := owner;
		qLogger := queryScenarioService.getLogger(); // ensures the instance logger is using the correct Id
		updateUserParameters(parameterValues, true, true, initCommon);

		// Create an action and listener list for the chain of initialisation actions
		// Create a __TerminationMgr for the instance proxy, - in case the instance should terminate
		(new __TerminationMgr).init(terminateWorker, queryDefinitionName, queryScenarioService.instancePxyId);
		createParameterizedCompletedCallback := completedCallback;
		haveCreateParameterizedCompletedCallback := true;

		// Set necessary __PendingTimersMgr information
		timerMgr.setInstance(queryScenarioService.instancePxyId);
	}


	/**
	* Callback used to log the a request has been made to delete this parameterized instance.
	* Also ensure that this does not trigger a respawn upon termination.
	*/
	action prepareParameterizedQueryInstanceFinish(boolean logDeath) {	
		if logDeath then {
			if isInstanceProxy then {
				qLogger.instanceLog("Deleting instance", "INFO", false);
			} 
		}
		shouldRespawn := false;
		if isInstanceProxy and (not deleted) and initialised then {
			route __WindowManagerTableUsageChanged(-1, [sharedId_com$softwareag$saep$SensorEvent]);
		}
		deleted := true;
	}

	/**
	* Called immediately upon receiving query scenario service create or edit event. 
	* Exception will be thrown (to be caught by queryScenarioService) if value field sizes do not 
	* match, is parsing fails or if any of the within/retains expressions, within filters or waits
	* are invalid (syntacically or <= 0) - no try-catch blocks are used as queryScenarioService
	* caller will log error/stacktrace as appropriate.
	*/
	action updateUserParameters(sequence<string> parameterValues, boolean validate, boolean calledByCreate, action<> completeCallback) {
		if validate then {
			queryScenarioService.checkSizeOfParameters(parameterValues, calledByCreate);
		}
		sequence<string> old_sharedIds := [sharedId_com$softwareag$saep$SensorEvent];

		/** Sets "const" parameters used to reset locally mutable parameter variables, by 
		* parsing each parameter into __user (needed prior to (eg) _within_ initialisation).
		* Henceforth use the canonical form of the parameters (having been parsed).
		* Also handles update of query services' sequence of parameter values.
		*/
		sequence <string> paramValues := [];
		queryScenarioService.updateParameterValues(paramValues);

		if validate then {
			/* Expressions are validated here - exception can be thrown out of each catch-block, which will be caught by queryScenarioService */
			{
				queryScenarioService.validatingExpr("within clause \"\" for input com$softwareag$saep$SensorEvent");
				float v := __user.__getWithin_com$softwareag$saep$SensorEvent();
				if v  <=  0.0 then {
					qLogger.requestFailed(calledByCreate, "Invalid within clause \"\" (duration = " + v.toString() + ") for input com$softwareag$saep$SensorEvent. Cannot be less than or equal to zero.", getParametersString());
					queryScenarioService.failValidation(); 
				}
			} 

			initWindow_com$softwareag$saep$SensorEvent();

			initWindowTable(completeCallback);

			prepareFinished(false, 0, completeCallback); // may well not have any tables to prepare
		} else {
			if not isInstanceProxy then {
				if not calledByCreate then {
					 
					within_com$softwareag$saep$SensorEvent := __user.__getWithin_com$softwareag$saep$SensorEvent();  
					initWaits();
					initWithinFilters();
				}

				generateSharedId_com$softwareag$saep$SensorEvent();

				completeCallback();

				if not calledByCreate then {
					// must terminate the window managers before re-spawning
					windowManager_com$softwareag$saep$SensorEvent.terminate();
					// for the window manager's benefit, we handle Edit re-spawning and dieing - but we re-spawn from this mThread, and not via the respawn interface
					spawn workerMain(); // skip re-spawning the respawnListener, the old one should still be active.
					shouldRespawn := false;
					die;
				}
			} else {
				completeCallback();
			}

		}
		if isInstanceProxy then {
			route __WindowManagerTableUsageChanged(+1, [sharedId_com$softwareag$saep$SensorEvent]);
			if initialised then {
				route __WindowManagerTableUsageChanged(-1, old_sharedIds);
			}
		}
	}

	action getParametersString() returns string {
		return queryScenarioService.getParametersString(queryScenarioService.parameterValues, false);
	}


	/** 
	 * Called when any preparation has finished - will call initCommon if all preparations complete
	 */
	action prepareFinished(boolean removeId, integer id, action<> callbackComplete) {
		if removeId then {
			pendingPreparations.remove(id);
		}
		if pendingPreparations.size() = 0 then {
			callbackComplete();
		}
	}


 	/** 
	 * Called from the factory instance, when any tables have been prepared.  Only runs if no preparations left.
	 * Sets up the framework for handling multiple contexts. 
	 */
	action initCommon() {
		initWaits();
		initWithinFilters();
		initialised := true;
		if createdAtStartup then {
			// if this was created during startup, this is
			// either a non-parameterized instance or a
			// parameterized instance on a cluster, we are
			// only ready now:
			send __QueryReady(queryScenarioService.name) to scenarioServiceCtx;
		}

		// Handle changes to the set of worker-contexts  - causes workers to be spawned
		(new __ContextMgr).init( onNewContexts );

		// Initialise each __DistributionMgr  
		dist_com$softwareag$saep$SensorEvent.init(SensorEvent.getName(), distribute_com$softwareag$saep$SensorEvent);
		dist___RestartQueryTimer.init(__RestartQueryTimer.getName(), distribute___RestartQueryTimer);
		if haveCreateParameterizedCompletedCallback then {
			createParameterizedCompletedCallback();
		}

	}

	/** Executed before this instance dies. */
  	action ondie() {
  		// Clean-up!
		// If other queries share these event inputs, and if this query is currently
		// in charge of distribution, then a new distributor needs electing
		dist_com$softwareag$saep$SensorEvent.terminate();
		dist___RestartQueryTimer.terminate();		
		windowManager_com$softwareag$saep$SensorEvent.terminate();
		if isInstanceProxy and not deleted then {
			route __FailedQueryInstance(queryScenarioService.name, queryScenarioService.instancePxyId, queryScenarioService.parameterValues, parameterizationOwner);
			send __RemoveInstance(queryDefinitionName, queryScenarioService.instancePxyId) to workers.ctxs;
			if initialised then {
				route __WindowManagerTableUsageChanged(-1, [sharedId_com$softwareag$saep$SensorEvent]);
			}
		}

		if shouldTerminateWorkers then {
			log "Query log: Exception thrown when processing query, terminating all workers" at FATAL;
			send __RemoveInstance(queryDefinitionName, queryScenarioService.instancePxyId) to hubCtx;
		} else if shouldRespawn then { 
			// respawn in case aggregate function threw exception

			route __Respawn(queryScenarioService.instancePxyId); 
		}

		if not shouldTerminateWorkers then {
			// we should not lose any timer state we have, so send all 
			// state about timers to the hub context, which will
			// re-distribute it to the workers (possibly back to us, 
			// but possibly not; whatever it will do the right thing).
			timerMgr.broadcastTimers();
		}

		if isMasterMonitor then {
			// Ref-counting remove to HubContextManager
			(new __HubContextRemove).process(queryDefinitionName , mainCtx);
			// Alert query scenario service that the entire definition is gone - called once per definition.
			// Intentionally called here instead of in onunload to as to have access to the master monitor member values.
			queryScenarioService.unload();
		} else if isInstanceProxy then {
			timerMgr.removeAll();
		}
	}


	action distribute_com$softwareag$saep$SensorEvent() {
		SensorEvent e;
		on all SensorEvent(): e { 			 
			forward_com$softwareag$saep$SensorEvent(e, nextContext());
		}
	}

	action forward_com$softwareag$saep$SensorEvent(SensorEvent e, context ctx) {
		
	  	enqueue e to ctx;
	}

	action distribute___RestartQueryTimer() {
		__RestartQueryTimer e;
		on all __RestartQueryTimer(): e { 			 
			forward___RestartQueryTimer(e, nextContext());
		}
	}

	action forward___RestartQueryTimer(__RestartQueryTimer e, context ctx) {
		
	  	enqueue e to ctx;
	}


	 
	/** Spawned on each new worker instance */
	action newWorker() {
		isMasterMonitor := false;
		isInstanceProxy := false;


		// set up respawn listener for new worker in case of exception thrown by aggregate function
		spawn respawnListener();
		workerMain();
	}

	action workerMain() {
		qryId := integer.getUnique();

		// starts the query scenario service listeners as these are not active afer being spawned - only if we have parameters
		queryScenarioService.startWorkerListeners(context.current().getId() = workers.gc_ctx.getId());




		dictionary<string,string> sharedIdToHeartbeatType := {
			sharedId_com$softwareag$saep$SensorEvent : ""
		};

		// Set-up a listener for each event inputs
		initWindowListener_com$softwareag$saep$SensorEvent(sharedIdToHeartbeatType);
	
		// Create a __TerminationMgr for the worker instance, so that the context can be discarded 
		terminationMgr := new __TerminationMgr;
		terminationMgr.init(terminateWorker, queryDefinitionName, queryScenarioService.instancePxyId);
		
		// and restart any timers we get notified of:
		__RestartQueryTimer restartTimer;
		on all __RestartQueryTimer(queryName=queryScenarioService.name, instanceId=queryScenarioService.instancePxyId):restartTimer {
			reEvaluateInputs(restartTimer);
		}
	}


	/** respawn listener set up for every instance */
	action respawnListener() {
		on __Respawn(instanceId = queryScenarioService.instancePxyId) {
			qLogger.instanceLog("Exception thrown from aggregate function(s), respawning worker to current context", "WARN", false);

			shouldRespawn := false;
			spawn newWorker();
			die;
		}

		// Create a __TerminationMgr for the worker instance, so that the context can be discarded 
		terminationMgr := new __TerminationMgr;
		terminationMgr.init(terminateWorker, queryDefinitionName, queryScenarioService.instancePxyId);
	}


	/* All input definition and maintenance code */
	/* ========================================== */	

	/* Initialise individual event input inputs */

	/** Size of the 'within' window of com.softwareag.saep.SensorEvent */
	float within_com$softwareag$saep$SensorEvent;

	string sharedId_com$softwareag$saep$SensorEvent;
	__WindowManager windowManager_com$softwareag$saep$SensorEvent;

	action generateSharedId_com$softwareag$saep$SensorEvent() {
		// set up a listener as a template:
		listener l:=__user.__startListener_com$softwareag$saep$SensorEvent();
		sharedId_com$softwareag$saep$SensorEvent := l.serialise() + "-" + 
			"";
		l.quit();
	}

	/*
	 * Initialise the window 'com.softwareag.saep.SensorEvent' for events of type com.softwareag.saep.SensorEvent
	 */
	action initWindow_com$softwareag$saep$SensorEvent() {
		generateSharedId_com$softwareag$saep$SensorEvent();
	}

	/* Code to extract the key from the input event **/
	action __getRowKey_com$softwareag$saep$SensorEvent(SensorEvent e) returns string {
		sequence<string> keyFields := [];

		/**
		 * This beautiful bit of unreachable code is designed to
		 * provoke typechecking errors for incompatibilities between
		 * the types of key elements. (and also with unique). It does
		 * this by going through all the key elements of this input's
		 * event type and trying to assign them to a dummy event of
		 * the first input, and vice versa (both directions in order
		 * to find any constant fields being used as keys) 
		 */
		if(false) then {
			SensorEvent specimen_e := new SensorEvent;
			SensorEvent specimen := new SensorEvent;

		}
		return keyFields.toString();
	}





	action handle_com$softwareag$saep$SensorEvent(action<string, boolean, float> __onEvent, integer retryCount, SensorEvent latest) {
		try {
			latest_com$softwareag$saep$SensorEvent := latest;
			float srcTime := currentTime;
			__onEvent( __getRowKey_com$softwareag$saep$SensorEvent( latest), false, srcTime);

		} catch (com.apama.exceptions.Exception __e) {
			if (retryCount > 0) then {
				qLogger.instanceLog("Caught exception (retries="+retryCount.toString()+") "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString()+" - "+__e.getStackTrace().toString(), "ERROR", false);
				terminationMgr.incrOutstandingRetries();
				on wait(1.0) {
					handle_com$softwareag$saep$SensorEvent(__onEvent, retryCount-1, latest);
					terminationMgr.decrOutstandingRetries();
				}
				return;
			} else {
				qLogger.instanceLog("Terminating query instance. Exception "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString(), "FATAL", false);
				shouldTerminateWorkers := true;
				die;
			}
		}
	}

	SensorEvent latest_com$softwareag$saep$SensorEvent;

	action initWindowListener_com$softwareag$saep$SensorEvent(dictionary<string, string> sharedIdToHeartbeatType) {
		__WindowLength length := __WindowLength(-1.0, -1, 0.0, 0.0);
		calculateWithin_com$softwareag$saep$SensorEvent();
		length.withinDuration := within_com$softwareag$saep$SensorEvent;

		__user.__handle_com$softwareag$saep$SensorEvent := handle_com$softwareag$saep$SensorEvent;
		dictionary<string, boolean> allSharedIds_and_hasSourceTime := {sharedId_com$softwareag$saep$SensorEvent:false};
		sequence<string> allSharedIds_and_hasSourceTime_keys := allSharedIds_and_hasSourceTime.keys();
		allSharedIds_and_hasSourceTime_keys.sort();
		sequence<string> allSharedIds := new sequence<string>;
		sequence<boolean> hasSourceTime := new sequence<boolean>;
		string sharedId_key;
		for sharedId_key in allSharedIds_and_hasSourceTime_keys {
			allSharedIds.append(sharedId_key);
			hasSourceTime.append(allSharedIds_and_hasSourceTime[sharedId_key]);
		}

		windowManager_com$softwareag$saep$SensorEvent.init(
			sharedId_com$softwareag$saep$SensorEvent,
			qryId,
			allSharedIds,
			length,
			__user.__listenFor_com$softwareag$saep$SensorEvent,
			calculateInputDefinitiveTime_com$softwareag$saep$SensorEvent,
			maintainWindow_com$softwareag$saep$SensorEvent,
			store,
			hubCtx,
			context.current().getId() = workers.gc_ctx.getId(),
			hasSourceTime,
			sharedIdToHeartbeatType
		);

		__StoredSnapshot ss;
		on all __StoredSnapshot(sharedId = sharedId_com$softwareag$saep$SensorEvent, managerId = windowManager_com$softwareag$saep$SensorEvent.managerId):ss {
			gotSnapshot(ss);
		}		
	}

	/** __WindowManager._calculateInputDefinitiveTime_cb */
	action calculateInputDefinitiveTime_com$softwareag$saep$SensorEvent(__StoredEventWindow sew, float maxTime, float maxWait) returns float {
		return calculateInputDefinitiveTime(sew.timestamps, sew.timestamps, getCurrentTime(maxTime, false), maxWait, 
				sew.heartbeatTime, new dictionary<string, __DelayedOutOfOrderTime>, "", false);
	}

	action maintainWindow_parse_com$softwareag$saep$SensorEvent(string str) returns sequence<SensorEvent> {
		return sequence<SensorEvent>.parse(str);
	}


	/** __WindowManager._maintainWindow_cb 
	* definitiveTime is the minimum of the definitive times of the other
	*  query inputs; this input needs to add its latest event (if addLatest
	*  is set), then calculate this input's definitive time, to obtain the
	*  new query definitive time.
	*  Returns the details of latest event to be received by the correlator
	*  (the event being processed here, i.e. latest_com$softwareag$saep$SensorEvent)
	*/

	action maintainWindow_com$softwareag$saep$SensorEvent(__StoredEventWindow sew, __WindowLength length, float minWaitTime, float maxTime, float definitiveTime, boolean addLatest, float srcTime, dictionary<string, __StoredEventWindow> windows) returns __LatestEvent {
		sequence<SensorEvent> seq;
		if(sew.seq_of_evts = "") then {
			seq := new sequence<SensorEvent>;
		} else {
			seq := maintainWindow_parse_com$softwareag$saep$SensorEvent(sew.seq_of_evts);
		}

		float srcTimeUsed := float.NAN;
		float now := getCurrentTime(maxTime, true);

		float prevDefinitiveTime := float.min(definitiveTime, calculateInputDefinitiveTime_com$softwareag$saep$SensorEvent(sew, now, length.waitTime));

		if(addLatest) then {
			seq.append(latest_com$softwareag$saep$SensorEvent);
			sew.timestamps.append(now);
			srcTimeUsed := now;		definitiveTime := float.min(definitiveTime, calculateInputDefinitiveTime_com$softwareag$saep$SensorEvent(sew, now, length.waitTime));

		} else {
			definitiveTime := prevDefinitiveTime;
		}


		// At least one, possibly both, of length.retainDuration and
		// withinDuration are non-negative (i.e. set).  We ignore those
		// that are not set, and if both are set, then we take the union
		// - which is the minimum of the 'oversize' count.
		integer oversize := seq.size();

		// apply retain restriction if set
		if (length.retainDuration >= 0) then {
			oversize := seq.size() - length.retainDuration;	}

		// apply within restriction if set:
		if( length.withinDuration >= 0.0 ) then {
			integer binSearchIndex := -1;
			float windowEnd := (definitiveTime / __TS.GRANULARITY).floor().toFloat() * __TS.GRANULARITY;		windowEnd := windowEnd - length.withinDuration;
			// And exclude things that are right on the edge, even if they've been bumped over by __TS.TIEBREAKER
			windowEnd := windowEnd + (__TS.GRANULARITY - __TS.TIEBREAKER);
			sequence<float> evtTimestamps := sew.timestamps;
			{
				integer oldest := 0;
				integer youngest := evtTimestamps.size();

				while oldest < youngest {
							
					integer midpoint := oldest + ((youngest - oldest) / 2);
					if evtTimestamps[midpoint] <= windowEnd then {
						oldest := midpoint + 1;
					} else {
						youngest := midpoint;	
					}	
				}
				if oldest = youngest and (oldest >= evtTimestamps.size() or  evtTimestamps[oldest] > windowEnd) then {
					binSearchIndex := oldest;
				}
			}
			if binSearchIndex < oversize then {
				oversize := binSearchIndex;
			}
		}

		// this can be negative, but the while loop will only remove
		// anything if it is > 0:
		while(oversize > 0) {
			seq.remove(0);
			sew.timestamps.remove(0);
			oversize := oversize - 1;
		}

		sew.seq_of_evts := seq.toString();
		return __LatestEvent(now, srcTimeUsed);
	}

	/*
	 * Populate the entry in definitiveTimes with the definitive time for this input.
	 * Only count events with (correlator-realm) timestamps up to uptoCorrelatorTime.
	 */
	action populateInputDefinitiveTime_com$softwareag$saep$SensorEvent(__StoredSnapshot ss, dictionary<string, float> definitiveTimes, boolean isPrevEval, dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders) {
		try {
			float uptoCorrelatorTime := ss.previousEvalTimestamp;
			float correlatorEvalTime := ss.previousEvalTimestamp;
			if not isPrevEval then {
				uptoCorrelatorTime := float.INFINITY;
				correlatorEvalTime := getCurrentTime(ss.latestEvent.processedTimestamp, false);
			}

			__StoredEventWindow sew := ss.allEvts[sharedId_com$softwareag$saep$SensorEvent];
			sequence<float> timestamps := [];
			sequence<float> correlatorTimestamps := [];
			integer i:=0;

			timestamps := sew.timestamps;
			correlatorTimestamps := sew.timestamps;

			// Calculate input definitive time based non-discarded events in window
			float heartbeat;
			if isPrevEval then {
				heartbeat := sew.previousHeartbeatTime;
			} else {
				heartbeat := sew.heartbeatTime;
			}
			definitiveTimes["com$softwareag$saep$SensorEvent"] := calculateInputDefinitiveTime(timestamps, correlatorTimestamps, correlatorEvalTime, 
	0.0, heartbeat, delayedOutOfOrders,
					"com$softwareag$saep$SensorEvent", false);
		} catch(com.apama.exceptions.Exception exc) {
			// Probably due to the entry not being there - treat as empty:
			return;
		}
	}

	/** Returns window relevant to this query instance, taking into considerations any retain clauses */
	action getWindow_com$softwareag$saep$SensorEvent(__StoredSnapshot ss) returns sequence<SensorEvent> {
		try {
			__StoredEventWindow sew := ss.allEvts[sharedId_com$softwareag$saep$SensorEvent];
			sequence<float> evtTimestamps := sew.timestamps;
			sequence<SensorEvent> contents;
			if sew.seq_of_evts = "" then {
				contents := new sequence<SensorEvent>;
			} else {
				contents := sequence<SensorEvent>.parse(sew.seq_of_evts);
			}

			integer i:=0;
			SensorEvent elem;
			while i < contents.size() {
				elem := contents[i];
				elem.setTimeDeep(evtTimestamps[i]);
				i := i+1;		}

			return contents;
		} catch(com.apama.exceptions.Exception exc) {
			// Probably due to the entry not being there - treat as empty:
			return new sequence<SensorEvent>;
		}
	}

	/** 
	 * Trims the window (sequence of events) so those later than the definitive time are not considered yet 
	 * and take into considerations retain/within clauses.
	 * This MUST be called after getWindow_com$softwareag$saep$SensorEvent and calculateQueryDefinitiveTime.
	 */
	action scopeWindowToDefinitiveTime_com$softwareag$saep$SensorEvent(sequence<SensorEvent> contents, float definitiveTime, __StoredSnapshot ss, boolean isSpeculating, float maxDefinitiveTime) {
		if contents.size() = 0 then {
			return;
		}

		// Determines the index BELOW which the window is accurate up to the definitive time (hence numEvtsBeforeDefinitiveTime
		// corresponds to the total number of events that can be used).
		integer numEvtsBeforeDefinitiveTime := binSearch_com$softwareag$saep$SensorEvent(definitiveTime, contents);
		if numEvtsBeforeDefinitiveTime = 0 then {
			contents.clear();
		} else if numEvtsBeforeDefinitiveTime > 0 then {
			contents.setSize(numEvtsBeforeDefinitiveTime); // truncate any events that are too recent (> dt)
		}

		// if we are speculating, we need to reach as far back as within the current max definitive time (DT will be infinity)
		if isSpeculating then {
			definitiveTime := maxDefinitiveTime;
		}
		// Trim window based on within expression
		// The end of the window has to be aligned across actual timestamps (__TS.GRANULARITY), ignoring __TS.TIEBREAKER
		definitiveTime := (definitiveTime / __TS.GRANULARITY).floor().toFloat() * __TS.GRANULARITY;
		float within_windowEnd := definitiveTime - (within_com$softwareag$saep$SensorEvent);
		// And exclude things that are right on the edge, even if they've been bumped over by __TS.TIEBREAKER
		within_windowEnd := within_windowEnd + (__TS.GRANULARITY - __TS.TIEBREAKER);
		integer oldestInWindow := binSearch_com$softwareag$saep$SensorEvent(within_windowEnd, contents);
		if oldestInWindow < 0 then {
			contents.clear();
		} else if oldestInWindow > 0 then {
			integer oversize := oldestInWindow; 
			//TODO Story 30128 - Think about how best to optimize this. 
			while(oversize > 0)  {
				contents.remove(0);
				oversize := oversize - 1;
			}
		}

		if contents.size() > 0 then {
			// Updates statistics
			if ss.sharedId = sharedId_com$softwareag$saep$SensorEvent then {
				queryScenarioService.reportWindowUpdate("com.softwareag.saep.SensorEvent", contents.size(), ss.key);
			}
		}
	}

	/* Calculate, validate and save 'within' duration */
	action calculateWithin_com$softwareag$saep$SensorEvent() {
		 
		within_com$softwareag$saep$SensorEvent := __user.__getWithin_com$softwareag$saep$SensorEvent();  

	}
	/* 
	 * Get index of oldest element whose timestamp is more recent than windowEnd, or -1 if contents is 
	 * empty or all elements are older than or equal to windowEnd. Assumes contents is sorted by timestamp from oldest 
	 * to most recent. 
	 */
	action binSearch_com$softwareag$saep$SensorEvent(float windowEnd, sequence<SensorEvent> contents) returns integer {
		if contents.size() <=0 or contents[contents.size() - 1].getTime() < windowEnd then {
			return -1; 
		}

		integer binSearchIndex := -1;
		{
			integer oldest := 0;
			integer youngest := contents.size();

			while oldest < youngest {
						
				integer midpoint := oldest + ((youngest - oldest) / 2);
				if contents[midpoint].getTime() <= windowEnd then {
					oldest := midpoint + 1;
				} else {
					youngest := midpoint;	
				}	
			}
			if oldest = youngest and (oldest >= contents.size() or  contents[oldest].getTime() > windowEnd) then {
				binSearchIndex := oldest;
			}
		}

		return binSearchIndex;
	}

	/**
	 * This is the form that an element within the window of com.softwareag.saep.SensorEvent takes in the memory store. It contains the event and its
	 * timestamp, as stringifying and parsing events ignores the event's getTime(), so it has to be kept in a separate field alongside.
	 */
	event __Stored_com$softwareag$saep$SensorEvent {
		SensorEvent value;
		float timestamp;
	}

	/**
	 * An indexable used to identify uniqueness of input as per with-unique clause
	 */


	 

	/* All pattern definition and evaluation code */
	/* ========================================== */


	/** An index into each of the types.
	 * 
	 * Iterates the window contents across all types on demand.
	 */
	event __WindowsIterator {

		// current iteration state:
		string currentType;	
		integer currentIndex;
		float currentTimestamp;
		/** Contents of each window */
		wildcard sequence<SensorEvent> window_com$softwareag$saep$SensorEvent;
		/** Index into window contents where this iterator is currently pointing */
		wildcard integer idx_com$softwareag$saep$SensorEvent; 

		sequence<string> types;
		
		/* Determine if we are evaluating against time or event. If true then return the 
		   current event type as empty but time of event will be available*/
		boolean timeMode;
		
		/* Source timestamp (which is known to be unique) of the latest event received by correlator*/
		float timestampOfLatestReceived;

		/* Window index into at which the current event is located. Only valid if isDone() returns 
			false. Use getType() to determine the type of the element to which the index applies.  */ 
		action getIndex() returns integer {
			return currentIndex;
		}

		action getType() returns string {
			if timeMode then {
				return "";
			}
			return currentType;
		}

		/* Get the stringified form of the event at the current index for the current type */
		action getStringified() returns string {
			 
			/* Switch based on type of input */
			return window_com$softwareag$saep$SensorEvent[idx_com$softwareag$saep$SensorEvent].toString();
		}

		action getCurrentTimestamp() returns float {
			return currentTimestamp;
		}

		/* Initialize the iterator. On completion the most recent event in the combined window
			can be retrieved using getIndex() and getType().
			@param endTime - an optional (ignored if NaN) timestamp to append to the end of the windows
		 */
		action init(float endTime) {
			types := ["com$softwareag$saep$SensorEvent"];
			types.reverse();
			idx_com$softwareag$saep$SensorEvent := window_com$softwareag$saep$SensorEvent.size() - 1;
			currentType := types[0];
			currentTimestamp := float.INFINITY;
			idx_com$softwareag$saep$SensorEvent := idx_com$softwareag$saep$SensorEvent + 1;
			if(not endTime.isNaN()) then {
				currentTimestamp := endTime;
				currentType := "";
				currentIndex := getIndexForType(types[0]);
			} else {
				next();
			}
		}

		/* Increment the iterator to point to the next event in the combined window. If there are no
			more events then isDone() will return true. Otherwise, use getIndex() and getType() to
			access the event. */
		action next() {
			if(currentType = "") then {
				currentType := types[0];
			}
			 
			/* Switch based on type of input */
			idx_com$softwareag$saep$SensorEvent := idx_com$softwareag$saep$SensorEvent - 1;
			string nextPrevType:="";
			float nextPrevTime:=-float.INFINITY;
			integer nextIndex:= -1;

			string type;
			for type in types {
				float evtTime:=getTimestamp(type);

				// assert (t >= currentTimestamp);
				if evtTime > nextPrevTime then {
					nextPrevTime := evtTime;
					nextPrevType := type;
					nextIndex:=getIndexForType(type);
				}
			}
			currentTimestamp := nextPrevTime;
			currentType := nextPrevType;
			currentIndex := nextIndex;
		}

		action isLatestReceived() returns boolean {
			return timestampOfLatestReceived = currentTimestamp;
		}

		action isDone() returns boolean {
			return currentIndex = -1;
		}

		action getTimestamp(string type) returns float {
			 
			/* Switch based on type of input */
			if idx_com$softwareag$saep$SensorEvent < 0 then {
				return -float.INFINITY;
			} else {
				return window_com$softwareag$saep$SensorEvent[idx_com$softwareag$saep$SensorEvent].getTime();
			}
		}

		action getIndexForType(string type) returns integer {
			 
			/* Switch based on type of input */
			return idx_com$softwareag$saep$SensorEvent;
		}
		
		action setTimeMode(boolean isTimeMode) {
			timeMode := isTimeMode;
		}
	}


	/** Internal event for holding evaluation state for a single find block */
	event __EvaluationState {

		// the user object (contains all user defined expressions/actions)
		__ElasticQueryUserCode __user;

		// Query scenario service event
		__QueryScenarioService queryScenarioService;

		// current index into the merged ordered window:
		__WindowsIterator inputs;

		// the current potential matchsets:
		dictionary<integer, __MatchSet> matchSets;
		
		// Matchsets spawned from the current matchset:
		sequence<integer> addedMatchsets;

		// whether we are matching the 'current' or latest event:
		boolean matchingCurrentEvent;
		
		// how many times we have consumed (coassigned) any events:
		integer haveConsumed;
		
		// the most recent matchset id
		integer mostRecentMatchSet;

		// whether to trigger even if the latest event is not in a matchset
		boolean findAllMatches;


		// duration for within filters (if any)

		//wait durations (if any)

		// The maximum time we really have (not just this evaluation)
		float maxDefinitiveTime;	

		// The timestamp of previously evaluated event
		float previousEventTimestamp;
		/* Effective timestamp of current event. Currently used by within filter. Initially 
		 * equal to the time of current event. Later it is set to the startTime of wait 
		 * interval when wait gets consumed. This ensures that within node evaluates 
		 * properly for event outside of wait interval as wait pattern causes whole 
		 * pattern to be evaluated for event outside wait interval.
		 * */
		float effectiveEventTimestamp;
		// value of the partition key for which evaluation is being done
		string key;
		// denote that pattern is being evaluated on expiry of some future wait
		boolean evalOnWaitExpiry;
		// If a wait evaluate while evalFutureTimer is true then wait is future wait
		boolean evalFutureTimer;
		// start time of the expired future wait
		float expiredWaitStartTime;
		// action to re-evaluate pattern on expirey of future wait
		action<__RestartQueryTimer> reEvaluateInputsAction;

		/** Evaluate a find pattern, calling __ElasticQueryUserCode.__findAction on a match
		  *
		  * Walks the window contents, evaluating the pattern using
		  * each of a set of MatchSets.
		  * Calls the __ElasticQueryUserCode.__findAction if a top level MatchSet exists
		  * which meets all of the where clauses and constraints
		  */
		action patternTrigger(float timeAtEndOfWindow, dictionary<string, float> inputDefinitiveTimes, dictionary<string, float> inputWaitTimes, boolean isSpeculating, dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders) {
			///// Initialise state
			inputs.init(timeAtEndOfWindow);
			addInitialMatchSet();

			previousEventTimestamp := float.INFINITY;
			// ids of MatchSets that are final
			dictionary<integer, integer> finalMatchSetIds := new dictionary<integer, integer>;
			// in case of evalOnWaitExpiry, matchingCurrentEvent will get set to true
			// once future wait gets consumed.
			// when speculating matchingCurrentEvent only gets set to true if processing
			// the most recently received event.
			if not evalOnWaitExpiry then {
				matchingCurrentEvent := true;
			}
				
			boolean inputsDone := false;
			// first time pattern will be evaluated against no event to find future waits
			evalFutureTimer := true; 
			///// walk the window
			// for each event (until we have a final matchset, or no matchsets left)
			// we also evaluate pattern for window with no event and time -float.INFINITY
			while (not inputsDone) and (matchSets.size() > 0) {
				if isSpeculating then {
					matchingCurrentEvent := inputs.isLatestReceived();
				}
				__MatchSet matchSet;
				// for each matchset (present at the beginning
				// of processing this event - doesn't evaluate
				// matchsets added during this loop):
				for matchSet in matchSets.values() {
					///// evaluate the pattern twice:
					// once against time only then against event
					processPattern(matchSet, finalMatchSetIds, true);
					processPattern(matchSet, finalMatchSetIds, false);
				}

				evalFutureTimer := false;
				if (inputs.isDone()) then {
					inputsDone := true;
				}

				previousEventTimestamp := inputs.getCurrentTimestamp();
				inputs.next();
				// for the current/ latest event only: if it
				// is not coassigned, we abort the pattern
				// evaluation:
				if matchingCurrentEvent and haveConsumed = 0 and not findAllMatches then {
					return;
				}
				matchingCurrentEvent := false;
			}

			if finalMatchSetIds.size() > 0 then {
				if isSpeculating then {
					// determine when any matches triggered by the event most recently received by the correlator
					// will be less-than or equal to definitive time then re-evaluate at this time if it is currently
					// greater-than definitive time i.e. determine how long to wait for if necessary
					// (although explained using definitive time the actual calculation is in terms of real time)
					__MatchSet ms;
					integer fmsId;
					// The time at which this match occurred/will occur
					float ct := currentTime;
					for fmsId in finalMatchSetIds.keys() {
						ms := matchSets[fmsId];
						if ms.containsCurrent <= 0 then {
							continue;
						}

						float maxTS := ms.mostRecentTime();
						float speculativeWaitExpiryTime := ct;
						string eType;
						for eType in inputDefinitiveTimes.keys() {
							if inputDefinitiveTimes[eType] < maxTS then {
								__DelayedOutOfOrderTime delayed := delayedOutOfOrders.getOrDefault(eType);
								if delayed.maxInputEventTimestamp >= maxTS then {
									speculativeWaitExpiryTime := float.max(speculativeWaitExpiryTime, float.min(maxTS + inputWaitTimes.getOr(eType, 0.0), delayed.correlatorTimeBecomesDefinitive));
								} else {
									speculativeWaitExpiryTime := float.max(speculativeWaitExpiryTime, maxTS + inputWaitTimes.getOr(eType, 0.0));
								}
							}
						}

						if speculativeWaitExpiryTime > ct then {
							// wait for time+epsilon to avoid floating-point rounding errors, specifically the wait being slightly less than it should be
							speculativeWaitExpiryTime := speculativeWaitExpiryTime.nextafter(float.INFINITY);
							reEvaluateInputsAction(__RestartQueryTimer(queryScenarioService.name, queryScenarioService.instancePxyId, key, ct, speculativeWaitExpiryTime, false));
						}
					}

					return;
				}

				integer id:= mostRecentMatchSet;
				sequence<__MatchSet> allMatches := new sequence<__MatchSet>;
				boolean anyHaveCurrent := false;
				boolean anyFireNow := false;
				while(id != -1) {
					__MatchSet matchSet := matchSets[id];
					// check that there are no pending timers
					if finalMatchSetIds.hasKey(id) then {
						if matchSet.containsCurrent > 0 then {
							anyFireNow := processPendingWaitTimers(matchSet, inputWaitTimes) or anyFireNow;
							anyHaveCurrent := true;
						}

						allMatches.append(matchSet);
					}
					id := matchSet.next;
				}

				// if no new matchsets (i.e. with the current event), then suppress generating output:
				if not findAllMatches and ((not anyHaveCurrent) or (not anyFireNow)) then {
					return;
				}

				allMatches.reverse();
				__user.__processAggregates(allMatches);
				return; 

			}
		}

		/** Process pattern against time only or against event*/
		action processPattern(__MatchSet matchSet, dictionary<integer, integer> finalMatchSetIds, boolean withTime) {
			inputs.setTimeMode(withTime);
			
			effectiveEventTimestamp := inputs.getCurrentTimestamp();
			if matchSets.hasKey(matchSet.id) and not finalMatchSetIds.hasKey(matchSet.id) and evaluatePattern(matchSet) then {
				// we have a complete potential matchset.  If it matches the where clause, ...
				if pattern_node0_where(matchSet) then {
					// .. then we have a final matchset
					finalMatchSetIds.add(matchSet.id, matchSet.id);
				} else {
					discard(matchSet);
				}
			}
		}
		
		/** Process pending wait timers. If there are atleast one pending timer
		* which need to be evaluated in future then it returns false. */
		action processPendingWaitTimers(__MatchSet matchSet, dictionary<string,float> inputWaitTimes) returns boolean {
			// there will not be any pending timers when evaluating against
			// wait expiry because we are evaluating after all required waits are expired
			if evalOnWaitExpiry then {
				return true;
			}
			boolean noPendingTimer := true;
			float waitExpiryTime := -float.INFINITY;
			float waitStartTime := -float.INFINITY;
			string actionName := "";
			if not noPendingTimer then {
				// the waitStartTime is supplied so that wait
				// expression will evaluate to true when
				// evaluation reaches to that event
				reEvaluateInputsAction(__RestartQueryTimer(queryScenarioService.name, queryScenarioService.instancePxyId, key, waitStartTime, waitExpiryTime, true));
			}

			return noPendingTimer;
		}

		/** read current window content and corresponding event timestamps */
		action currentWindowContents(boolean forLogging) returns sequence<string> {
			inputs.init(float.NAN);
			sequence<string> contentsAndTimestamps := new sequence<string>;
			sequence<string> windowDump:=new sequence<string>;
			sequence<string> timestamps:=new sequence<string>;
			while(not inputs.isDone()) {
				windowDump.insert(inputs.getStringified(),0);
				decimal actualTimestamp := (inputs.getCurrentTimestamp().toDecimal() / __TS.GRANULARITY.toDecimal()).round().toDecimal() * __TS.GRANULARITY.toDecimal();
				timestamps.insert(actualTimestamp.toFloat().toString(), 0);
				inputs.next();
			}
			if forLogging then {
				contentsAndTimestamps.append("Sensors window contents: ["+(",".join(windowDump))+"]");
				contentsAndTimestamps.append("Sensors window timestamps: ["+(",".join(timestamps))+"]");
			} else {
				contentsAndTimestamps.append("["+(",".join(windowDump))+"]");
				contentsAndTimestamps.append("["+(",".join(timestamps))+"]");
			}

			return contentsAndTimestamps;
		}

		constant integer EVAL_MATCHEVENTS := 1;
		constant integer EVAL_EVAL := 2;
		constant integer EVAL_CONDITIONS := 3;

		/** Evaluate the entire pattern (including withouts, withins, etc) */
		action evaluatePattern(__MatchSet matchSet) returns boolean {
			addedMatchsets:= new sequence<integer>;
			boolean prev_has_s1 := matchSet.has_s1;
			boolean p := pattern_node_0(matchSet, EVAL_MATCHEVENTS);
			p := pattern_node_0(matchSet, EVAL_EVAL);
			boolean p2 := pattern_node_0(matchSet, EVAL_CONDITIONS);
			p := p and p2;
			integer msId;
			while addedMatchsets.size() > 0 {
				sequence<integer> prevAdded := addedMatchsets;
				addedMatchsets := new sequence<integer>;
				for msId in prevAdded {
					if matchSets.hasKey(msId) then {
						matchSet := matchSets[msId];
						boolean q := pattern_node_0(matchSet, EVAL_EVAL);
						boolean q2 := pattern_node_0(matchSet, EVAL_CONDITIONS);
						if q or q2 then {
							__user.__qLogger.instanceLog("Unexpectedly evaluated a spawned matchset to true", "ERROR", false);
						}
					}
				}
			}
			return p;
		}

		/* Start of evaluation actions for each node in the pattern */
		action pattern_node0_where(__MatchSet matchSet) returns boolean {

			// what positive where clauses can we now evaluate?
			// what without where clauses can we now evaluate?

			// do any withouts invalidate this matchset?

			return true;
		}

		// utility methods for managing MatchSets:
		/** Add the initial matchset. */
		action addInitialMatchSet() {
			__MatchSet initial := new __MatchSet;
			initial.init();
			initial.next := -1;
			initial.prev := -1;
			mostRecentMatchSet := initial.id;
			matchSets.add(initial.id, initial);
		}

		/** Find the most recent matchset that is in the supplied set */
		action findMostRecentIn(dictionary<integer, integer> set) returns integer {
			integer id:= mostRecentMatchSet;
			while (id != -1 and not set.hasKey(id)) {
				id := matchSets[id].next;
			}
			return id;
		}

		/** Add a match set */
		action addMatchSetAfter(__MatchSet prior) returns __MatchSet {
			if(not matchSets.hasKey(prior.id)) then {
				return prior;
			}
			__MatchSet newms := prior.clone();
			newms.init();
			newms.prev := prior.id;
			newms.next := prior.next;
			prior.next := newms.id;
			if(newms.next != -1) then {
				matchSets[newms.next].prev := newms.id;
			}
			matchSets.add(newms.id, newms);
			addedMatchsets.append(newms.id);
			return newms;
		}

		/** discard a match set */
		action discard(__MatchSet matchSet) {
			if matchSets.hasKey(matchSet.id) then {
				// maintain linked list:
				if(matchSet.prev != -1) then {
					if matchSets.hasKey(matchSet.prev) then {
						matchSets[matchSet.prev].next :=  matchSet.next;
					} else {
						__user.__qLogger.instanceLog("Unexpected matchset (prev) " + matchSet.prev.toString() + " in " + self.toString(), "ERROR", false);
					}
				}
				if(matchSet.next != -1) then {
					if matchSets.hasKey(matchSet.next) then {
						matchSets[matchSet.next].prev :=  matchSet.prev;
					} else {
						__user.__qLogger.instanceLog("Unexpected matchset (next) " + matchSet.next.toString() + " in " + self.toString(), "ERROR", false);
					}
				}
				if mostRecentMatchSet = matchSet.id then {
					mostRecentMatchSet := matchSet.next;
				}
				matchSets.remove(matchSet.id);
			} // else may have already been discarded - ignore
		}


		action evalConditions_node_0(__MatchSet matchSet) returns boolean {

			// what positive where clauses can we now evaluate?
			// what without where clauses can we now evaluate?

			// do any withouts invalidate this matchset?

			return true;
		}

		/* Pattern node for a coassignment from com$softwareag$saep$SensorEvent to s1 */
		action pattern_node_0(__MatchSet matchSet, integer evalState) returns boolean {
			// if we already have this coassignmnet, we evaluate to true, and don't copy or do anything:
			if matchSet.triggered_s1 > 0 then {
				if (evalState = EVAL_CONDITIONS) and (matchSet.triggered_s1  = EVAL_EVAL) then {
					matchSet.triggered_s1 := EVAL_CONDITIONS;
					boolean matchedWhere := evalConditions_node_0(matchSet);
					if not matchedWhere then {
						discard(matchSet);
					}
					return matchedWhere;
				}
				return true;
			}

			if "com$softwareag$saep$SensorEvent" = inputs.getType() then {
				if evalState = EVAL_MATCHEVENTS then {
					// coassign the event
					matchSet.csnmt_s1 := inputs.window_com$softwareag$saep$SensorEvent[inputs.getIndex()];
					matchSet.has_s1 := true;
					matchSet.timestamp_s1 := inputs.getCurrentTimestamp();

					haveConsumed := haveConsumed + 1;
					if matchingCurrentEvent then {
						matchSet.containsCurrent := matchSet.containsCurrent + 1;
					}

					return true;
				}
			}

			if evalState = EVAL_EVAL and matchSet.has_s1 then {
				boolean doCopy := true;
					__MatchSet copy := addMatchSetAfter(matchSet);
					copy.has_s1 := false;
					copy.triggered_s1 := 0;
					if matchingCurrentEvent then {
						copy.containsCurrent := copy.containsCurrent - 1;
					}
				matchSet.triggered_s1 := EVAL_EVAL;
				return true;
			} else {
				return false;
			}
		}

	}

	/* End of evaluation actions for each node in the pattern */

	action initWithinFilters() {
	}

	//wait duration
	action initWaits() {
	}
	
	/* Common code */
	/* =========== */
	
	/** Gets the next context for round-robin distribution of input events. */
	action nextContext() returns context {
		if workers.ctxs.size() <= 1 then {
			qLogger.instanceLog("Invalid state: No worker contexts.", "ERROR", false);
			shouldRespawn := false;
			die;
		}
		
		index := (index + 1) % workers.ctxs.size();
		if workers.ctxs[index].getId() = workers.gc_ctx.getId() then  {
			index := (index + 1) % workers.ctxs.size();
		}
		return workers.ctxs[index];
	}
	
	/** 
	* Called if the system is reconfigured.
	* Updates the set of contexts over which to distribute events.
	*/
	action onNewContexts( __WorkerContextSet workers_ ) {
		workers := workers_;
		context ctx;
		for ctx in workers.ctxs {
			spawn newWorker() to ctx;
		}

		queryScenarioService.updateWorkerContexts(workers);
	}
	
	/** Terminates a worker instance */
	action terminateWorker() {
		// Check if we've got any waits outstanding before shutting down.
		shouldRespawn := false;
		die;
	}
	
	/** Re-evaluate patterns
	* timer - details of the time we should re-evaluate at.
	*/
	action reEvaluateInputs(__RestartQueryTimer timer) {
		if not timerMgr.hasTimer(timer) then {
			timerMgr.add(timer);
			if(timer.waitExpiryTime > currentTime) then {
				on wait(timer.waitExpiryTime - currentTime) {
					fireTimer(timer, 10);
				}
			} else {
				fireTimer(timer, 10);
			}
		}
	}

	/** Find new definitive times since our last evaluation.
	* populates definitiveTimes with any source-realm definitive timestamps which were not definitive as of the last evaluation.
	*/
	action findValidNewDefinitiveTimes(sequence<float> definitiveTimes, float previousDefinitiveTime, float definitiveTime, float waitTime, sequence<float> sourceTimes, sequence<float> times) {
		integer i:=0;
		while(i < times.size() and i < sourceTimes.size()) {
			// must be (previous, current] definitive time, and not invalid (discarded due to delay > waitTime)
			if sourceTimes[i] > previousDefinitiveTime and sourceTimes[i] <= definitiveTime and times[i] - sourceTimes[i] <= waitTime then {
				definitiveTimes.append(sourceTimes[i]);
			}
			i := i + 1;
		}
	}


	/** 
	 * Process a stored snapshot for one of the inputs of this query
	 */
	action gotSnapshot(__StoredSnapshot ss) {
		boolean isEvalOnWaitExpiry:= ss.isEvalOnWaitExpiry;
		float expiredWaitStartTime:= ss.expiredWaitStartTime;
		float expiredWaitEndTime := ss.expiredWaitEndTime;

		// Set up input __EvaluationState variables
		__EvaluationState evalState := newEvaluationState(ss);
		dictionary<string, float> inputWaitTimes := new dictionary<string, float>;
		dictionary<string, float> dict := new dictionary<string, float>;

		// no source timestamps => single evaluation always
		if not anyHaveSourceTimestamps then {
			evalWindowOnce(evalState, ss, ss.latestEvent.processedTimestamp, currentTime, isEvalOnWaitExpiry, expiredWaitStartTime, expiredWaitEndTime, false, dict, dict, new dictionary<string, __DelayedOutOfOrderTime>);
		} else {
			inputWaitTimes := {};
			// Calculate previous definitive time, based on previousEvalTimestamp
			dictionary<string, float> previousDefinitiveTimes := new dictionary<string, float>;
			dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders := {};
			populateInputDefinitiveTime_com$softwareag$saep$SensorEvent(ss, previousDefinitiveTimes, true, delayedOutOfOrders);

			// Calculate current defintive time:
			dictionary<string, float> definitiveTimesDict := new dictionary<string, float>;
			populateInputDefinitiveTime_com$softwareag$saep$SensorEvent(ss, definitiveTimesDict, false, delayedOutOfOrders);
			float previousDefinitiveTime := calculateQueryDefinitiveTime(previousDefinitiveTimes, "previous");
			float definitiveTime := calculateQueryDefinitiveTime(definitiveTimesDict, "current");

			float beginDefinitiveSearchRange := previousDefinitiveTime;
			float endDefinitiveSearchRange := definitiveTime;
			// determine what new definitive times we have:
			sequence<float> definitiveTimes := []; // populated by calls to findValidNewDefinitiveTimes
			{
				sequence<float> sourceTimes := ss.allEvts[sharedId_com$softwareag$saep$SensorEvent].timestamps;
				float waitTime:=0.0;
				findValidNewDefinitiveTimes(definitiveTimes, beginDefinitiveSearchRange, endDefinitiveSearchRange, waitTime, sourceTimes, ss.allEvts[sharedId_com$softwareag$saep$SensorEvent].timestamps);
			}
			definitiveTimes.sort();

			float evalDefinitiveTime;
			for evalDefinitiveTime in definitiveTimes {
				evalWindowOnce(evalState.clone(), ss.clone(), evalDefinitiveTime, definitiveTime, false, float.NAN, float.NAN, false, dict, inputWaitTimes, delayedOutOfOrders);
			}

			if anyHaveSourceTimestamps and not isEvalOnWaitExpiry then {
				// now perform speculative search through window to determine if any timers should be set up
				evalWindowOnce(evalState, ss, float.INFINITY, definitiveTime, false, float.NAN, float.NAN, true, definitiveTimesDict, inputWaitTimes, delayedOutOfOrders);
			}
		}
	}

	/** 
	 * Evaluate the window, up to the point indicated in source time by definitive time
	 */
	action evalWindowOnce(__EvaluationState evalState, __StoredSnapshot ss, float definitiveTime, float maxDefinitiveTime, boolean isEvalOnWaitExpiry, float expiredWaitStartTime, float expiredWaitEndTime, boolean isSpeculating, dictionary<string, float> definitiveTimes, dictionary<string, float> inputWaitTimes, dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders) {
		// Set up the rest of input __EvaluationState variables
		evalState.maxDefinitiveTime := maxDefinitiveTime;
		evalState.evalOnWaitExpiry := isEvalOnWaitExpiry;
		evalState.expiredWaitStartTime := expiredWaitStartTime;
		evalState.findAllMatches := ss.findAllMatches;

		// Trim relevant windows based on the queries definitive time
		scopeWindowToDefinitiveTime_com$softwareag$saep$SensorEvent(evalState.inputs.window_com$softwareag$saep$SensorEvent, definitiveTime, ss, isSpeculating, maxDefinitiveTime);
		// set evalState.inputs.timestampOfLatestReceived to the timestamp available to
		// __WindowsIterator which is sew.sourceTimestamp if available, otherwise sew.timestamp
		evalState.inputs.timestampOfLatestReceived := ss.latestEvent.sourceTimestamp;

		// Execute patternTrigger
		// If isSpeculating = true we scan through once to determine any future matchSets and get the max wait value
		evalState.patternTrigger(expiredWaitEndTime, definitiveTimes, inputWaitTimes, isSpeculating, delayedOutOfOrders);
	}


	/**
	 * Actually re-evaluate an expired timer
	 */
	action fireTimer(__RestartQueryTimer timer, integer retryCount) {
		string key := timer.windowKey;
		__StoredSnapshot ss;
		try {
			ss := windowManager_com$softwareag$saep$SensorEvent.getSnapshot(key, false);
			// correlator timestamp of events can go
			// slightly ahead of correlator time, so
			// processedTimestamp is the max of
			// ss.latestEvent and the timer expiry time:
			ss.latestEvent.processedTimestamp := float.max(ss.latestEvent.processedTimestamp, timer.waitExpiryTime);
			ss.isEvalOnWaitExpiry := true;
			ss.expiredWaitStartTime := timer.waitStartTime;
			ss.expiredWaitEndTime := timer.waitExpiryTime;
		} catch (com.apama.exceptions.Exception __e) {
			if (retryCount > 0) then {
				qLogger.instanceLog("Caught exception (retries="+retryCount.toString()+") "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString()+" - "+__e.getStackTrace().toString(), "ERROR", false);
				terminationMgr.incrOutstandingRetries();
				on wait(1.0) {
					fireTimer(timer, retryCount - 1);
					terminationMgr.decrOutstandingRetries();
				}
				return;
			} else {
				qLogger.instanceLog("Terminating query instance. Exception "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString(), "FATAL", false);
				shouldTerminateWorkers := true;
				die;
			}
		}
		// We have timers per query instance; just eval locally.
		gotSnapshot(ss);
		timerMgr.remove(timer);
	}

	// Set up variables required when instantiating __EvalutationState
	action newEvaluationState(__StoredSnapshot ss) returns __EvaluationState {
		__EvaluationState evalState := new __EvaluationState;
		evalState.key := ss.key;
		evalState.reEvaluateInputsAction := reEvaluateInputs;
	
		evalState.queryScenarioService := queryScenarioService;
		__user.__qLogger := qLogger;
		evalState.__user := __user.clone();
		
		// set the key values:
		sequence<string> keyValues := sequence<string>.parse(ss.key);
		integer i:=0;

		evalState.inputs.window_com$softwareag$saep$SensorEvent := getWindow_com$softwareag$saep$SensorEvent(ss);

		shouldRespawn := true;
		return evalState;
	}

	action getCurrentTime(float maxTimestamp, boolean breakTie) returns float {
		 if(currentTime > maxTimestamp) then { 	 
			return currentTime;
		} else if breakTie then {
			return maxTimestamp + __TS.TIEBREAKER;
		} else {
			return maxTimestamp;
		}
	}

	/* 
	 * Calculates the definitive time of the input window corresponding to the 
	 * sourceTimestamps passed in. Calculated as the maximum of:
	 * 	Most recent timestamp or source timestamp
	 * 	Correlator's current time - input wait time
	 */
	action calculateInputDefinitiveTime(sequence<float> definitiveTimestamps, 
			sequence<float> correlatorTimestamps, 
			float evalCurrentTime, float inputWait, 
			float heartbeatTime, 
			dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders, 
			string thisInput, 
			boolean outOfOrder) returns float {

		if outOfOrder then {
			return float.max(evalCurrentTime - inputWait, heartbeatTime);
		}

		float dt := -float.INFINITY;
		float maxTimeOutOfOrder := -float.INFINITY;
		float timeWillBecomeDefinitive := -float.INFINITY;
		integer i:=0;
		while(i < definitiveTimestamps.size()) {
			float evtDelayTime := correlatorTimestamps[i] - definitiveTimestamps[i];
			float evtAge := evalCurrentTime - correlatorTimestamps[i];
			if( evtDelayTime <= queryScenarioService.delayLeeway.delayLeeway or 
			     evtAge >= queryScenarioService.delayLeeway.reorderBuffer) then {
				if maxTimeOutOfOrder = -float.INFINITY then {
					dt := float.max(dt, definitiveTimestamps[i]);
				}
			} else {
				maxTimeOutOfOrder := float.max(maxTimeOutOfOrder, definitiveTimestamps[i]);
				timeWillBecomeDefinitive := float.max(timeWillBecomeDefinitive, correlatorTimestamps[i] + queryScenarioService.delayLeeway.reorderBuffer);
			}
			i := i + 1;
		}
		if(maxTimeOutOfOrder != -float.INFINITY and thisInput != "") then {
			delayedOutOfOrders[thisInput] := __DelayedOutOfOrderTime(maxTimeOutOfOrder, timeWillBecomeDefinitive);
		}

		return float.max(float.max(dt, evalCurrentTime - inputWait), heartbeatTime);
	}

	/* 
	 * Calculates the definitive time of the query. Calculated as the minimum of
	 * all the input definitive times.
	 * Definitive time defines the time the query is accurate up to, across all
	 * inputs, taking into account any source times the inputs may have. It is the point
	 * in time for which the query runtime knows it has received all the events it is 
	 * going to receive. Only from this time onwards will patterns match.
	 * This is definied for queries with and without any getSourceTime actions 
	 * implemented but only has special method when at least one is present;
	 */
	action calculateQueryDefinitiveTime(dictionary<string, float> dts, string type) returns float {
		float dt := float.INFINITY;
		string dt_key;
		for dt_key in dts.keys() {
			dt := float.min(dt, dts[dt_key]);
		}

		return dt;
	}
	
	action getMetadataMap() returns dictionary<string, string> {
		return {
"Author":"Software AG"
				};
	}
}

// QUERY SOURCE:
// This is a base64-encoded copy of the query source (generated by rel/9.10.0.x@275046) that generated this .mon file
// Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
// KioqKioqKioqKioqKioqKioqKioqKg0KLy8gVGl0bGU6ICAgICAgICAgU2Vuc29ycw0KLy8gRGVz
// Y3JpcHRpb246ICAgQ291bnRzIHRoZSBzZW5zb3IgZXZlbnRzIGluIGEgdGltZSB3aW5kb3cNCi8v
// IERlcGVuZGVuY2llczogIEV2ZW50IHR5cGUgZGVmaW5pdGlvbg0KLy8gQXV0aG9yOiAgICAgICAg
// U29mdHdhcmUgQUcNCi8vDQovLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
// KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQoNCnBhY2thZ2UgY29tLnNv
// ZnR3YXJlYWcuc2FlcDsNCg0KcXVlcnkgU2Vuc29ycyB7CQ0KCW1ldGFkYXRhIHsNCgkJIkF1dGhv
// ciI6IlNvZnR3YXJlIEFHIg0KCX0NCgkNCglpbnB1dHMgIHsNCgkJU2Vuc29yRXZlbnQoKSB3aXRo
// aW4gNSBzZWM7DQoJfQ0KDQoJZmluZCBldmVyeSBTZW5zb3JFdmVudCA6IHMxDQoJc2VsZWN0IGNv
// bS5hcGFtYS5hZ2dyZWdhdGVzLmNvdW50KCkgOiBlMSAgew0KCQklY3VzdG9tKCJ0aXRsZSI6IkN1
// c3RvbSBFUEwgQWN0aW9uIDEiKSB7DQoJCQlzZW5kIENvdW50ZXIoZTEpIHRvICIiOw0KCQl9DQoJ
// fQ0KfQ0K

TIME 0000000c 1484234970,1
TIME 0000000c 1484234970,2
TIME 0000000d 1484234970,30
TIME 0000000c 1484234970,3
TIME 0000000c 1484234970,5
TIME 0000000c 1484234970,6
TIME 0000000c 1484234970,7
TIME 0000000c 1484234970,8
TIME 0000000c 1484234970,9
TIME 0000000d 1484234970,10
TIME 0000000d 1484234970,11
TIME 0000000d 1484234970,12
TIME 0000000d 1484234970,13
TIME 0000000d 1484234970,14
TIME 0000000d 1484234970,15
TIME 0000000d 1484234970,16
TIME 0000000d 1484234970,17
TIME 0000000d 1484234970,18
TIME 0000000d 1484234970,19
TIME 0000000d 1484234970,20
TIME 0000000d 1484234970,21
TIME 0000000d 1484234970,22
TIME 0000000d 1484234970,23
TIME 0000000d 1484234970,24
TIME 0000000d 1484234970,25
TIME 0000000d 1484234970,26
TIME 0000000d 1484234970,27
TIME 0000000d 1484234970,28
TIME 0000000d 1484234970,29
EVNT 0000008a 10612171611911497990 "",com.softwareag.saep.RawEvent(4,10753295594424116,27187,-405,451,5053947,341072227,-1830,9748,1268,-4018,9154,198);
TIME 0000000e 1484234970.1,1
TIME 0000000e 1484234970.2,1
TIME 0000000e 1484234970.2,3
TIME 0000000e 1484234970.3,1
TIME 0000000e 1484234970.4,1
TIME 0000000e 1484234970.5,1
TIME 0000000e 1484234970.5,3
TIME 0000000e 1484234970.6,1
TIME 0000000e 1484234970.7,1
TIME 0000000e 1484234970.8,1
TIME 0000000e 1484234970.9,1
TIME 0000000c 1484234971,1
TIME 0000000d 1484234971,31
TIME 0000000e 1484234971.1,1
TIME 0000000e 1484234971.2,1
TIME 0000000e 1484234971.3,1
TIME 0000000e 1484234971.4,1
TIME 0000000e 1484234971.5,1
TIME 0000000e 1484234971.6,1
TIME 0000000e 1484234971.6,3
TIME 0000000e 1484234971.7,1
TIME 0000000e 1484234971.8,1
TIME 0000000e 1484234971.9,1
TIME 0000000c 1484234972,1
TIME 0000000c 1484234972,2
TIME 0000000e 1484234972.1,1
TIME 0000000e 1484234972.2,1
TIME 0000000f 1484234972.2,31
TIME 0000000e 1484234972.3,1
TIME 0000000e 1484234972.4,1
TIME 0000000e 1484234972.5,1
TIME 0000000e 1484234972.6,1
TIME 0000000e 1484234972.7,1
TIME 0000000e 1484234972.8,1
TIME 0000000e 1484234972.9,1
TIME 0000000c 1484234973,1
TIME 0000000e 1484234973.1,1
TIME 0000000e 1484234973.2,1
TIME 0000000e 1484234973.3,1
TIME 0000000e 1484234973.3,3
TIME 0000000e 1484234973.4,1
TIME 0000000e 1484234973.5,1
TIME 0000000e 1484234973.5,2
TIME 0000000f 1484234973.5,31
TIME 0000000e 1484234973.6,1
TIME 0000000e 1484234973.7,1
TIME 0000000e 1484234973.8,1
TIME 0000000e 1484234973.8,2
TIME 0000000e 1484234973.9,1
TIME 0000000e 1484234973.9,3
TIME 0000000c 1484234974,1
TIME 0000000e 1484234974.1,1
TIME 0000000e 1484234974.2,1
TIME 0000000e 1484234974.3,1
TIME 0000000e 1484234974.4,1
TIME 0000000e 1484234974.5,1
TIME 0000000e 1484234974.6,1
TIME 0000000e 1484234974.6,3
TIME 0000000e 1484234974.6,2
TIME 0000000e 1484234974.7,1
TIME 0000000e 1484234974.8,1
TIME 0000000e 1484234974.9,1
TIME 0000000c 1484234975,1
TIME 0000000e 1484234975.1,1
TIME 0000000e 1484234975.2,1
TIME 0000000e 1484234975.3,1
TIME 0000000f 1484234975.3,31
TIME 0000000e 1484234975.4,1
TIME 0000000e 1484234975.4,2
TIME 0000000e 1484234975.5,1
TIME 0000000e 1484234975.6,1
TIME 0000000e 1484234975.7,1
TIME 0000000e 1484234975.7,3
TIME 0000000e 1484234975.8,1
TIME 0000000e 1484234975.9,1
TIME 0000000c 1484234976,1
TIME 0000000e 1484234976.1,1
TIME 0000000e 1484234976.2,1
TIME 0000000e 1484234976.2,2
TIME 0000000e 1484234976.3,1
TIME 0000000e 1484234976.4,1
TIME 0000000e 1484234976.5,1
TIME 0000000e 1484234976.5,2
TIME 0000000e 1484234976.6,1
TIME 0000000e 1484234976.7,1
TIME 0000000e 1484234976.8,1
TIME 0000000e 1484234976.9,1
TIME 0000000c 1484234977,1
TIME 0000000e 1484234977.1,1
TIME 0000000e 1484234977.2,1
TIME 0000000e 1484234977.3,1
TIME 0000000e 1484234977.4,1
TIME 0000000e 1484234977.5,1
TIME 0000000e 1484234977.6,1
TIME 0000000e 1484234977.7,1
TIME 0000000e 1484234977.8,1
TIME 0000000e 1484234977.9,1
TIME 0000000c 1484234978,1
TIME 0000000e 1484234978.1,1
TIME 0000000e 1484234978.2,1
TIME 0000000e 1484234978.3,1
TIME 0000000e 1484234978.4,1
TIME 0000000e 1484234978.5,1
TIME 0000000e 1484234978.6,1
TIME 0000000e 1484234978.7,1
TIME 0000000e 1484234978.7,3
TIME 0000000e 1484234978.7,2
TIME 0000000e 1484234978.8,1
TIME 0000000e 1484234978.9,1
TIME 0000000c 1484234979,1
TIME 0000000e 1484234979.1,1
TIME 0000000e 1484234979.2,1
TIME 0000000e 1484234979.3,1
TIME 0000000e 1484234979.4,1
TIME 0000000e 1484234979.5,1
TIME 0000000e 1484234979.5,3
TIME 0000000e 1484234979.6,1
TIME 0000000e 1484234979.7,1
TIME 0000000e 1484234979.8,1
TIME 0000000e 1484234979.9,1
TIME 0000000c 1484234980,1
TIME 0000000e 1484234980.1,1
TIME 0000000e 1484234980.2,1
TIME 0000000e 1484234980.3,1
TIME 0000000e 1484234980.4,1
TIME 0000000e 1484234980.5,1
TIME 0000000e 1484234980.6,1
TIME 0000000e 1484234980.6,3
TIME 0000000e 1484234980.7,1
TIME 0000000e 1484234980.8,1
TIME 0000000e 1484234980.9,1
TIME 0000000c 1484234981,1
TIME 0000000e 1484234981.1,1
TIME 0000000e 1484234981.2,1
TIME 0000000e 1484234981.3,1
TIME 0000000e 1484234981.4,1
TIME 0000000e 1484234981.5,1
TIME 0000000e 1484234981.6,1
TIME 0000000e 1484234981.6,3
TIME 0000000e 1484234981.7,1
TIME 0000000e 1484234981.8,1
TIME 0000000e 1484234981.9,1
TIME 0000000c 1484234982,1
TIME 0000000e 1484234982.1,1
TIME 0000000e 1484234982.2,1
TIME 0000000e 1484234982.3,1
TIME 0000000e 1484234982.3,2
TIME 0000000e 1484234982.4,1
TIME 0000000e 1484234982.5,1
TIME 0000000e 1484234982.6,1
TIME 0000000e 1484234982.7,1
TIME 0000000e 1484234982.8,1
TIME 0000000e 1484234982.9,1
TIME 0000000e 1484234982.9,3
TIME 0000000c 1484234983,1
TIME 0000000e 1484234983.1,1
TIME 0000000e 1484234983.2,1
TIME 0000000e 1484234983.3,1
TIME 0000000e 1484234983.3,2
TIME 0000000e 1484234983.4,1
TIME 0000000e 1484234983.5,1
TIME 0000000e 1484234983.5,3
TIME 0000000e 1484234983.6,1
TIME 0000000e 1484234983.7,1
TIME 0000000e 1484234983.8,1
TIME 0000000e 1484234983.9,1
TIME 0000000c 1484234984,1
TIME 0000000e 1484234984.1,1
TIME 0000000e 1484234984.2,1
TIME 0000000e 1484234984.3,1
TIME 0000000e 1484234984.3,2
TIME 0000000e 1484234984.4,1
TIME 0000000e 1484234984.4,3
TIME 0000000e 1484234984.5,1
TIME 0000000e 1484234984.6,1
TIME 0000000e 1484234984.7,1
TIME 0000000e 1484234984.8,1
TIME 0000000e 1484234984.9,1
TIME 0000000c 1484234985,1
TIME 0000000e 1484234985.1,1
TIME 0000000e 1484234985.2,1
TIME 0000000e 1484234985.3,1
TIME 0000000e 1484234985.3,3
TIME 0000000e 1484234985.4,1
TIME 0000000e 1484234985.5,1
TIME 0000000e 1484234985.6,1
TIME 0000000e 1484234985.7,1
TIME 0000000e 1484234985.7,2
TIME 0000000e 1484234985.8,1
TIME 0000000e 1484234985.9,1
TIME 0000000e 1484234985.9,3
TIME 0000000c 1484234986,1
TIME 0000000e 1484234986.1,1
TIME 0000000e 1484234986.2,1
TIME 0000000e 1484234986.3,1
TIME 0000000e 1484234986.3,2
TIME 0000000e 1484234986.4,1
TIME 0000000e 1484234986.5,1
TIME 0000000e 1484234986.6,1
TIME 0000000e 1484234986.7,1
TIME 0000000e 1484234986.8,1
TIME 0000000e 1484234986.9,1
TIME 0000000e 1484234986.9,3
TIME 0000000c 1484234987,1
TIME 0000000e 1484234987.1,1
TIME 0000000e 1484234987.2,1
TIME 0000000e 1484234987.3,1
TIME 0000000e 1484234987.4,1
TIME 0000000e 1484234987.5,1
TIME 0000000e 1484234987.5,3
TIME 0000000e 1484234987.6,1
TIME 0000000e 1484234987.7,1
TIME 0000000e 1484234987.7,2
TIME 0000000e 1484234987.8,1
TIME 0000000e 1484234987.9,1
TIME 0000000c 1484234988,1
TIME 0000000c 1484234988,2
TIME 0000000e 1484234988.1,1
TIME 0000000e 1484234988.2,1
TIME 0000000e 1484234988.3,1
TIME 0000000e 1484234988.3,2
TIME 0000000e 1484234988.4,1
TIME 0000000e 1484234988.5,1
TIME 0000000e 1484234988.6,1
TIME 0000000e 1484234988.6,3
TIME 0000000e 1484234988.7,1
TIME 0000000e 1484234988.8,1
TIME 0000000e 1484234988.9,1
TIME 0000000e 1484234988.9,2
TIME 0000000c 1484234989,1
TIME 0000000e 1484234989.1,1
TIME 0000000e 1484234989.2,1
TIME 0000000e 1484234989.3,1
TIME 0000000e 1484234989.4,1
TIME 0000000e 1484234989.4,3
TIME 0000000e 1484234989.5,1
TIME 0000000e 1484234989.6,1
TIME 0000000e 1484234989.7,1
TIME 0000000e 1484234989.8,1
TIME 0000000e 1484234989.9,1
TIME 0000000c 1484234990,1
TIME 0000000e 1484234990.1,1
TIME 0000000e 1484234990.2,1
TIME 0000000e 1484234990.3,1
TIME 0000000e 1484234990.4,1
TIME 0000000e 1484234990.5,1
TIME 0000000e 1484234990.6,1
TIME 0000000e 1484234990.7,1
TIME 0000000e 1484234990.8,1
TIME 0000000e 1484234990.9,1
TIME 0000000e 1484234990.9,3
TIME 0000000c 1484234991,1
TIME 0000000e 1484234991.1,1
TIME 0000000e 1484234991.1,2
TIME 0000000e 1484234991.2,1
TIME 0000000e 1484234991.3,1
TIME 0000000e 1484234991.4,1
TIME 0000000e 1484234991.5,1
TIME 0000000e 1484234991.5,3
TIME 0000000e 1484234991.6,1
TIME 0000000e 1484234991.7,1
TIME 0000000e 1484234991.8,1
TIME 0000000e 1484234991.9,1
TIME 0000000c 1484234992,1
TIME 0000000c 1484234992,2
TIME 0000000e 1484234992.1,1
TIME 0000000e 1484234992.2,1
TIME 0000000e 1484234992.3,1
TIME 0000000e 1484234992.3,2
TIME 0000000e 1484234992.4,1
TIME 0000000e 1484234992.5,1
TIME 0000000e 1484234992.6,1
TIME 0000000e 1484234992.6,3
TIME 0000000e 1484234992.7,1
TIME 0000000e 1484234992.8,1
TIME 0000000e 1484234992.9,1
TIME 0000000e 1484234992.9,2
TIME 0000000c 1484234993,1
TIME 0000000e 1484234993.1,1
TIME 0000000e 1484234993.2,1
TIME 0000000e 1484234993.3,1
TIME 0000000e 1484234993.4,1
TIME 0000000e 1484234993.5,1
TIME 0000000e 1484234993.6,1
TIME 0000000e 1484234993.6,2
TIME 0000000e 1484234993.7,1
TIME 0000000e 1484234993.7,3
TIME 0000000e 1484234993.8,1
TIME 0000000e 1484234993.9,1
TIME 0000000e 1484234993.9,2
TIME 0000000c 1484234994,1
TIME 0000000e 1484234994.1,1
TIME 0000000e 1484234994.2,1
TIME 0000000e 1484234994.2,2
TIME 0000000e 1484234994.3,1
TIME 0000000e 1484234994.4,1
TIME 0000000e 1484234994.5,1
TIME 0000000e 1484234994.5,2
TIME 0000000e 1484234994.6,1
TIME 0000000e 1484234994.7,1
TIME 0000000e 1484234994.8,1
TIME 0000000e 1484234994.8,2
TIME 0000000e 1484234994.9,1
TIME 0000000c 1484234995,1
TIME 0000000e 1484234995.1,1
TIME 0000000e 1484234995.2,1
TIME 0000000e 1484234995.3,1
TIME 0000000e 1484234995.4,1
TIME 0000000e 1484234995.5,1
TIME 0000000e 1484234995.6,1
TIME 0000000e 1484234995.7,1
TIME 0000000e 1484234995.7,3
TIME 0000000e 1484234995.7,2
TIME 0000000e 1484234995.8,1
TIME 0000000e 1484234995.9,1
TIME 0000000c 1484234996,1
TIME 0000000c 1484234996,2
TIME 0000000e 1484234996.1,1
TIME 0000000e 1484234996.2,1
TIME 0000000e 1484234996.3,1
TIME 0000000e 1484234996.3,3
TIME 0000000e 1484234996.4,1
TIME 0000000e 1484234996.5,1
TIME 0000000e 1484234996.6,1
TIME 0000000e 1484234996.7,1
TIME 0000000e 1484234996.7,2
TIME 0000000e 1484234996.8,1
TIME 0000000e 1484234996.9,1
TIME 0000000e 1484234996.9,3
TIME 0000000c 1484234997,1
TIME 0000000e 1484234997.1,1
TIME 0000000e 1484234997.2,1
TIME 0000000e 1484234997.3,1
TIME 0000000e 1484234997.4,1
TIME 0000000e 1484234997.5,1
TIME 0000000e 1484234997.6,1
TIME 0000000e 1484234997.6,2
TIME 0000000e 1484234997.7,1
TIME 0000000e 1484234997.8,1
TIME 0000000e 1484234997.9,1
TIME 0000000c 1484234998,1
TIME 0000000e 1484234998.1,1
TIME 0000000e 1484234998.2,1
TIME 0000000e 1484234998.3,1
TIME 0000000e 1484234998.4,1
TIME 0000000e 1484234998.5,1
TIME 0000000e 1484234998.6,1
TIME 0000000e 1484234998.6,2
TIME 0000000e 1484234998.7,1
TIME 0000000e 1484234998.8,1
TIME 0000000e 1484234998.9,1
TIME 0000000e 1484234998.9,2
TIME 0000000c 1484234999,1
TIME 0000000e 1484234999.1,1
TIME 0000000e 1484234999.2,1
TIME 0000000e 1484234999.3,1
TIME 0000000e 1484234999.4,1
TIME 0000000e 1484234999.4,3
TIME 0000000e 1484234999.5,1
TIME 0000000e 1484234999.6,1
TIME 0000000e 1484234999.7,1
TIME 0000000e 1484234999.8,1
TIME 0000000e 1484234999.9,1
TIME 0000000c 1484235000,1
TIME 0000000c 1484235000,2
TIME 0000000e 1484235000.1,1
TIME 0000000e 1484235000.2,1
TIME 0000000e 1484235000.3,1
TIME 0000000e 1484235000.4,1
TIME 0000000e 1484235000.4,2
TIME 0000000e 1484235000.5,1
TIME 0000000e 1484235000.6,1
TIME 0000000e 1484235000.7,1
TIME 0000000e 1484235000.8,1
TIME 0000000e 1484235000.8,3
TIME 0000000e 1484235000.9,1
TIME 0000000c 1484235001,1
TIME 0000000e 1484235001.1,1
TIME 0000000e 1484235001.2,1
TIME 0000000e 1484235001.3,1
TIME 0000000e 1484235001.4,1
TIME 0000000e 1484235001.4,2
TIME 0000000e 1484235001.5,1
TIME 0000000e 1484235001.6,1
TIME 0000000e 1484235001.7,1
TIME 0000000e 1484235001.8,1
TIME 0000000e 1484235001.9,1
TIME 0000000c 1484235002,1
TIME 0000000e 1484235002.1,1
TIME 0000000e 1484235002.1,2
TIME 0000000e 1484235002.2,1
TIME 0000000e 1484235002.3,1
TIME 0000000e 1484235002.4,1
TIME 0000000e 1484235002.5,1
TIME 0000000e 1484235002.5,3
TIME 0000000e 1484235002.6,1
TIME 0000000e 1484235002.6,2
TIME 0000000e 1484235002.7,1
TIME 0000000e 1484235002.8,1
TIME 0000000f 1484235002.8,29
TIME 0000000f 1484235002.8,30
TIME 0000000f 1484235002.8,32
TIME 0000000f 1484235002.8,31
TIME 0000000e 1484235002.8,4
EVNT 0000008b 10612171611911497990 "",com.softwareag.saep.RawEvent(52,10753295627242564,23353,-15050,-108,1001114,6741407,4661,2298,8543,4779,4892,7294);
EVNT 0000008b 10612171611911497990 "",com.softwareag.saep.RawEvent(10,10753295659083187,-5264,15968,1267,134344,5976079,-5795,4595,6729,-9160,1132,3846);
